
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ChatRoom
 * 
 */
export type ChatRoom = $Result.DefaultSelection<Prisma.$ChatRoomPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model FollowRequest
 * 
 */
export type FollowRequest = $Result.DefaultSelection<Prisma.$FollowRequestPayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model GenreTag
 * 
 */
export type GenreTag = $Result.DefaultSelection<Prisma.$GenreTagPayload>
/**
 * Model GameGenreTag
 * 
 */
export type GameGenreTag = $Result.DefaultSelection<Prisma.$GameGenreTagPayload>
/**
 * Model GameLike
 * 
 */
export type GameLike = $Result.DefaultSelection<Prisma.$GameLikePayload>
/**
 * Model GameRating
 * 
 */
export type GameRating = $Result.DefaultSelection<Prisma.$GameRatingPayload>
/**
 * Model GameCategory
 * 
 */
export type GameCategory = $Result.DefaultSelection<Prisma.$GameCategoryPayload>
/**
 * Model GameSession
 * 
 */
export type GameSession = $Result.DefaultSelection<Prisma.$GameSessionPayload>
/**
 * Model Gift
 * 
 */
export type Gift = $Result.DefaultSelection<Prisma.$GiftPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Stream
 * 
 */
export type Stream = $Result.DefaultSelection<Prisma.$StreamPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model OneSignalPlayer
 * 
 */
export type OneSignalPlayer = $Result.DefaultSelection<Prisma.$OneSignalPlayerPayload>
/**
 * Model TrustedDevice
 * 
 */
export type TrustedDevice = $Result.DefaultSelection<Prisma.$TrustedDevicePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  WIP: 'WIP'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserGender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER',
  PREFER_NOT_SAY: 'PREFER_NOT_SAY'
};

export type UserGender = (typeof UserGender)[keyof typeof UserGender]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  BANNED: 'BANNED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const UserAccountStatus: {
  ACTIVE: 'ACTIVE',
  PENDING_VERIFICATION: 'PENDING_VERIFICATION',
  SUSPENDED: 'SUSPENDED'
};

export type UserAccountStatus = (typeof UserAccountStatus)[keyof typeof UserAccountStatus]


export const ChatRoomType: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE',
  VOICE_ONLY: 'VOICE_ONLY'
};

export type ChatRoomType = (typeof ChatRoomType)[keyof typeof ChatRoomType]


export const ChatRoomStatus: {
  ACTIVE: 'ACTIVE',
  CLOSED: 'CLOSED',
  ARCHIVED: 'ARCHIVED'
};

export type ChatRoomStatus = (typeof ChatRoomStatus)[keyof typeof ChatRoomStatus]


export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  GIFT: 'GIFT',
  SYSTEM: 'SYSTEM'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const TransactionType: {
  COIN_PURCHASE: 'COIN_PURCHASE',
  GIFT_SEND: 'GIFT_SEND',
  DIAMOND_CONVERSION: 'DIAMOND_CONVERSION',
  STREAM_REWARD: 'STREAM_REWARD'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const FollowRequestStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED'
};

export type FollowRequestStatus = (typeof FollowRequestStatus)[keyof typeof FollowRequestStatus]


export const GameSessionStatus: {
  WAITING: 'WAITING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type GameSessionStatus = (typeof GameSessionStatus)[keyof typeof GameSessionStatus]


export const ReportStatus: {
  PENDING: 'PENDING',
  REVIEWED_ACCEPTED: 'REVIEWED_ACCEPTED',
  REVIEWED_REJECTED: 'REVIEWED_REJECTED',
  RESOLVED: 'RESOLVED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const NotificationType: {
  NEW_FOLLOWER: 'NEW_FOLLOWER',
  MESSAGE_RECEIVED: 'MESSAGE_RECEIVED',
  GIFT_RECEIVED: 'GIFT_RECEIVED',
  SYSTEM_ANNOUNCEMENT: 'SYSTEM_ANNOUNCEMENT',
  FRIEND_REQUEST_RECEIVED: 'FRIEND_REQUEST_RECEIVED',
  FRIEND_REQUEST_ACCEPTED: 'FRIEND_REQUEST_ACCEPTED',
  REPORT_UPDATE: 'REPORT_UPDATE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const StreamStatus: {
  LIVE: 'LIVE',
  OFFLINE: 'OFFLINE',
  SCHEDULED: 'SCHEDULED',
  ENDED: 'ENDED'
};

export type StreamStatus = (typeof StreamStatus)[keyof typeof StreamStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserGender = $Enums.UserGender

export const UserGender: typeof $Enums.UserGender

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type UserAccountStatus = $Enums.UserAccountStatus

export const UserAccountStatus: typeof $Enums.UserAccountStatus

export type ChatRoomType = $Enums.ChatRoomType

export const ChatRoomType: typeof $Enums.ChatRoomType

export type ChatRoomStatus = $Enums.ChatRoomStatus

export const ChatRoomStatus: typeof $Enums.ChatRoomStatus

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type FollowRequestStatus = $Enums.FollowRequestStatus

export const FollowRequestStatus: typeof $Enums.FollowRequestStatus

export type GameSessionStatus = $Enums.GameSessionStatus

export const GameSessionStatus: typeof $Enums.GameSessionStatus

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type StreamStatus = $Enums.StreamStatus

export const StreamStatus: typeof $Enums.StreamStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatRoom`: Exposes CRUD operations for the **ChatRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatRooms
    * const chatRooms = await prisma.chatRoom.findMany()
    * ```
    */
  get chatRoom(): Prisma.ChatRoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.followRequest`: Exposes CRUD operations for the **FollowRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FollowRequests
    * const followRequests = await prisma.followRequest.findMany()
    * ```
    */
  get followRequest(): Prisma.FollowRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genreTag`: Exposes CRUD operations for the **GenreTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GenreTags
    * const genreTags = await prisma.genreTag.findMany()
    * ```
    */
  get genreTag(): Prisma.GenreTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameGenreTag`: Exposes CRUD operations for the **GameGenreTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameGenreTags
    * const gameGenreTags = await prisma.gameGenreTag.findMany()
    * ```
    */
  get gameGenreTag(): Prisma.GameGenreTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameLike`: Exposes CRUD operations for the **GameLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameLikes
    * const gameLikes = await prisma.gameLike.findMany()
    * ```
    */
  get gameLike(): Prisma.GameLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameRating`: Exposes CRUD operations for the **GameRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameRatings
    * const gameRatings = await prisma.gameRating.findMany()
    * ```
    */
  get gameRating(): Prisma.GameRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameCategory`: Exposes CRUD operations for the **GameCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameCategories
    * const gameCategories = await prisma.gameCategory.findMany()
    * ```
    */
  get gameCategory(): Prisma.GameCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameSession`: Exposes CRUD operations for the **GameSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameSessions
    * const gameSessions = await prisma.gameSession.findMany()
    * ```
    */
  get gameSession(): Prisma.GameSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gift`: Exposes CRUD operations for the **Gift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gifts
    * const gifts = await prisma.gift.findMany()
    * ```
    */
  get gift(): Prisma.GiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stream`: Exposes CRUD operations for the **Stream** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Streams
    * const streams = await prisma.stream.findMany()
    * ```
    */
  get stream(): Prisma.StreamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oneSignalPlayer`: Exposes CRUD operations for the **OneSignalPlayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OneSignalPlayers
    * const oneSignalPlayers = await prisma.oneSignalPlayer.findMany()
    * ```
    */
  get oneSignalPlayer(): Prisma.OneSignalPlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trustedDevice`: Exposes CRUD operations for the **TrustedDevice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrustedDevices
    * const trustedDevices = await prisma.trustedDevice.findMany()
    * ```
    */
  get trustedDevice(): Prisma.TrustedDeviceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.0
   * Query Engine version: 9c30299f5a0ea26a96790e13f796dc6094db3173
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ChatRoom: 'ChatRoom',
    Message: 'Message',
    Transaction: 'Transaction',
    Follow: 'Follow',
    FollowRequest: 'FollowRequest',
    Game: 'Game',
    GenreTag: 'GenreTag',
    GameGenreTag: 'GameGenreTag',
    GameLike: 'GameLike',
    GameRating: 'GameRating',
    GameCategory: 'GameCategory',
    GameSession: 'GameSession',
    Gift: 'Gift',
    Report: 'Report',
    Notification: 'Notification',
    Stream: 'Stream',
    RefreshToken: 'RefreshToken',
    OneSignalPlayer: 'OneSignalPlayer',
    TrustedDevice: 'TrustedDevice'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "chatRoom" | "message" | "transaction" | "follow" | "followRequest" | "game" | "genreTag" | "gameGenreTag" | "gameLike" | "gameRating" | "gameCategory" | "gameSession" | "gift" | "report" | "notification" | "stream" | "refreshToken" | "oneSignalPlayer" | "trustedDevice"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ChatRoom: {
        payload: Prisma.$ChatRoomPayload<ExtArgs>
        fields: Prisma.ChatRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          findFirst: {
            args: Prisma.ChatRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          findMany: {
            args: Prisma.ChatRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>[]
          }
          create: {
            args: Prisma.ChatRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          createMany: {
            args: Prisma.ChatRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>[]
          }
          delete: {
            args: Prisma.ChatRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          update: {
            args: Prisma.ChatRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          deleteMany: {
            args: Prisma.ChatRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatRoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>[]
          }
          upsert: {
            args: Prisma.ChatRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          aggregate: {
            args: Prisma.ChatRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatRoom>
          }
          groupBy: {
            args: Prisma.ChatRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatRoomCountArgs<ExtArgs>
            result: $Utils.Optional<ChatRoomCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      FollowRequest: {
        payload: Prisma.$FollowRequestPayload<ExtArgs>
        fields: Prisma.FollowRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowRequestPayload>
          }
          findFirst: {
            args: Prisma.FollowRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowRequestPayload>
          }
          findMany: {
            args: Prisma.FollowRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowRequestPayload>[]
          }
          create: {
            args: Prisma.FollowRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowRequestPayload>
          }
          createMany: {
            args: Prisma.FollowRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowRequestPayload>[]
          }
          delete: {
            args: Prisma.FollowRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowRequestPayload>
          }
          update: {
            args: Prisma.FollowRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowRequestPayload>
          }
          deleteMany: {
            args: Prisma.FollowRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowRequestPayload>[]
          }
          upsert: {
            args: Prisma.FollowRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowRequestPayload>
          }
          aggregate: {
            args: Prisma.FollowRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollowRequest>
          }
          groupBy: {
            args: Prisma.FollowRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowRequestCountArgs<ExtArgs>
            result: $Utils.Optional<FollowRequestCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      GenreTag: {
        payload: Prisma.$GenreTagPayload<ExtArgs>
        fields: Prisma.GenreTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenreTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenreTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreTagPayload>
          }
          findFirst: {
            args: Prisma.GenreTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenreTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreTagPayload>
          }
          findMany: {
            args: Prisma.GenreTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreTagPayload>[]
          }
          create: {
            args: Prisma.GenreTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreTagPayload>
          }
          createMany: {
            args: Prisma.GenreTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenreTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreTagPayload>[]
          }
          delete: {
            args: Prisma.GenreTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreTagPayload>
          }
          update: {
            args: Prisma.GenreTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreTagPayload>
          }
          deleteMany: {
            args: Prisma.GenreTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenreTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenreTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreTagPayload>[]
          }
          upsert: {
            args: Prisma.GenreTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreTagPayload>
          }
          aggregate: {
            args: Prisma.GenreTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenreTag>
          }
          groupBy: {
            args: Prisma.GenreTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenreTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenreTagCountArgs<ExtArgs>
            result: $Utils.Optional<GenreTagCountAggregateOutputType> | number
          }
        }
      }
      GameGenreTag: {
        payload: Prisma.$GameGenreTagPayload<ExtArgs>
        fields: Prisma.GameGenreTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameGenreTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameGenreTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameGenreTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameGenreTagPayload>
          }
          findFirst: {
            args: Prisma.GameGenreTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameGenreTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameGenreTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameGenreTagPayload>
          }
          findMany: {
            args: Prisma.GameGenreTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameGenreTagPayload>[]
          }
          create: {
            args: Prisma.GameGenreTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameGenreTagPayload>
          }
          createMany: {
            args: Prisma.GameGenreTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameGenreTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameGenreTagPayload>[]
          }
          delete: {
            args: Prisma.GameGenreTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameGenreTagPayload>
          }
          update: {
            args: Prisma.GameGenreTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameGenreTagPayload>
          }
          deleteMany: {
            args: Prisma.GameGenreTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameGenreTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameGenreTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameGenreTagPayload>[]
          }
          upsert: {
            args: Prisma.GameGenreTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameGenreTagPayload>
          }
          aggregate: {
            args: Prisma.GameGenreTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameGenreTag>
          }
          groupBy: {
            args: Prisma.GameGenreTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGenreTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameGenreTagCountArgs<ExtArgs>
            result: $Utils.Optional<GameGenreTagCountAggregateOutputType> | number
          }
        }
      }
      GameLike: {
        payload: Prisma.$GameLikePayload<ExtArgs>
        fields: Prisma.GameLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLikePayload>
          }
          findFirst: {
            args: Prisma.GameLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLikePayload>
          }
          findMany: {
            args: Prisma.GameLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLikePayload>[]
          }
          create: {
            args: Prisma.GameLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLikePayload>
          }
          createMany: {
            args: Prisma.GameLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLikePayload>[]
          }
          delete: {
            args: Prisma.GameLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLikePayload>
          }
          update: {
            args: Prisma.GameLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLikePayload>
          }
          deleteMany: {
            args: Prisma.GameLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLikePayload>[]
          }
          upsert: {
            args: Prisma.GameLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameLikePayload>
          }
          aggregate: {
            args: Prisma.GameLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameLike>
          }
          groupBy: {
            args: Prisma.GameLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameLikeCountArgs<ExtArgs>
            result: $Utils.Optional<GameLikeCountAggregateOutputType> | number
          }
        }
      }
      GameRating: {
        payload: Prisma.$GameRatingPayload<ExtArgs>
        fields: Prisma.GameRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameRatingPayload>
          }
          findFirst: {
            args: Prisma.GameRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameRatingPayload>
          }
          findMany: {
            args: Prisma.GameRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameRatingPayload>[]
          }
          create: {
            args: Prisma.GameRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameRatingPayload>
          }
          createMany: {
            args: Prisma.GameRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameRatingPayload>[]
          }
          delete: {
            args: Prisma.GameRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameRatingPayload>
          }
          update: {
            args: Prisma.GameRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameRatingPayload>
          }
          deleteMany: {
            args: Prisma.GameRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameRatingPayload>[]
          }
          upsert: {
            args: Prisma.GameRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameRatingPayload>
          }
          aggregate: {
            args: Prisma.GameRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameRating>
          }
          groupBy: {
            args: Prisma.GameRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameRatingCountArgs<ExtArgs>
            result: $Utils.Optional<GameRatingCountAggregateOutputType> | number
          }
        }
      }
      GameCategory: {
        payload: Prisma.$GameCategoryPayload<ExtArgs>
        fields: Prisma.GameCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>
          }
          findFirst: {
            args: Prisma.GameCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>
          }
          findMany: {
            args: Prisma.GameCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>[]
          }
          create: {
            args: Prisma.GameCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>
          }
          createMany: {
            args: Prisma.GameCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>[]
          }
          delete: {
            args: Prisma.GameCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>
          }
          update: {
            args: Prisma.GameCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>
          }
          deleteMany: {
            args: Prisma.GameCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>[]
          }
          upsert: {
            args: Prisma.GameCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCategoryPayload>
          }
          aggregate: {
            args: Prisma.GameCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameCategory>
          }
          groupBy: {
            args: Prisma.GameCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<GameCategoryCountAggregateOutputType> | number
          }
        }
      }
      GameSession: {
        payload: Prisma.$GameSessionPayload<ExtArgs>
        fields: Prisma.GameSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          findFirst: {
            args: Prisma.GameSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          findMany: {
            args: Prisma.GameSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>[]
          }
          create: {
            args: Prisma.GameSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          createMany: {
            args: Prisma.GameSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>[]
          }
          delete: {
            args: Prisma.GameSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          update: {
            args: Prisma.GameSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          deleteMany: {
            args: Prisma.GameSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>[]
          }
          upsert: {
            args: Prisma.GameSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          aggregate: {
            args: Prisma.GameSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameSession>
          }
          groupBy: {
            args: Prisma.GameSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameSessionCountArgs<ExtArgs>
            result: $Utils.Optional<GameSessionCountAggregateOutputType> | number
          }
        }
      }
      Gift: {
        payload: Prisma.$GiftPayload<ExtArgs>
        fields: Prisma.GiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftPayload>
          }
          findFirst: {
            args: Prisma.GiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftPayload>
          }
          findMany: {
            args: Prisma.GiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftPayload>[]
          }
          create: {
            args: Prisma.GiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftPayload>
          }
          createMany: {
            args: Prisma.GiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftPayload>[]
          }
          delete: {
            args: Prisma.GiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftPayload>
          }
          update: {
            args: Prisma.GiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftPayload>
          }
          deleteMany: {
            args: Prisma.GiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftPayload>[]
          }
          upsert: {
            args: Prisma.GiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftPayload>
          }
          aggregate: {
            args: Prisma.GiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGift>
          }
          groupBy: {
            args: Prisma.GiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<GiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.GiftCountArgs<ExtArgs>
            result: $Utils.Optional<GiftCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Stream: {
        payload: Prisma.$StreamPayload<ExtArgs>
        fields: Prisma.StreamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StreamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StreamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>
          }
          findFirst: {
            args: Prisma.StreamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StreamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>
          }
          findMany: {
            args: Prisma.StreamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>[]
          }
          create: {
            args: Prisma.StreamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>
          }
          createMany: {
            args: Prisma.StreamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StreamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>[]
          }
          delete: {
            args: Prisma.StreamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>
          }
          update: {
            args: Prisma.StreamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>
          }
          deleteMany: {
            args: Prisma.StreamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StreamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StreamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>[]
          }
          upsert: {
            args: Prisma.StreamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>
          }
          aggregate: {
            args: Prisma.StreamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStream>
          }
          groupBy: {
            args: Prisma.StreamGroupByArgs<ExtArgs>
            result: $Utils.Optional<StreamGroupByOutputType>[]
          }
          count: {
            args: Prisma.StreamCountArgs<ExtArgs>
            result: $Utils.Optional<StreamCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      OneSignalPlayer: {
        payload: Prisma.$OneSignalPlayerPayload<ExtArgs>
        fields: Prisma.OneSignalPlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OneSignalPlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneSignalPlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OneSignalPlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneSignalPlayerPayload>
          }
          findFirst: {
            args: Prisma.OneSignalPlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneSignalPlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OneSignalPlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneSignalPlayerPayload>
          }
          findMany: {
            args: Prisma.OneSignalPlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneSignalPlayerPayload>[]
          }
          create: {
            args: Prisma.OneSignalPlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneSignalPlayerPayload>
          }
          createMany: {
            args: Prisma.OneSignalPlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OneSignalPlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneSignalPlayerPayload>[]
          }
          delete: {
            args: Prisma.OneSignalPlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneSignalPlayerPayload>
          }
          update: {
            args: Prisma.OneSignalPlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneSignalPlayerPayload>
          }
          deleteMany: {
            args: Prisma.OneSignalPlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OneSignalPlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OneSignalPlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneSignalPlayerPayload>[]
          }
          upsert: {
            args: Prisma.OneSignalPlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneSignalPlayerPayload>
          }
          aggregate: {
            args: Prisma.OneSignalPlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOneSignalPlayer>
          }
          groupBy: {
            args: Prisma.OneSignalPlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<OneSignalPlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.OneSignalPlayerCountArgs<ExtArgs>
            result: $Utils.Optional<OneSignalPlayerCountAggregateOutputType> | number
          }
        }
      }
      TrustedDevice: {
        payload: Prisma.$TrustedDevicePayload<ExtArgs>
        fields: Prisma.TrustedDeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrustedDeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustedDevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrustedDeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustedDevicePayload>
          }
          findFirst: {
            args: Prisma.TrustedDeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustedDevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrustedDeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustedDevicePayload>
          }
          findMany: {
            args: Prisma.TrustedDeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustedDevicePayload>[]
          }
          create: {
            args: Prisma.TrustedDeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustedDevicePayload>
          }
          createMany: {
            args: Prisma.TrustedDeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrustedDeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustedDevicePayload>[]
          }
          delete: {
            args: Prisma.TrustedDeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustedDevicePayload>
          }
          update: {
            args: Prisma.TrustedDeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustedDevicePayload>
          }
          deleteMany: {
            args: Prisma.TrustedDeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrustedDeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrustedDeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustedDevicePayload>[]
          }
          upsert: {
            args: Prisma.TrustedDeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustedDevicePayload>
          }
          aggregate: {
            args: Prisma.TrustedDeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrustedDevice>
          }
          groupBy: {
            args: Prisma.TrustedDeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrustedDeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrustedDeviceCountArgs<ExtArgs>
            result: $Utils.Optional<TrustedDeviceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    chatRoom?: ChatRoomOmit
    message?: MessageOmit
    transaction?: TransactionOmit
    follow?: FollowOmit
    followRequest?: FollowRequestOmit
    game?: GameOmit
    genreTag?: GenreTagOmit
    gameGenreTag?: GameGenreTagOmit
    gameLike?: GameLikeOmit
    gameRating?: GameRatingOmit
    gameCategory?: GameCategoryOmit
    gameSession?: GameSessionOmit
    gift?: GiftOmit
    report?: ReportOmit
    notification?: NotificationOmit
    stream?: StreamOmit
    refreshToken?: RefreshTokenOmit
    oneSignalPlayer?: OneSignalPlayerOmit
    trustedDevice?: TrustedDeviceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    invitedUsers: number
    trustedDevices: number
    refreshTokens: number
    oneSignalPlayers: number
    transactions: number
    sentMessages: number
    receivedMessages: number
    reportsMade: number
    reportsReceived: number
    reviewedReports: number
    hostedGameSessions: number
    streams: number
    ownedChatRooms: number
    sentFollowRequests: number
    receivedFollowRequests: number
    followedBy: number
    following: number
    likedGames: number
    gameRatings: number
    notifications: number
    sentNotifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedUsers?: boolean | UserCountOutputTypeCountInvitedUsersArgs
    trustedDevices?: boolean | UserCountOutputTypeCountTrustedDevicesArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    oneSignalPlayers?: boolean | UserCountOutputTypeCountOneSignalPlayersArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    reportsMade?: boolean | UserCountOutputTypeCountReportsMadeArgs
    reportsReceived?: boolean | UserCountOutputTypeCountReportsReceivedArgs
    reviewedReports?: boolean | UserCountOutputTypeCountReviewedReportsArgs
    hostedGameSessions?: boolean | UserCountOutputTypeCountHostedGameSessionsArgs
    streams?: boolean | UserCountOutputTypeCountStreamsArgs
    ownedChatRooms?: boolean | UserCountOutputTypeCountOwnedChatRoomsArgs
    sentFollowRequests?: boolean | UserCountOutputTypeCountSentFollowRequestsArgs
    receivedFollowRequests?: boolean | UserCountOutputTypeCountReceivedFollowRequestsArgs
    followedBy?: boolean | UserCountOutputTypeCountFollowedByArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
    likedGames?: boolean | UserCountOutputTypeCountLikedGamesArgs
    gameRatings?: boolean | UserCountOutputTypeCountGameRatingsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    sentNotifications?: boolean | UserCountOutputTypeCountSentNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrustedDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrustedDeviceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOneSignalPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OneSignalPlayerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHostedGameSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStreamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedChatRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatRoomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentFollowRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedFollowRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikedGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGameRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ChatRoomCountOutputType
   */

  export type ChatRoomCountOutputType = {
    messages: number
    reports: number
  }

  export type ChatRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatRoomCountOutputTypeCountMessagesArgs
    reports?: boolean | ChatRoomCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * ChatRoomCountOutputType without action
   */
  export type ChatRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoomCountOutputType
     */
    select?: ChatRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatRoomCountOutputType without action
   */
  export type ChatRoomCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ChatRoomCountOutputType without action
   */
  export type ChatRoomCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    replies: number
    reports: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | MessageCountOutputTypeCountRepliesArgs
    reports?: boolean | MessageCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    gameGenreTags: number
    gameSessions: number
    likes: number
    ratings: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameGenreTags?: boolean | GameCountOutputTypeCountGameGenreTagsArgs
    gameSessions?: boolean | GameCountOutputTypeCountGameSessionsArgs
    likes?: boolean | GameCountOutputTypeCountLikesArgs
    ratings?: boolean | GameCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountGameGenreTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameGenreTagWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountGameSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameLikeWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameRatingWhereInput
  }


  /**
   * Count Type GenreTagCountOutputType
   */

  export type GenreTagCountOutputType = {
    gameGenreTags: number
  }

  export type GenreTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameGenreTags?: boolean | GenreTagCountOutputTypeCountGameGenreTagsArgs
  }

  // Custom InputTypes
  /**
   * GenreTagCountOutputType without action
   */
  export type GenreTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTagCountOutputType
     */
    select?: GenreTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenreTagCountOutputType without action
   */
  export type GenreTagCountOutputTypeCountGameGenreTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameGenreTagWhereInput
  }


  /**
   * Count Type GameCategoryCountOutputType
   */

  export type GameCategoryCountOutputType = {
    games: number
  }

  export type GameCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | GameCategoryCountOutputTypeCountGamesArgs
  }

  // Custom InputTypes
  /**
   * GameCategoryCountOutputType without action
   */
  export type GameCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategoryCountOutputType
     */
    select?: GameCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCategoryCountOutputType without action
   */
  export type GameCategoryCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }


  /**
   * Count Type GiftCountOutputType
   */

  export type GiftCountOutputType = {
    messages: number
  }

  export type GiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | GiftCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * GiftCountOutputType without action
   */
  export type GiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCountOutputType
     */
    select?: GiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GiftCountOutputType without action
   */
  export type GiftCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type StreamCountOutputType
   */

  export type StreamCountOutputType = {
    reports: number
  }

  export type StreamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | StreamCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * StreamCountOutputType without action
   */
  export type StreamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamCountOutputType
     */
    select?: StreamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StreamCountOutputType without action
   */
  export type StreamCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    level: number | null
    vipLevel: number | null
    coins: number | null
    diamonds: number | null
    followingCount: number | null
    followerCount: number | null
    postCount: number | null
  }

  export type UserSumAggregateOutputType = {
    level: number | null
    vipLevel: number | null
    coins: bigint | null
    diamonds: bigint | null
    followingCount: number | null
    followerCount: number | null
    postCount: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    authProvider: string | null
    authId: string | null
    username: string | null
    nickname: string | null
    profilePictureUrl: string | null
    bio: string | null
    gender: $Enums.UserGender | null
    birthDate: Date | null
    country: string | null
    region: string | null
    level: number | null
    vipLevel: number | null
    coins: bigint | null
    diamonds: bigint | null
    email: string | null
    password: string | null
    passwordChangedAt: Date | null
    isEmailVerified: boolean | null
    lastLoginAt: Date | null
    followingCount: number | null
    followerCount: number | null
    status: $Enums.UserStatus | null
    isOnline: boolean | null
    allowDirectMessages: boolean | null
    accountStatus: $Enums.UserAccountStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    role: $Enums.UserRole | null
    isPrivate: boolean | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    emailVerificationToken: string | null
    emailVerificationExpiresAt: Date | null
    passwordResetToken: string | null
    passwordResetExpiresAt: Date | null
    postCount: number | null
    invitedByForeignKey: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    authProvider: string | null
    authId: string | null
    username: string | null
    nickname: string | null
    profilePictureUrl: string | null
    bio: string | null
    gender: $Enums.UserGender | null
    birthDate: Date | null
    country: string | null
    region: string | null
    level: number | null
    vipLevel: number | null
    coins: bigint | null
    diamonds: bigint | null
    email: string | null
    password: string | null
    passwordChangedAt: Date | null
    isEmailVerified: boolean | null
    lastLoginAt: Date | null
    followingCount: number | null
    followerCount: number | null
    status: $Enums.UserStatus | null
    isOnline: boolean | null
    allowDirectMessages: boolean | null
    accountStatus: $Enums.UserAccountStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    role: $Enums.UserRole | null
    isPrivate: boolean | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    emailVerificationToken: string | null
    emailVerificationExpiresAt: Date | null
    passwordResetToken: string | null
    passwordResetExpiresAt: Date | null
    postCount: number | null
    invitedByForeignKey: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    authProvider: number
    authId: number
    username: number
    nickname: number
    profilePictureUrl: number
    bio: number
    gender: number
    birthDate: number
    country: number
    region: number
    level: number
    vipLevel: number
    coins: number
    diamonds: number
    email: number
    password: number
    passwordChangedAt: number
    isEmailVerified: number
    lastLoginAt: number
    followingCount: number
    followerCount: number
    status: number
    isOnline: number
    preferences: number
    allowDirectMessages: number
    notificationSettings: number
    blockedUserIds: number
    accountStatus: number
    createdAt: number
    updatedAt: number
    role: number
    isPrivate: number
    pinnedMessagesInRooms: number
    twoFactorEnabled: number
    twoFactorSecret: number
    twoFactorRecoveryCodes: number
    emailVerificationToken: number
    emailVerificationExpiresAt: number
    passwordResetToken: number
    passwordResetExpiresAt: number
    postCount: number
    invitedByForeignKey: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    level?: true
    vipLevel?: true
    coins?: true
    diamonds?: true
    followingCount?: true
    followerCount?: true
    postCount?: true
  }

  export type UserSumAggregateInputType = {
    level?: true
    vipLevel?: true
    coins?: true
    diamonds?: true
    followingCount?: true
    followerCount?: true
    postCount?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    authProvider?: true
    authId?: true
    username?: true
    nickname?: true
    profilePictureUrl?: true
    bio?: true
    gender?: true
    birthDate?: true
    country?: true
    region?: true
    level?: true
    vipLevel?: true
    coins?: true
    diamonds?: true
    email?: true
    password?: true
    passwordChangedAt?: true
    isEmailVerified?: true
    lastLoginAt?: true
    followingCount?: true
    followerCount?: true
    status?: true
    isOnline?: true
    allowDirectMessages?: true
    accountStatus?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    isPrivate?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    emailVerificationToken?: true
    emailVerificationExpiresAt?: true
    passwordResetToken?: true
    passwordResetExpiresAt?: true
    postCount?: true
    invitedByForeignKey?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    authProvider?: true
    authId?: true
    username?: true
    nickname?: true
    profilePictureUrl?: true
    bio?: true
    gender?: true
    birthDate?: true
    country?: true
    region?: true
    level?: true
    vipLevel?: true
    coins?: true
    diamonds?: true
    email?: true
    password?: true
    passwordChangedAt?: true
    isEmailVerified?: true
    lastLoginAt?: true
    followingCount?: true
    followerCount?: true
    status?: true
    isOnline?: true
    allowDirectMessages?: true
    accountStatus?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    isPrivate?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    emailVerificationToken?: true
    emailVerificationExpiresAt?: true
    passwordResetToken?: true
    passwordResetExpiresAt?: true
    postCount?: true
    invitedByForeignKey?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    authProvider?: true
    authId?: true
    username?: true
    nickname?: true
    profilePictureUrl?: true
    bio?: true
    gender?: true
    birthDate?: true
    country?: true
    region?: true
    level?: true
    vipLevel?: true
    coins?: true
    diamonds?: true
    email?: true
    password?: true
    passwordChangedAt?: true
    isEmailVerified?: true
    lastLoginAt?: true
    followingCount?: true
    followerCount?: true
    status?: true
    isOnline?: true
    preferences?: true
    allowDirectMessages?: true
    notificationSettings?: true
    blockedUserIds?: true
    accountStatus?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    isPrivate?: true
    pinnedMessagesInRooms?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    twoFactorRecoveryCodes?: true
    emailVerificationToken?: true
    emailVerificationExpiresAt?: true
    passwordResetToken?: true
    passwordResetExpiresAt?: true
    postCount?: true
    invitedByForeignKey?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    authProvider: string | null
    authId: string | null
    username: string
    nickname: string | null
    profilePictureUrl: string | null
    bio: string | null
    gender: $Enums.UserGender | null
    birthDate: Date | null
    country: string | null
    region: string | null
    level: number
    vipLevel: number
    coins: bigint
    diamonds: bigint
    email: string
    password: string | null
    passwordChangedAt: Date | null
    isEmailVerified: boolean
    lastLoginAt: Date | null
    followingCount: number
    followerCount: number
    status: $Enums.UserStatus
    isOnline: boolean
    preferences: JsonValue | null
    allowDirectMessages: boolean
    notificationSettings: JsonValue | null
    blockedUserIds: JsonValue | null
    accountStatus: $Enums.UserAccountStatus
    createdAt: Date
    updatedAt: Date
    role: $Enums.UserRole
    isPrivate: boolean
    pinnedMessagesInRooms: JsonValue | null
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    twoFactorRecoveryCodes: JsonValue | null
    emailVerificationToken: string | null
    emailVerificationExpiresAt: Date | null
    passwordResetToken: string | null
    passwordResetExpiresAt: Date | null
    postCount: number
    invitedByForeignKey: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authProvider?: boolean
    authId?: boolean
    username?: boolean
    nickname?: boolean
    profilePictureUrl?: boolean
    bio?: boolean
    gender?: boolean
    birthDate?: boolean
    country?: boolean
    region?: boolean
    level?: boolean
    vipLevel?: boolean
    coins?: boolean
    diamonds?: boolean
    email?: boolean
    password?: boolean
    passwordChangedAt?: boolean
    isEmailVerified?: boolean
    lastLoginAt?: boolean
    followingCount?: boolean
    followerCount?: boolean
    status?: boolean
    isOnline?: boolean
    preferences?: boolean
    allowDirectMessages?: boolean
    notificationSettings?: boolean
    blockedUserIds?: boolean
    accountStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    isPrivate?: boolean
    pinnedMessagesInRooms?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorRecoveryCodes?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpiresAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpiresAt?: boolean
    postCount?: boolean
    invitedByForeignKey?: boolean
    invitedUsers?: boolean | User$invitedUsersArgs<ExtArgs>
    invitedBy?: boolean | User$invitedByArgs<ExtArgs>
    trustedDevices?: boolean | User$trustedDevicesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    oneSignalPlayers?: boolean | User$oneSignalPlayersArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    reportsMade?: boolean | User$reportsMadeArgs<ExtArgs>
    reportsReceived?: boolean | User$reportsReceivedArgs<ExtArgs>
    reviewedReports?: boolean | User$reviewedReportsArgs<ExtArgs>
    hostedGameSessions?: boolean | User$hostedGameSessionsArgs<ExtArgs>
    streams?: boolean | User$streamsArgs<ExtArgs>
    ownedChatRooms?: boolean | User$ownedChatRoomsArgs<ExtArgs>
    sentFollowRequests?: boolean | User$sentFollowRequestsArgs<ExtArgs>
    receivedFollowRequests?: boolean | User$receivedFollowRequestsArgs<ExtArgs>
    followedBy?: boolean | User$followedByArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    likedGames?: boolean | User$likedGamesArgs<ExtArgs>
    gameRatings?: boolean | User$gameRatingsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authProvider?: boolean
    authId?: boolean
    username?: boolean
    nickname?: boolean
    profilePictureUrl?: boolean
    bio?: boolean
    gender?: boolean
    birthDate?: boolean
    country?: boolean
    region?: boolean
    level?: boolean
    vipLevel?: boolean
    coins?: boolean
    diamonds?: boolean
    email?: boolean
    password?: boolean
    passwordChangedAt?: boolean
    isEmailVerified?: boolean
    lastLoginAt?: boolean
    followingCount?: boolean
    followerCount?: boolean
    status?: boolean
    isOnline?: boolean
    preferences?: boolean
    allowDirectMessages?: boolean
    notificationSettings?: boolean
    blockedUserIds?: boolean
    accountStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    isPrivate?: boolean
    pinnedMessagesInRooms?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorRecoveryCodes?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpiresAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpiresAt?: boolean
    postCount?: boolean
    invitedByForeignKey?: boolean
    invitedBy?: boolean | User$invitedByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authProvider?: boolean
    authId?: boolean
    username?: boolean
    nickname?: boolean
    profilePictureUrl?: boolean
    bio?: boolean
    gender?: boolean
    birthDate?: boolean
    country?: boolean
    region?: boolean
    level?: boolean
    vipLevel?: boolean
    coins?: boolean
    diamonds?: boolean
    email?: boolean
    password?: boolean
    passwordChangedAt?: boolean
    isEmailVerified?: boolean
    lastLoginAt?: boolean
    followingCount?: boolean
    followerCount?: boolean
    status?: boolean
    isOnline?: boolean
    preferences?: boolean
    allowDirectMessages?: boolean
    notificationSettings?: boolean
    blockedUserIds?: boolean
    accountStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    isPrivate?: boolean
    pinnedMessagesInRooms?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorRecoveryCodes?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpiresAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpiresAt?: boolean
    postCount?: boolean
    invitedByForeignKey?: boolean
    invitedBy?: boolean | User$invitedByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    authProvider?: boolean
    authId?: boolean
    username?: boolean
    nickname?: boolean
    profilePictureUrl?: boolean
    bio?: boolean
    gender?: boolean
    birthDate?: boolean
    country?: boolean
    region?: boolean
    level?: boolean
    vipLevel?: boolean
    coins?: boolean
    diamonds?: boolean
    email?: boolean
    password?: boolean
    passwordChangedAt?: boolean
    isEmailVerified?: boolean
    lastLoginAt?: boolean
    followingCount?: boolean
    followerCount?: boolean
    status?: boolean
    isOnline?: boolean
    preferences?: boolean
    allowDirectMessages?: boolean
    notificationSettings?: boolean
    blockedUserIds?: boolean
    accountStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    isPrivate?: boolean
    pinnedMessagesInRooms?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorRecoveryCodes?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpiresAt?: boolean
    passwordResetToken?: boolean
    passwordResetExpiresAt?: boolean
    postCount?: boolean
    invitedByForeignKey?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authProvider" | "authId" | "username" | "nickname" | "profilePictureUrl" | "bio" | "gender" | "birthDate" | "country" | "region" | "level" | "vipLevel" | "coins" | "diamonds" | "email" | "password" | "passwordChangedAt" | "isEmailVerified" | "lastLoginAt" | "followingCount" | "followerCount" | "status" | "isOnline" | "preferences" | "allowDirectMessages" | "notificationSettings" | "blockedUserIds" | "accountStatus" | "createdAt" | "updatedAt" | "role" | "isPrivate" | "pinnedMessagesInRooms" | "twoFactorEnabled" | "twoFactorSecret" | "twoFactorRecoveryCodes" | "emailVerificationToken" | "emailVerificationExpiresAt" | "passwordResetToken" | "passwordResetExpiresAt" | "postCount" | "invitedByForeignKey", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedUsers?: boolean | User$invitedUsersArgs<ExtArgs>
    invitedBy?: boolean | User$invitedByArgs<ExtArgs>
    trustedDevices?: boolean | User$trustedDevicesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    oneSignalPlayers?: boolean | User$oneSignalPlayersArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    reportsMade?: boolean | User$reportsMadeArgs<ExtArgs>
    reportsReceived?: boolean | User$reportsReceivedArgs<ExtArgs>
    reviewedReports?: boolean | User$reviewedReportsArgs<ExtArgs>
    hostedGameSessions?: boolean | User$hostedGameSessionsArgs<ExtArgs>
    streams?: boolean | User$streamsArgs<ExtArgs>
    ownedChatRooms?: boolean | User$ownedChatRoomsArgs<ExtArgs>
    sentFollowRequests?: boolean | User$sentFollowRequestsArgs<ExtArgs>
    receivedFollowRequests?: boolean | User$receivedFollowRequestsArgs<ExtArgs>
    followedBy?: boolean | User$followedByArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    likedGames?: boolean | User$likedGamesArgs<ExtArgs>
    gameRatings?: boolean | User$gameRatingsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedBy?: boolean | User$invitedByArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedBy?: boolean | User$invitedByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      invitedUsers: Prisma.$UserPayload<ExtArgs>[]
      invitedBy: Prisma.$UserPayload<ExtArgs> | null
      trustedDevices: Prisma.$TrustedDevicePayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      oneSignalPlayers: Prisma.$OneSignalPlayerPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      reportsMade: Prisma.$ReportPayload<ExtArgs>[]
      reportsReceived: Prisma.$ReportPayload<ExtArgs>[]
      reviewedReports: Prisma.$ReportPayload<ExtArgs>[]
      hostedGameSessions: Prisma.$GameSessionPayload<ExtArgs>[]
      streams: Prisma.$StreamPayload<ExtArgs>[]
      ownedChatRooms: Prisma.$ChatRoomPayload<ExtArgs>[]
      sentFollowRequests: Prisma.$FollowRequestPayload<ExtArgs>[]
      receivedFollowRequests: Prisma.$FollowRequestPayload<ExtArgs>[]
      followedBy: Prisma.$FollowPayload<ExtArgs>[]
      following: Prisma.$FollowPayload<ExtArgs>[]
      likedGames: Prisma.$GameLikePayload<ExtArgs>[]
      gameRatings: Prisma.$GameRatingPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      sentNotifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authProvider: string | null
      authId: string | null
      username: string
      nickname: string | null
      profilePictureUrl: string | null
      bio: string | null
      gender: $Enums.UserGender | null
      birthDate: Date | null
      country: string | null
      region: string | null
      level: number
      vipLevel: number
      coins: bigint
      diamonds: bigint
      email: string
      password: string | null
      passwordChangedAt: Date | null
      isEmailVerified: boolean
      lastLoginAt: Date | null
      followingCount: number
      followerCount: number
      status: $Enums.UserStatus
      isOnline: boolean
      preferences: Prisma.JsonValue | null
      allowDirectMessages: boolean
      notificationSettings: Prisma.JsonValue | null
      blockedUserIds: Prisma.JsonValue | null
      accountStatus: $Enums.UserAccountStatus
      createdAt: Date
      updatedAt: Date
      role: $Enums.UserRole
      isPrivate: boolean
      pinnedMessagesInRooms: Prisma.JsonValue | null
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      twoFactorRecoveryCodes: Prisma.JsonValue | null
      emailVerificationToken: string | null
      emailVerificationExpiresAt: Date | null
      passwordResetToken: string | null
      passwordResetExpiresAt: Date | null
      postCount: number
      invitedByForeignKey: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invitedUsers<T extends User$invitedUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$invitedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitedBy<T extends User$invitedByArgs<ExtArgs> = {}>(args?: Subset<T, User$invitedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    trustedDevices<T extends User$trustedDevicesArgs<ExtArgs> = {}>(args?: Subset<T, User$trustedDevicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustedDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    oneSignalPlayers<T extends User$oneSignalPlayersArgs<ExtArgs> = {}>(args?: Subset<T, User$oneSignalPlayersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneSignalPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportsMade<T extends User$reportsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportsReceived<T extends User$reportsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewedReports<T extends User$reviewedReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hostedGameSessions<T extends User$hostedGameSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$hostedGameSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    streams<T extends User$streamsArgs<ExtArgs> = {}>(args?: Subset<T, User$streamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedChatRooms<T extends User$ownedChatRoomsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedChatRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentFollowRequests<T extends User$sentFollowRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentFollowRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedFollowRequests<T extends User$receivedFollowRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedFollowRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followedBy<T extends User$followedByArgs<ExtArgs> = {}>(args?: Subset<T, User$followedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedGames<T extends User$likedGamesArgs<ExtArgs> = {}>(args?: Subset<T, User$likedGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gameRatings<T extends User$gameRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$gameRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentNotifications<T extends User$sentNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly authProvider: FieldRef<"User", 'String'>
    readonly authId: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly nickname: FieldRef<"User", 'String'>
    readonly profilePictureUrl: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'UserGender'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly country: FieldRef<"User", 'String'>
    readonly region: FieldRef<"User", 'String'>
    readonly level: FieldRef<"User", 'Int'>
    readonly vipLevel: FieldRef<"User", 'Int'>
    readonly coins: FieldRef<"User", 'BigInt'>
    readonly diamonds: FieldRef<"User", 'BigInt'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly passwordChangedAt: FieldRef<"User", 'DateTime'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly followingCount: FieldRef<"User", 'Int'>
    readonly followerCount: FieldRef<"User", 'Int'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly isOnline: FieldRef<"User", 'Boolean'>
    readonly preferences: FieldRef<"User", 'Json'>
    readonly allowDirectMessages: FieldRef<"User", 'Boolean'>
    readonly notificationSettings: FieldRef<"User", 'Json'>
    readonly blockedUserIds: FieldRef<"User", 'Json'>
    readonly accountStatus: FieldRef<"User", 'UserAccountStatus'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isPrivate: FieldRef<"User", 'Boolean'>
    readonly pinnedMessagesInRooms: FieldRef<"User", 'Json'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly twoFactorRecoveryCodes: FieldRef<"User", 'Json'>
    readonly emailVerificationToken: FieldRef<"User", 'String'>
    readonly emailVerificationExpiresAt: FieldRef<"User", 'DateTime'>
    readonly passwordResetToken: FieldRef<"User", 'String'>
    readonly passwordResetExpiresAt: FieldRef<"User", 'DateTime'>
    readonly postCount: FieldRef<"User", 'Int'>
    readonly invitedByForeignKey: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.invitedUsers
   */
  export type User$invitedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.invitedBy
   */
  export type User$invitedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.trustedDevices
   */
  export type User$trustedDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceInclude<ExtArgs> | null
    where?: TrustedDeviceWhereInput
    orderBy?: TrustedDeviceOrderByWithRelationInput | TrustedDeviceOrderByWithRelationInput[]
    cursor?: TrustedDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrustedDeviceScalarFieldEnum | TrustedDeviceScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.oneSignalPlayers
   */
  export type User$oneSignalPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerInclude<ExtArgs> | null
    where?: OneSignalPlayerWhereInput
    orderBy?: OneSignalPlayerOrderByWithRelationInput | OneSignalPlayerOrderByWithRelationInput[]
    cursor?: OneSignalPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OneSignalPlayerScalarFieldEnum | OneSignalPlayerScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.reportsMade
   */
  export type User$reportsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.reportsReceived
   */
  export type User$reportsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.reviewedReports
   */
  export type User$reviewedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.hostedGameSessions
   */
  export type User$hostedGameSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    cursor?: GameSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * User.streams
   */
  export type User$streamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    where?: StreamWhereInput
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[]
    cursor?: StreamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StreamScalarFieldEnum | StreamScalarFieldEnum[]
  }

  /**
   * User.ownedChatRooms
   */
  export type User$ownedChatRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    where?: ChatRoomWhereInput
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    cursor?: ChatRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * User.sentFollowRequests
   */
  export type User$sentFollowRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestInclude<ExtArgs> | null
    where?: FollowRequestWhereInput
    orderBy?: FollowRequestOrderByWithRelationInput | FollowRequestOrderByWithRelationInput[]
    cursor?: FollowRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowRequestScalarFieldEnum | FollowRequestScalarFieldEnum[]
  }

  /**
   * User.receivedFollowRequests
   */
  export type User$receivedFollowRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestInclude<ExtArgs> | null
    where?: FollowRequestWhereInput
    orderBy?: FollowRequestOrderByWithRelationInput | FollowRequestOrderByWithRelationInput[]
    cursor?: FollowRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowRequestScalarFieldEnum | FollowRequestScalarFieldEnum[]
  }

  /**
   * User.followedBy
   */
  export type User$followedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.likedGames
   */
  export type User$likedGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeInclude<ExtArgs> | null
    where?: GameLikeWhereInput
    orderBy?: GameLikeOrderByWithRelationInput | GameLikeOrderByWithRelationInput[]
    cursor?: GameLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameLikeScalarFieldEnum | GameLikeScalarFieldEnum[]
  }

  /**
   * User.gameRatings
   */
  export type User$gameRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingInclude<ExtArgs> | null
    where?: GameRatingWhereInput
    orderBy?: GameRatingOrderByWithRelationInput | GameRatingOrderByWithRelationInput[]
    cursor?: GameRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameRatingScalarFieldEnum | GameRatingScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.sentNotifications
   */
  export type User$sentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ChatRoom
   */

  export type AggregateChatRoom = {
    _count: ChatRoomCountAggregateOutputType | null
    _avg: ChatRoomAvgAggregateOutputType | null
    _sum: ChatRoomSumAggregateOutputType | null
    _min: ChatRoomMinAggregateOutputType | null
    _max: ChatRoomMaxAggregateOutputType | null
  }

  export type ChatRoomAvgAggregateOutputType = {
    maxParticipants: number | null
    currentParticipantCount: number | null
    speakerSeatCount: number | null
  }

  export type ChatRoomSumAggregateOutputType = {
    maxParticipants: number | null
    currentParticipantCount: number | null
    speakerSeatCount: number | null
  }

  export type ChatRoomMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    title: string | null
    description: string | null
    coverImageUrl: string | null
    type: $Enums.ChatRoomType | null
    passwordHash: string | null
    maxParticipants: number | null
    currentParticipantCount: number | null
    speakerSeatCount: number | null
    rtcChannelName: string | null
    status: $Enums.ChatRoomStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatRoomMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    title: string | null
    description: string | null
    coverImageUrl: string | null
    type: $Enums.ChatRoomType | null
    passwordHash: string | null
    maxParticipants: number | null
    currentParticipantCount: number | null
    speakerSeatCount: number | null
    rtcChannelName: string | null
    status: $Enums.ChatRoomStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatRoomCountAggregateOutputType = {
    id: number
    ownerId: number
    title: number
    description: number
    coverImageUrl: number
    type: number
    passwordHash: number
    maxParticipants: number
    currentParticipantCount: number
    activeParticipants: number
    moderators: number
    speakerSeatCount: number
    speakerSeatAssignments: number
    rtcChannelName: number
    tags: number
    status: number
    pinnedMessageIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatRoomAvgAggregateInputType = {
    maxParticipants?: true
    currentParticipantCount?: true
    speakerSeatCount?: true
  }

  export type ChatRoomSumAggregateInputType = {
    maxParticipants?: true
    currentParticipantCount?: true
    speakerSeatCount?: true
  }

  export type ChatRoomMinAggregateInputType = {
    id?: true
    ownerId?: true
    title?: true
    description?: true
    coverImageUrl?: true
    type?: true
    passwordHash?: true
    maxParticipants?: true
    currentParticipantCount?: true
    speakerSeatCount?: true
    rtcChannelName?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatRoomMaxAggregateInputType = {
    id?: true
    ownerId?: true
    title?: true
    description?: true
    coverImageUrl?: true
    type?: true
    passwordHash?: true
    maxParticipants?: true
    currentParticipantCount?: true
    speakerSeatCount?: true
    rtcChannelName?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatRoomCountAggregateInputType = {
    id?: true
    ownerId?: true
    title?: true
    description?: true
    coverImageUrl?: true
    type?: true
    passwordHash?: true
    maxParticipants?: true
    currentParticipantCount?: true
    activeParticipants?: true
    moderators?: true
    speakerSeatCount?: true
    speakerSeatAssignments?: true
    rtcChannelName?: true
    tags?: true
    status?: true
    pinnedMessageIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatRoom to aggregate.
     */
    where?: ChatRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatRooms to fetch.
     */
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatRooms
    **/
    _count?: true | ChatRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatRoomMaxAggregateInputType
  }

  export type GetChatRoomAggregateType<T extends ChatRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateChatRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatRoom[P]>
      : GetScalarType<T[P], AggregateChatRoom[P]>
  }




  export type ChatRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatRoomWhereInput
    orderBy?: ChatRoomOrderByWithAggregationInput | ChatRoomOrderByWithAggregationInput[]
    by: ChatRoomScalarFieldEnum[] | ChatRoomScalarFieldEnum
    having?: ChatRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatRoomCountAggregateInputType | true
    _avg?: ChatRoomAvgAggregateInputType
    _sum?: ChatRoomSumAggregateInputType
    _min?: ChatRoomMinAggregateInputType
    _max?: ChatRoomMaxAggregateInputType
  }

  export type ChatRoomGroupByOutputType = {
    id: string
    ownerId: string
    title: string
    description: string | null
    coverImageUrl: string | null
    type: $Enums.ChatRoomType
    passwordHash: string | null
    maxParticipants: number
    currentParticipantCount: number
    activeParticipants: JsonValue | null
    moderators: JsonValue | null
    speakerSeatCount: number
    speakerSeatAssignments: JsonValue | null
    rtcChannelName: string | null
    tags: JsonValue | null
    status: $Enums.ChatRoomStatus
    pinnedMessageIds: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ChatRoomCountAggregateOutputType | null
    _avg: ChatRoomAvgAggregateOutputType | null
    _sum: ChatRoomSumAggregateOutputType | null
    _min: ChatRoomMinAggregateOutputType | null
    _max: ChatRoomMaxAggregateOutputType | null
  }

  type GetChatRoomGroupByPayload<T extends ChatRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatRoomGroupByOutputType[P]>
            : GetScalarType<T[P], ChatRoomGroupByOutputType[P]>
        }
      >
    >


  export type ChatRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    coverImageUrl?: boolean
    type?: boolean
    passwordHash?: boolean
    maxParticipants?: boolean
    currentParticipantCount?: boolean
    activeParticipants?: boolean
    moderators?: boolean
    speakerSeatCount?: boolean
    speakerSeatAssignments?: boolean
    rtcChannelName?: boolean
    tags?: boolean
    status?: boolean
    pinnedMessageIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | ChatRoom$messagesArgs<ExtArgs>
    reports?: boolean | ChatRoom$reportsArgs<ExtArgs>
    _count?: boolean | ChatRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatRoom"]>

  export type ChatRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    coverImageUrl?: boolean
    type?: boolean
    passwordHash?: boolean
    maxParticipants?: boolean
    currentParticipantCount?: boolean
    activeParticipants?: boolean
    moderators?: boolean
    speakerSeatCount?: boolean
    speakerSeatAssignments?: boolean
    rtcChannelName?: boolean
    tags?: boolean
    status?: boolean
    pinnedMessageIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatRoom"]>

  export type ChatRoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    coverImageUrl?: boolean
    type?: boolean
    passwordHash?: boolean
    maxParticipants?: boolean
    currentParticipantCount?: boolean
    activeParticipants?: boolean
    moderators?: boolean
    speakerSeatCount?: boolean
    speakerSeatAssignments?: boolean
    rtcChannelName?: boolean
    tags?: boolean
    status?: boolean
    pinnedMessageIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatRoom"]>

  export type ChatRoomSelectScalar = {
    id?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    coverImageUrl?: boolean
    type?: boolean
    passwordHash?: boolean
    maxParticipants?: boolean
    currentParticipantCount?: boolean
    activeParticipants?: boolean
    moderators?: boolean
    speakerSeatCount?: boolean
    speakerSeatAssignments?: boolean
    rtcChannelName?: boolean
    tags?: boolean
    status?: boolean
    pinnedMessageIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatRoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "title" | "description" | "coverImageUrl" | "type" | "passwordHash" | "maxParticipants" | "currentParticipantCount" | "activeParticipants" | "moderators" | "speakerSeatCount" | "speakerSeatAssignments" | "rtcChannelName" | "tags" | "status" | "pinnedMessageIds" | "createdAt" | "updatedAt", ExtArgs["result"]["chatRoom"]>
  export type ChatRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | ChatRoom$messagesArgs<ExtArgs>
    reports?: boolean | ChatRoom$reportsArgs<ExtArgs>
    _count?: boolean | ChatRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatRoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatRoom"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      title: string
      description: string | null
      coverImageUrl: string | null
      type: $Enums.ChatRoomType
      passwordHash: string | null
      maxParticipants: number
      currentParticipantCount: number
      activeParticipants: Prisma.JsonValue | null
      moderators: Prisma.JsonValue | null
      speakerSeatCount: number
      speakerSeatAssignments: Prisma.JsonValue | null
      rtcChannelName: string | null
      tags: Prisma.JsonValue | null
      status: $Enums.ChatRoomStatus
      pinnedMessageIds: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chatRoom"]>
    composites: {}
  }

  type ChatRoomGetPayload<S extends boolean | null | undefined | ChatRoomDefaultArgs> = $Result.GetResult<Prisma.$ChatRoomPayload, S>

  type ChatRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatRoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatRoomCountAggregateInputType | true
    }

  export interface ChatRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatRoom'], meta: { name: 'ChatRoom' } }
    /**
     * Find zero or one ChatRoom that matches the filter.
     * @param {ChatRoomFindUniqueArgs} args - Arguments to find a ChatRoom
     * @example
     * // Get one ChatRoom
     * const chatRoom = await prisma.chatRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatRoomFindUniqueArgs>(args: SelectSubset<T, ChatRoomFindUniqueArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatRoom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatRoomFindUniqueOrThrowArgs} args - Arguments to find a ChatRoom
     * @example
     * // Get one ChatRoom
     * const chatRoom = await prisma.chatRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomFindFirstArgs} args - Arguments to find a ChatRoom
     * @example
     * // Get one ChatRoom
     * const chatRoom = await prisma.chatRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatRoomFindFirstArgs>(args?: SelectSubset<T, ChatRoomFindFirstArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomFindFirstOrThrowArgs} args - Arguments to find a ChatRoom
     * @example
     * // Get one ChatRoom
     * const chatRoom = await prisma.chatRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatRooms
     * const chatRooms = await prisma.chatRoom.findMany()
     * 
     * // Get first 10 ChatRooms
     * const chatRooms = await prisma.chatRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatRoomWithIdOnly = await prisma.chatRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatRoomFindManyArgs>(args?: SelectSubset<T, ChatRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatRoom.
     * @param {ChatRoomCreateArgs} args - Arguments to create a ChatRoom.
     * @example
     * // Create one ChatRoom
     * const ChatRoom = await prisma.chatRoom.create({
     *   data: {
     *     // ... data to create a ChatRoom
     *   }
     * })
     * 
     */
    create<T extends ChatRoomCreateArgs>(args: SelectSubset<T, ChatRoomCreateArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatRooms.
     * @param {ChatRoomCreateManyArgs} args - Arguments to create many ChatRooms.
     * @example
     * // Create many ChatRooms
     * const chatRoom = await prisma.chatRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatRoomCreateManyArgs>(args?: SelectSubset<T, ChatRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatRooms and returns the data saved in the database.
     * @param {ChatRoomCreateManyAndReturnArgs} args - Arguments to create many ChatRooms.
     * @example
     * // Create many ChatRooms
     * const chatRoom = await prisma.chatRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatRooms and only return the `id`
     * const chatRoomWithIdOnly = await prisma.chatRoom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatRoom.
     * @param {ChatRoomDeleteArgs} args - Arguments to delete one ChatRoom.
     * @example
     * // Delete one ChatRoom
     * const ChatRoom = await prisma.chatRoom.delete({
     *   where: {
     *     // ... filter to delete one ChatRoom
     *   }
     * })
     * 
     */
    delete<T extends ChatRoomDeleteArgs>(args: SelectSubset<T, ChatRoomDeleteArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatRoom.
     * @param {ChatRoomUpdateArgs} args - Arguments to update one ChatRoom.
     * @example
     * // Update one ChatRoom
     * const chatRoom = await prisma.chatRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatRoomUpdateArgs>(args: SelectSubset<T, ChatRoomUpdateArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatRooms.
     * @param {ChatRoomDeleteManyArgs} args - Arguments to filter ChatRooms to delete.
     * @example
     * // Delete a few ChatRooms
     * const { count } = await prisma.chatRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatRoomDeleteManyArgs>(args?: SelectSubset<T, ChatRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatRooms
     * const chatRoom = await prisma.chatRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatRoomUpdateManyArgs>(args: SelectSubset<T, ChatRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatRooms and returns the data updated in the database.
     * @param {ChatRoomUpdateManyAndReturnArgs} args - Arguments to update many ChatRooms.
     * @example
     * // Update many ChatRooms
     * const chatRoom = await prisma.chatRoom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatRooms and only return the `id`
     * const chatRoomWithIdOnly = await prisma.chatRoom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatRoomUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatRoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatRoom.
     * @param {ChatRoomUpsertArgs} args - Arguments to update or create a ChatRoom.
     * @example
     * // Update or create a ChatRoom
     * const chatRoom = await prisma.chatRoom.upsert({
     *   create: {
     *     // ... data to create a ChatRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatRoom we want to update
     *   }
     * })
     */
    upsert<T extends ChatRoomUpsertArgs>(args: SelectSubset<T, ChatRoomUpsertArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomCountArgs} args - Arguments to filter ChatRooms to count.
     * @example
     * // Count the number of ChatRooms
     * const count = await prisma.chatRoom.count({
     *   where: {
     *     // ... the filter for the ChatRooms we want to count
     *   }
     * })
    **/
    count<T extends ChatRoomCountArgs>(
      args?: Subset<T, ChatRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatRoomAggregateArgs>(args: Subset<T, ChatRoomAggregateArgs>): Prisma.PrismaPromise<GetChatRoomAggregateType<T>>

    /**
     * Group by ChatRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatRoomGroupByArgs['orderBy'] }
        : { orderBy?: ChatRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatRoom model
   */
  readonly fields: ChatRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends ChatRoom$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatRoom$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends ChatRoom$reportsArgs<ExtArgs> = {}>(args?: Subset<T, ChatRoom$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatRoom model
   */
  interface ChatRoomFieldRefs {
    readonly id: FieldRef<"ChatRoom", 'String'>
    readonly ownerId: FieldRef<"ChatRoom", 'String'>
    readonly title: FieldRef<"ChatRoom", 'String'>
    readonly description: FieldRef<"ChatRoom", 'String'>
    readonly coverImageUrl: FieldRef<"ChatRoom", 'String'>
    readonly type: FieldRef<"ChatRoom", 'ChatRoomType'>
    readonly passwordHash: FieldRef<"ChatRoom", 'String'>
    readonly maxParticipants: FieldRef<"ChatRoom", 'Int'>
    readonly currentParticipantCount: FieldRef<"ChatRoom", 'Int'>
    readonly activeParticipants: FieldRef<"ChatRoom", 'Json'>
    readonly moderators: FieldRef<"ChatRoom", 'Json'>
    readonly speakerSeatCount: FieldRef<"ChatRoom", 'Int'>
    readonly speakerSeatAssignments: FieldRef<"ChatRoom", 'Json'>
    readonly rtcChannelName: FieldRef<"ChatRoom", 'String'>
    readonly tags: FieldRef<"ChatRoom", 'Json'>
    readonly status: FieldRef<"ChatRoom", 'ChatRoomStatus'>
    readonly pinnedMessageIds: FieldRef<"ChatRoom", 'Json'>
    readonly createdAt: FieldRef<"ChatRoom", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatRoom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatRoom findUnique
   */
  export type ChatRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRoom to fetch.
     */
    where: ChatRoomWhereUniqueInput
  }

  /**
   * ChatRoom findUniqueOrThrow
   */
  export type ChatRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRoom to fetch.
     */
    where: ChatRoomWhereUniqueInput
  }

  /**
   * ChatRoom findFirst
   */
  export type ChatRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRoom to fetch.
     */
    where?: ChatRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatRooms to fetch.
     */
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatRooms.
     */
    cursor?: ChatRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatRooms.
     */
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * ChatRoom findFirstOrThrow
   */
  export type ChatRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRoom to fetch.
     */
    where?: ChatRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatRooms to fetch.
     */
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatRooms.
     */
    cursor?: ChatRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatRooms.
     */
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * ChatRoom findMany
   */
  export type ChatRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRooms to fetch.
     */
    where?: ChatRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatRooms to fetch.
     */
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatRooms.
     */
    cursor?: ChatRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatRooms.
     */
    skip?: number
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * ChatRoom create
   */
  export type ChatRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatRoom.
     */
    data: XOR<ChatRoomCreateInput, ChatRoomUncheckedCreateInput>
  }

  /**
   * ChatRoom createMany
   */
  export type ChatRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatRooms.
     */
    data: ChatRoomCreateManyInput | ChatRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatRoom createManyAndReturn
   */
  export type ChatRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * The data used to create many ChatRooms.
     */
    data: ChatRoomCreateManyInput | ChatRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatRoom update
   */
  export type ChatRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatRoom.
     */
    data: XOR<ChatRoomUpdateInput, ChatRoomUncheckedUpdateInput>
    /**
     * Choose, which ChatRoom to update.
     */
    where: ChatRoomWhereUniqueInput
  }

  /**
   * ChatRoom updateMany
   */
  export type ChatRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatRooms.
     */
    data: XOR<ChatRoomUpdateManyMutationInput, ChatRoomUncheckedUpdateManyInput>
    /**
     * Filter which ChatRooms to update
     */
    where?: ChatRoomWhereInput
    /**
     * Limit how many ChatRooms to update.
     */
    limit?: number
  }

  /**
   * ChatRoom updateManyAndReturn
   */
  export type ChatRoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * The data used to update ChatRooms.
     */
    data: XOR<ChatRoomUpdateManyMutationInput, ChatRoomUncheckedUpdateManyInput>
    /**
     * Filter which ChatRooms to update
     */
    where?: ChatRoomWhereInput
    /**
     * Limit how many ChatRooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatRoom upsert
   */
  export type ChatRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatRoom to update in case it exists.
     */
    where: ChatRoomWhereUniqueInput
    /**
     * In case the ChatRoom found by the `where` argument doesn't exist, create a new ChatRoom with this data.
     */
    create: XOR<ChatRoomCreateInput, ChatRoomUncheckedCreateInput>
    /**
     * In case the ChatRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatRoomUpdateInput, ChatRoomUncheckedUpdateInput>
  }

  /**
   * ChatRoom delete
   */
  export type ChatRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter which ChatRoom to delete.
     */
    where: ChatRoomWhereUniqueInput
  }

  /**
   * ChatRoom deleteMany
   */
  export type ChatRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatRooms to delete
     */
    where?: ChatRoomWhereInput
    /**
     * Limit how many ChatRooms to delete.
     */
    limit?: number
  }

  /**
   * ChatRoom.messages
   */
  export type ChatRoom$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * ChatRoom.reports
   */
  export type ChatRoom$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * ChatRoom without action
   */
  export type ChatRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    receiverId: string | null
    roomId: string | null
    messageType: $Enums.MessageType | null
    content: string | null
    giftId: string | null
    isPinned: boolean | null
    createdAt: Date | null
    repliedToMessageId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    receiverId: string | null
    roomId: string | null
    messageType: $Enums.MessageType | null
    content: string | null
    giftId: string | null
    isPinned: boolean | null
    createdAt: Date | null
    repliedToMessageId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    receiverId: number
    roomId: number
    messageType: number
    content: number
    giftId: number
    readStatus: number
    isDeletedFor: number
    isPinned: number
    reactions: number
    createdAt: number
    repliedToMessageId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    receiverId?: true
    roomId?: true
    messageType?: true
    content?: true
    giftId?: true
    isPinned?: true
    createdAt?: true
    repliedToMessageId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    receiverId?: true
    roomId?: true
    messageType?: true
    content?: true
    giftId?: true
    isPinned?: true
    createdAt?: true
    repliedToMessageId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    receiverId?: true
    roomId?: true
    messageType?: true
    content?: true
    giftId?: true
    readStatus?: true
    isDeletedFor?: true
    isPinned?: true
    reactions?: true
    createdAt?: true
    repliedToMessageId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    receiverId: string | null
    roomId: string | null
    messageType: $Enums.MessageType
    content: string | null
    giftId: string | null
    readStatus: JsonValue | null
    isDeletedFor: JsonValue | null
    isPinned: boolean
    reactions: JsonValue | null
    createdAt: Date
    repliedToMessageId: string | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    receiverId?: boolean
    roomId?: boolean
    messageType?: boolean
    content?: boolean
    giftId?: boolean
    readStatus?: boolean
    isDeletedFor?: boolean
    isPinned?: boolean
    reactions?: boolean
    createdAt?: boolean
    repliedToMessageId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | Message$receiverArgs<ExtArgs>
    room?: boolean | Message$roomArgs<ExtArgs>
    gift?: boolean | Message$giftArgs<ExtArgs>
    repliedToMessage?: boolean | Message$repliedToMessageArgs<ExtArgs>
    replies?: boolean | Message$repliesArgs<ExtArgs>
    reports?: boolean | Message$reportsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    receiverId?: boolean
    roomId?: boolean
    messageType?: boolean
    content?: boolean
    giftId?: boolean
    readStatus?: boolean
    isDeletedFor?: boolean
    isPinned?: boolean
    reactions?: boolean
    createdAt?: boolean
    repliedToMessageId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | Message$receiverArgs<ExtArgs>
    room?: boolean | Message$roomArgs<ExtArgs>
    gift?: boolean | Message$giftArgs<ExtArgs>
    repliedToMessage?: boolean | Message$repliedToMessageArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    receiverId?: boolean
    roomId?: boolean
    messageType?: boolean
    content?: boolean
    giftId?: boolean
    readStatus?: boolean
    isDeletedFor?: boolean
    isPinned?: boolean
    reactions?: boolean
    createdAt?: boolean
    repliedToMessageId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | Message$receiverArgs<ExtArgs>
    room?: boolean | Message$roomArgs<ExtArgs>
    gift?: boolean | Message$giftArgs<ExtArgs>
    repliedToMessage?: boolean | Message$repliedToMessageArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    receiverId?: boolean
    roomId?: boolean
    messageType?: boolean
    content?: boolean
    giftId?: boolean
    readStatus?: boolean
    isDeletedFor?: boolean
    isPinned?: boolean
    reactions?: boolean
    createdAt?: boolean
    repliedToMessageId?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "senderId" | "receiverId" | "roomId" | "messageType" | "content" | "giftId" | "readStatus" | "isDeletedFor" | "isPinned" | "reactions" | "createdAt" | "repliedToMessageId", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | Message$receiverArgs<ExtArgs>
    room?: boolean | Message$roomArgs<ExtArgs>
    gift?: boolean | Message$giftArgs<ExtArgs>
    repliedToMessage?: boolean | Message$repliedToMessageArgs<ExtArgs>
    replies?: boolean | Message$repliesArgs<ExtArgs>
    reports?: boolean | Message$reportsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | Message$receiverArgs<ExtArgs>
    room?: boolean | Message$roomArgs<ExtArgs>
    gift?: boolean | Message$giftArgs<ExtArgs>
    repliedToMessage?: boolean | Message$repliedToMessageArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | Message$receiverArgs<ExtArgs>
    room?: boolean | Message$roomArgs<ExtArgs>
    gift?: boolean | Message$giftArgs<ExtArgs>
    repliedToMessage?: boolean | Message$repliedToMessageArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs> | null
      room: Prisma.$ChatRoomPayload<ExtArgs> | null
      gift: Prisma.$GiftPayload<ExtArgs> | null
      repliedToMessage: Prisma.$MessagePayload<ExtArgs> | null
      replies: Prisma.$MessagePayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      receiverId: string | null
      roomId: string | null
      messageType: $Enums.MessageType
      content: string | null
      giftId: string | null
      readStatus: Prisma.JsonValue | null
      isDeletedFor: Prisma.JsonValue | null
      isPinned: boolean
      reactions: Prisma.JsonValue | null
      createdAt: Date
      repliedToMessageId: string | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends Message$receiverArgs<ExtArgs> = {}>(args?: Subset<T, Message$receiverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    room<T extends Message$roomArgs<ExtArgs> = {}>(args?: Subset<T, Message$roomArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gift<T extends Message$giftArgs<ExtArgs> = {}>(args?: Subset<T, Message$giftArgs<ExtArgs>>): Prisma__GiftClient<$Result.GetResult<Prisma.$GiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    repliedToMessage<T extends Message$repliedToMessageArgs<ExtArgs> = {}>(args?: Subset<T, Message$repliedToMessageArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Message$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Message$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends Message$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Message$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly receiverId: FieldRef<"Message", 'String'>
    readonly roomId: FieldRef<"Message", 'String'>
    readonly messageType: FieldRef<"Message", 'MessageType'>
    readonly content: FieldRef<"Message", 'String'>
    readonly giftId: FieldRef<"Message", 'String'>
    readonly readStatus: FieldRef<"Message", 'Json'>
    readonly isDeletedFor: FieldRef<"Message", 'Json'>
    readonly isPinned: FieldRef<"Message", 'Boolean'>
    readonly reactions: FieldRef<"Message", 'Json'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly repliedToMessageId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.receiver
   */
  export type Message$receiverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message.room
   */
  export type Message$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    where?: ChatRoomWhereInput
  }

  /**
   * Message.gift
   */
  export type Message$giftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftInclude<ExtArgs> | null
    where?: GiftWhereInput
  }

  /**
   * Message.repliedToMessage
   */
  export type Message$repliedToMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Message.replies
   */
  export type Message$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message.reports
   */
  export type Message$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    transactionType: $Enums.TransactionType | null
    amount: Decimal | null
    currency: string | null
    relatedEntityId: string | null
    relatedEntityType: string | null
    description: string | null
    platform: string | null
    platformTransactionId: string | null
    status: $Enums.TransactionStatus | null
    paymentGatewayToken: string | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    transactionType: $Enums.TransactionType | null
    amount: Decimal | null
    currency: string | null
    relatedEntityId: string | null
    relatedEntityType: string | null
    description: string | null
    platform: string | null
    platformTransactionId: string | null
    status: $Enums.TransactionStatus | null
    paymentGatewayToken: string | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    transactionType: number
    amount: number
    currency: number
    relatedEntityId: number
    relatedEntityType: number
    description: number
    platform: number
    platformTransactionId: number
    status: number
    paymentGatewayToken: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    transactionType?: true
    amount?: true
    currency?: true
    relatedEntityId?: true
    relatedEntityType?: true
    description?: true
    platform?: true
    platformTransactionId?: true
    status?: true
    paymentGatewayToken?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    transactionType?: true
    amount?: true
    currency?: true
    relatedEntityId?: true
    relatedEntityType?: true
    description?: true
    platform?: true
    platformTransactionId?: true
    status?: true
    paymentGatewayToken?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    transactionType?: true
    amount?: true
    currency?: true
    relatedEntityId?: true
    relatedEntityType?: true
    description?: true
    platform?: true
    platformTransactionId?: true
    status?: true
    paymentGatewayToken?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    transactionType: $Enums.TransactionType
    amount: Decimal
    currency: string
    relatedEntityId: string | null
    relatedEntityType: string | null
    description: string | null
    platform: string | null
    platformTransactionId: string | null
    status: $Enums.TransactionStatus
    paymentGatewayToken: string | null
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionType?: boolean
    amount?: boolean
    currency?: boolean
    relatedEntityId?: boolean
    relatedEntityType?: boolean
    description?: boolean
    platform?: boolean
    platformTransactionId?: boolean
    status?: boolean
    paymentGatewayToken?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionType?: boolean
    amount?: boolean
    currency?: boolean
    relatedEntityId?: boolean
    relatedEntityType?: boolean
    description?: boolean
    platform?: boolean
    platformTransactionId?: boolean
    status?: boolean
    paymentGatewayToken?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionType?: boolean
    amount?: boolean
    currency?: boolean
    relatedEntityId?: boolean
    relatedEntityType?: boolean
    description?: boolean
    platform?: boolean
    platformTransactionId?: boolean
    status?: boolean
    paymentGatewayToken?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    transactionType?: boolean
    amount?: boolean
    currency?: boolean
    relatedEntityId?: boolean
    relatedEntityType?: boolean
    description?: boolean
    platform?: boolean
    platformTransactionId?: boolean
    status?: boolean
    paymentGatewayToken?: boolean
    createdAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "transactionType" | "amount" | "currency" | "relatedEntityId" | "relatedEntityType" | "description" | "platform" | "platformTransactionId" | "status" | "paymentGatewayToken" | "createdAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      transactionType: $Enums.TransactionType
      amount: Prisma.Decimal
      currency: string
      relatedEntityId: string | null
      relatedEntityType: string | null
      description: string | null
      platform: string | null
      platformTransactionId: string | null
      status: $Enums.TransactionStatus
      paymentGatewayToken: string | null
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly transactionType: FieldRef<"Transaction", 'TransactionType'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly relatedEntityId: FieldRef<"Transaction", 'String'>
    readonly relatedEntityType: FieldRef<"Transaction", 'String'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly platform: FieldRef<"Transaction", 'String'>
    readonly platformTransactionId: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly paymentGatewayToken: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowMaxAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowCountAggregateOutputType = {
    id: number
    followerId: number
    followingId: number
    createdAt: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowMaxAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowCountAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    id: string
    followerId: string
    followingId: string
    createdAt: Date
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectScalar = {
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
  }

  export type FollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followerId" | "followingId" | "createdAt", ExtArgs["result"]["follow"]>
  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerId: string
      followingId: string
      createdAt: Date
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followWithIdOnly = await prisma.follow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {FollowCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows and returns the data updated in the database.
     * @param {FollowUpdateManyAndReturnArgs} args - Arguments to update many Follows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */
  interface FollowFieldRefs {
    readonly id: FieldRef<"Follow", 'String'>
    readonly followerId: FieldRef<"Follow", 'String'>
    readonly followingId: FieldRef<"Follow", 'String'>
    readonly createdAt: FieldRef<"Follow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Follow createManyAndReturn
   */
  export type FollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
  }

  /**
   * Follow updateManyAndReturn
   */
  export type FollowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to delete.
     */
    limit?: number
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model FollowRequest
   */

  export type AggregateFollowRequest = {
    _count: FollowRequestCountAggregateOutputType | null
    _min: FollowRequestMinAggregateOutputType | null
    _max: FollowRequestMaxAggregateOutputType | null
  }

  export type FollowRequestMinAggregateOutputType = {
    id: string | null
    requesterId: string | null
    recipientId: string | null
    status: $Enums.FollowRequestStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FollowRequestMaxAggregateOutputType = {
    id: string | null
    requesterId: string | null
    recipientId: string | null
    status: $Enums.FollowRequestStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FollowRequestCountAggregateOutputType = {
    id: number
    requesterId: number
    recipientId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FollowRequestMinAggregateInputType = {
    id?: true
    requesterId?: true
    recipientId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FollowRequestMaxAggregateInputType = {
    id?: true
    requesterId?: true
    recipientId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FollowRequestCountAggregateInputType = {
    id?: true
    requesterId?: true
    recipientId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FollowRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowRequest to aggregate.
     */
    where?: FollowRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowRequests to fetch.
     */
    orderBy?: FollowRequestOrderByWithRelationInput | FollowRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FollowRequests
    **/
    _count?: true | FollowRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowRequestMaxAggregateInputType
  }

  export type GetFollowRequestAggregateType<T extends FollowRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateFollowRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowRequest[P]>
      : GetScalarType<T[P], AggregateFollowRequest[P]>
  }




  export type FollowRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowRequestWhereInput
    orderBy?: FollowRequestOrderByWithAggregationInput | FollowRequestOrderByWithAggregationInput[]
    by: FollowRequestScalarFieldEnum[] | FollowRequestScalarFieldEnum
    having?: FollowRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowRequestCountAggregateInputType | true
    _min?: FollowRequestMinAggregateInputType
    _max?: FollowRequestMaxAggregateInputType
  }

  export type FollowRequestGroupByOutputType = {
    id: string
    requesterId: string
    recipientId: string
    status: $Enums.FollowRequestStatus
    createdAt: Date
    updatedAt: Date
    _count: FollowRequestCountAggregateOutputType | null
    _min: FollowRequestMinAggregateOutputType | null
    _max: FollowRequestMaxAggregateOutputType | null
  }

  type GetFollowRequestGroupByPayload<T extends FollowRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowRequestGroupByOutputType[P]>
            : GetScalarType<T[P], FollowRequestGroupByOutputType[P]>
        }
      >
    >


  export type FollowRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    recipientId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requester?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followRequest"]>

  export type FollowRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    recipientId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requester?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followRequest"]>

  export type FollowRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    recipientId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requester?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followRequest"]>

  export type FollowRequestSelectScalar = {
    id?: boolean
    requesterId?: boolean
    recipientId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FollowRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requesterId" | "recipientId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["followRequest"]>
  export type FollowRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FollowRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FollowRequest"
    objects: {
      requester: Prisma.$UserPayload<ExtArgs>
      recipient: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requesterId: string
      recipientId: string
      status: $Enums.FollowRequestStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["followRequest"]>
    composites: {}
  }

  type FollowRequestGetPayload<S extends boolean | null | undefined | FollowRequestDefaultArgs> = $Result.GetResult<Prisma.$FollowRequestPayload, S>

  type FollowRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowRequestCountAggregateInputType | true
    }

  export interface FollowRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FollowRequest'], meta: { name: 'FollowRequest' } }
    /**
     * Find zero or one FollowRequest that matches the filter.
     * @param {FollowRequestFindUniqueArgs} args - Arguments to find a FollowRequest
     * @example
     * // Get one FollowRequest
     * const followRequest = await prisma.followRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowRequestFindUniqueArgs>(args: SelectSubset<T, FollowRequestFindUniqueArgs<ExtArgs>>): Prisma__FollowRequestClient<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FollowRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowRequestFindUniqueOrThrowArgs} args - Arguments to find a FollowRequest
     * @example
     * // Get one FollowRequest
     * const followRequest = await prisma.followRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowRequestClient<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestFindFirstArgs} args - Arguments to find a FollowRequest
     * @example
     * // Get one FollowRequest
     * const followRequest = await prisma.followRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowRequestFindFirstArgs>(args?: SelectSubset<T, FollowRequestFindFirstArgs<ExtArgs>>): Prisma__FollowRequestClient<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestFindFirstOrThrowArgs} args - Arguments to find a FollowRequest
     * @example
     * // Get one FollowRequest
     * const followRequest = await prisma.followRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowRequestClient<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FollowRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FollowRequests
     * const followRequests = await prisma.followRequest.findMany()
     * 
     * // Get first 10 FollowRequests
     * const followRequests = await prisma.followRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followRequestWithIdOnly = await prisma.followRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowRequestFindManyArgs>(args?: SelectSubset<T, FollowRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FollowRequest.
     * @param {FollowRequestCreateArgs} args - Arguments to create a FollowRequest.
     * @example
     * // Create one FollowRequest
     * const FollowRequest = await prisma.followRequest.create({
     *   data: {
     *     // ... data to create a FollowRequest
     *   }
     * })
     * 
     */
    create<T extends FollowRequestCreateArgs>(args: SelectSubset<T, FollowRequestCreateArgs<ExtArgs>>): Prisma__FollowRequestClient<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FollowRequests.
     * @param {FollowRequestCreateManyArgs} args - Arguments to create many FollowRequests.
     * @example
     * // Create many FollowRequests
     * const followRequest = await prisma.followRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowRequestCreateManyArgs>(args?: SelectSubset<T, FollowRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FollowRequests and returns the data saved in the database.
     * @param {FollowRequestCreateManyAndReturnArgs} args - Arguments to create many FollowRequests.
     * @example
     * // Create many FollowRequests
     * const followRequest = await prisma.followRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FollowRequests and only return the `id`
     * const followRequestWithIdOnly = await prisma.followRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FollowRequest.
     * @param {FollowRequestDeleteArgs} args - Arguments to delete one FollowRequest.
     * @example
     * // Delete one FollowRequest
     * const FollowRequest = await prisma.followRequest.delete({
     *   where: {
     *     // ... filter to delete one FollowRequest
     *   }
     * })
     * 
     */
    delete<T extends FollowRequestDeleteArgs>(args: SelectSubset<T, FollowRequestDeleteArgs<ExtArgs>>): Prisma__FollowRequestClient<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FollowRequest.
     * @param {FollowRequestUpdateArgs} args - Arguments to update one FollowRequest.
     * @example
     * // Update one FollowRequest
     * const followRequest = await prisma.followRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowRequestUpdateArgs>(args: SelectSubset<T, FollowRequestUpdateArgs<ExtArgs>>): Prisma__FollowRequestClient<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FollowRequests.
     * @param {FollowRequestDeleteManyArgs} args - Arguments to filter FollowRequests to delete.
     * @example
     * // Delete a few FollowRequests
     * const { count } = await prisma.followRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowRequestDeleteManyArgs>(args?: SelectSubset<T, FollowRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FollowRequests
     * const followRequest = await prisma.followRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowRequestUpdateManyArgs>(args: SelectSubset<T, FollowRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowRequests and returns the data updated in the database.
     * @param {FollowRequestUpdateManyAndReturnArgs} args - Arguments to update many FollowRequests.
     * @example
     * // Update many FollowRequests
     * const followRequest = await prisma.followRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FollowRequests and only return the `id`
     * const followRequestWithIdOnly = await prisma.followRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FollowRequest.
     * @param {FollowRequestUpsertArgs} args - Arguments to update or create a FollowRequest.
     * @example
     * // Update or create a FollowRequest
     * const followRequest = await prisma.followRequest.upsert({
     *   create: {
     *     // ... data to create a FollowRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FollowRequest we want to update
     *   }
     * })
     */
    upsert<T extends FollowRequestUpsertArgs>(args: SelectSubset<T, FollowRequestUpsertArgs<ExtArgs>>): Prisma__FollowRequestClient<$Result.GetResult<Prisma.$FollowRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FollowRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestCountArgs} args - Arguments to filter FollowRequests to count.
     * @example
     * // Count the number of FollowRequests
     * const count = await prisma.followRequest.count({
     *   where: {
     *     // ... the filter for the FollowRequests we want to count
     *   }
     * })
    **/
    count<T extends FollowRequestCountArgs>(
      args?: Subset<T, FollowRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FollowRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowRequestAggregateArgs>(args: Subset<T, FollowRequestAggregateArgs>): Prisma.PrismaPromise<GetFollowRequestAggregateType<T>>

    /**
     * Group by FollowRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowRequestGroupByArgs['orderBy'] }
        : { orderBy?: FollowRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FollowRequest model
   */
  readonly fields: FollowRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FollowRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requester<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FollowRequest model
   */
  interface FollowRequestFieldRefs {
    readonly id: FieldRef<"FollowRequest", 'String'>
    readonly requesterId: FieldRef<"FollowRequest", 'String'>
    readonly recipientId: FieldRef<"FollowRequest", 'String'>
    readonly status: FieldRef<"FollowRequest", 'FollowRequestStatus'>
    readonly createdAt: FieldRef<"FollowRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"FollowRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FollowRequest findUnique
   */
  export type FollowRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestInclude<ExtArgs> | null
    /**
     * Filter, which FollowRequest to fetch.
     */
    where: FollowRequestWhereUniqueInput
  }

  /**
   * FollowRequest findUniqueOrThrow
   */
  export type FollowRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestInclude<ExtArgs> | null
    /**
     * Filter, which FollowRequest to fetch.
     */
    where: FollowRequestWhereUniqueInput
  }

  /**
   * FollowRequest findFirst
   */
  export type FollowRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestInclude<ExtArgs> | null
    /**
     * Filter, which FollowRequest to fetch.
     */
    where?: FollowRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowRequests to fetch.
     */
    orderBy?: FollowRequestOrderByWithRelationInput | FollowRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowRequests.
     */
    cursor?: FollowRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowRequests.
     */
    distinct?: FollowRequestScalarFieldEnum | FollowRequestScalarFieldEnum[]
  }

  /**
   * FollowRequest findFirstOrThrow
   */
  export type FollowRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestInclude<ExtArgs> | null
    /**
     * Filter, which FollowRequest to fetch.
     */
    where?: FollowRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowRequests to fetch.
     */
    orderBy?: FollowRequestOrderByWithRelationInput | FollowRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowRequests.
     */
    cursor?: FollowRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowRequests.
     */
    distinct?: FollowRequestScalarFieldEnum | FollowRequestScalarFieldEnum[]
  }

  /**
   * FollowRequest findMany
   */
  export type FollowRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestInclude<ExtArgs> | null
    /**
     * Filter, which FollowRequests to fetch.
     */
    where?: FollowRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowRequests to fetch.
     */
    orderBy?: FollowRequestOrderByWithRelationInput | FollowRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FollowRequests.
     */
    cursor?: FollowRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowRequests.
     */
    skip?: number
    distinct?: FollowRequestScalarFieldEnum | FollowRequestScalarFieldEnum[]
  }

  /**
   * FollowRequest create
   */
  export type FollowRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a FollowRequest.
     */
    data: XOR<FollowRequestCreateInput, FollowRequestUncheckedCreateInput>
  }

  /**
   * FollowRequest createMany
   */
  export type FollowRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FollowRequests.
     */
    data: FollowRequestCreateManyInput | FollowRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FollowRequest createManyAndReturn
   */
  export type FollowRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * The data used to create many FollowRequests.
     */
    data: FollowRequestCreateManyInput | FollowRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FollowRequest update
   */
  export type FollowRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a FollowRequest.
     */
    data: XOR<FollowRequestUpdateInput, FollowRequestUncheckedUpdateInput>
    /**
     * Choose, which FollowRequest to update.
     */
    where: FollowRequestWhereUniqueInput
  }

  /**
   * FollowRequest updateMany
   */
  export type FollowRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FollowRequests.
     */
    data: XOR<FollowRequestUpdateManyMutationInput, FollowRequestUncheckedUpdateManyInput>
    /**
     * Filter which FollowRequests to update
     */
    where?: FollowRequestWhereInput
    /**
     * Limit how many FollowRequests to update.
     */
    limit?: number
  }

  /**
   * FollowRequest updateManyAndReturn
   */
  export type FollowRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * The data used to update FollowRequests.
     */
    data: XOR<FollowRequestUpdateManyMutationInput, FollowRequestUncheckedUpdateManyInput>
    /**
     * Filter which FollowRequests to update
     */
    where?: FollowRequestWhereInput
    /**
     * Limit how many FollowRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FollowRequest upsert
   */
  export type FollowRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the FollowRequest to update in case it exists.
     */
    where: FollowRequestWhereUniqueInput
    /**
     * In case the FollowRequest found by the `where` argument doesn't exist, create a new FollowRequest with this data.
     */
    create: XOR<FollowRequestCreateInput, FollowRequestUncheckedCreateInput>
    /**
     * In case the FollowRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowRequestUpdateInput, FollowRequestUncheckedUpdateInput>
  }

  /**
   * FollowRequest delete
   */
  export type FollowRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestInclude<ExtArgs> | null
    /**
     * Filter which FollowRequest to delete.
     */
    where: FollowRequestWhereUniqueInput
  }

  /**
   * FollowRequest deleteMany
   */
  export type FollowRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowRequests to delete
     */
    where?: FollowRequestWhereInput
    /**
     * Limit how many FollowRequests to delete.
     */
    limit?: number
  }

  /**
   * FollowRequest without action
   */
  export type FollowRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowRequest
     */
    select?: FollowRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowRequest
     */
    omit?: FollowRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowRequestInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    entryCost: number | null
    likeCount: number | null
    playCount: number | null
    averageRating: number | null
    ratingCount: number | null
  }

  export type GameSumAggregateOutputType = {
    entryCost: bigint | null
    likeCount: number | null
    playCount: number | null
    averageRating: number | null
    ratingCount: number | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    name: string | null
    description: string | null
    iconUrl: string | null
    entryCost: bigint | null
    isActive: boolean | null
    developer: string | null
    publisher: string | null
    releaseDate: Date | null
    likeCount: number | null
    playCount: number | null
    averageRating: number | null
    ratingCount: number | null
    createdAt: Date | null
    categoryId: string | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    name: string | null
    description: string | null
    iconUrl: string | null
    entryCost: bigint | null
    isActive: boolean | null
    developer: string | null
    publisher: string | null
    releaseDate: Date | null
    likeCount: number | null
    playCount: number | null
    averageRating: number | null
    ratingCount: number | null
    createdAt: Date | null
    categoryId: string | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    gameId: number
    name: number
    description: number
    iconUrl: number
    entryCost: number
    rewardStructure: number
    isActive: number
    developer: number
    publisher: number
    releaseDate: number
    platformCompat: number
    likeCount: number
    playCount: number
    averageRating: number
    ratingCount: number
    createdAt: number
    categoryId: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    entryCost?: true
    likeCount?: true
    playCount?: true
    averageRating?: true
    ratingCount?: true
  }

  export type GameSumAggregateInputType = {
    entryCost?: true
    likeCount?: true
    playCount?: true
    averageRating?: true
    ratingCount?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    gameId?: true
    name?: true
    description?: true
    iconUrl?: true
    entryCost?: true
    isActive?: true
    developer?: true
    publisher?: true
    releaseDate?: true
    likeCount?: true
    playCount?: true
    averageRating?: true
    ratingCount?: true
    createdAt?: true
    categoryId?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    gameId?: true
    name?: true
    description?: true
    iconUrl?: true
    entryCost?: true
    isActive?: true
    developer?: true
    publisher?: true
    releaseDate?: true
    likeCount?: true
    playCount?: true
    averageRating?: true
    ratingCount?: true
    createdAt?: true
    categoryId?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    gameId?: true
    name?: true
    description?: true
    iconUrl?: true
    entryCost?: true
    rewardStructure?: true
    isActive?: true
    developer?: true
    publisher?: true
    releaseDate?: true
    platformCompat?: true
    likeCount?: true
    playCount?: true
    averageRating?: true
    ratingCount?: true
    createdAt?: true
    categoryId?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    gameId: string
    name: string
    description: string | null
    iconUrl: string | null
    entryCost: bigint
    rewardStructure: JsonValue | null
    isActive: boolean
    developer: string | null
    publisher: string | null
    releaseDate: Date | null
    platformCompat: JsonValue | null
    likeCount: number
    playCount: number
    averageRating: number
    ratingCount: number
    createdAt: Date
    categoryId: string | null
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    entryCost?: boolean
    rewardStructure?: boolean
    isActive?: boolean
    developer?: boolean
    publisher?: boolean
    releaseDate?: boolean
    platformCompat?: boolean
    likeCount?: boolean
    playCount?: boolean
    averageRating?: boolean
    ratingCount?: boolean
    createdAt?: boolean
    categoryId?: boolean
    category?: boolean | Game$categoryArgs<ExtArgs>
    gameGenreTags?: boolean | Game$gameGenreTagsArgs<ExtArgs>
    gameSessions?: boolean | Game$gameSessionsArgs<ExtArgs>
    likes?: boolean | Game$likesArgs<ExtArgs>
    ratings?: boolean | Game$ratingsArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    entryCost?: boolean
    rewardStructure?: boolean
    isActive?: boolean
    developer?: boolean
    publisher?: boolean
    releaseDate?: boolean
    platformCompat?: boolean
    likeCount?: boolean
    playCount?: boolean
    averageRating?: boolean
    ratingCount?: boolean
    createdAt?: boolean
    categoryId?: boolean
    category?: boolean | Game$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    entryCost?: boolean
    rewardStructure?: boolean
    isActive?: boolean
    developer?: boolean
    publisher?: boolean
    releaseDate?: boolean
    platformCompat?: boolean
    likeCount?: boolean
    playCount?: boolean
    averageRating?: boolean
    ratingCount?: boolean
    createdAt?: boolean
    categoryId?: boolean
    category?: boolean | Game$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    gameId?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    entryCost?: boolean
    rewardStructure?: boolean
    isActive?: boolean
    developer?: boolean
    publisher?: boolean
    releaseDate?: boolean
    platformCompat?: boolean
    likeCount?: boolean
    playCount?: boolean
    averageRating?: boolean
    ratingCount?: boolean
    createdAt?: boolean
    categoryId?: boolean
  }

  export type GameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "name" | "description" | "iconUrl" | "entryCost" | "rewardStructure" | "isActive" | "developer" | "publisher" | "releaseDate" | "platformCompat" | "likeCount" | "playCount" | "averageRating" | "ratingCount" | "createdAt" | "categoryId", ExtArgs["result"]["game"]>
  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Game$categoryArgs<ExtArgs>
    gameGenreTags?: boolean | Game$gameGenreTagsArgs<ExtArgs>
    gameSessions?: boolean | Game$gameSessionsArgs<ExtArgs>
    likes?: boolean | Game$likesArgs<ExtArgs>
    ratings?: boolean | Game$ratingsArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Game$categoryArgs<ExtArgs>
  }
  export type GameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Game$categoryArgs<ExtArgs>
  }

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      category: Prisma.$GameCategoryPayload<ExtArgs> | null
      gameGenreTags: Prisma.$GameGenreTagPayload<ExtArgs>[]
      gameSessions: Prisma.$GameSessionPayload<ExtArgs>[]
      likes: Prisma.$GameLikePayload<ExtArgs>[]
      ratings: Prisma.$GameRatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      name: string
      description: string | null
      iconUrl: string | null
      entryCost: bigint
      rewardStructure: Prisma.JsonValue | null
      isActive: boolean
      developer: string | null
      publisher: string | null
      releaseDate: Date | null
      platformCompat: Prisma.JsonValue | null
      likeCount: number
      playCount: number
      averageRating: number
      ratingCount: number
      createdAt: Date
      categoryId: string | null
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games and returns the data updated in the database.
     * @param {GameUpdateManyAndReturnArgs} args - Arguments to update many Games.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameUpdateManyAndReturnArgs>(args: SelectSubset<T, GameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Game$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Game$categoryArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gameGenreTags<T extends Game$gameGenreTagsArgs<ExtArgs> = {}>(args?: Subset<T, Game$gameGenreTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gameSessions<T extends Game$gameSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Game$gameSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends Game$likesArgs<ExtArgs> = {}>(args?: Subset<T, Game$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Game$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Game$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly gameId: FieldRef<"Game", 'String'>
    readonly name: FieldRef<"Game", 'String'>
    readonly description: FieldRef<"Game", 'String'>
    readonly iconUrl: FieldRef<"Game", 'String'>
    readonly entryCost: FieldRef<"Game", 'BigInt'>
    readonly rewardStructure: FieldRef<"Game", 'Json'>
    readonly isActive: FieldRef<"Game", 'Boolean'>
    readonly developer: FieldRef<"Game", 'String'>
    readonly publisher: FieldRef<"Game", 'String'>
    readonly releaseDate: FieldRef<"Game", 'DateTime'>
    readonly platformCompat: FieldRef<"Game", 'Json'>
    readonly likeCount: FieldRef<"Game", 'Int'>
    readonly playCount: FieldRef<"Game", 'Int'>
    readonly averageRating: FieldRef<"Game", 'Float'>
    readonly ratingCount: FieldRef<"Game", 'Int'>
    readonly createdAt: FieldRef<"Game", 'DateTime'>
    readonly categoryId: FieldRef<"Game", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
  }

  /**
   * Game updateManyAndReturn
   */
  export type GameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to delete.
     */
    limit?: number
  }

  /**
   * Game.category
   */
  export type Game$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    where?: GameCategoryWhereInput
  }

  /**
   * Game.gameGenreTags
   */
  export type Game$gameGenreTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagInclude<ExtArgs> | null
    where?: GameGenreTagWhereInput
    orderBy?: GameGenreTagOrderByWithRelationInput | GameGenreTagOrderByWithRelationInput[]
    cursor?: GameGenreTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameGenreTagScalarFieldEnum | GameGenreTagScalarFieldEnum[]
  }

  /**
   * Game.gameSessions
   */
  export type Game$gameSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    cursor?: GameSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * Game.likes
   */
  export type Game$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeInclude<ExtArgs> | null
    where?: GameLikeWhereInput
    orderBy?: GameLikeOrderByWithRelationInput | GameLikeOrderByWithRelationInput[]
    cursor?: GameLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameLikeScalarFieldEnum | GameLikeScalarFieldEnum[]
  }

  /**
   * Game.ratings
   */
  export type Game$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingInclude<ExtArgs> | null
    where?: GameRatingWhereInput
    orderBy?: GameRatingOrderByWithRelationInput | GameRatingOrderByWithRelationInput[]
    cursor?: GameRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameRatingScalarFieldEnum | GameRatingScalarFieldEnum[]
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model GenreTag
   */

  export type AggregateGenreTag = {
    _count: GenreTagCountAggregateOutputType | null
    _min: GenreTagMinAggregateOutputType | null
    _max: GenreTagMaxAggregateOutputType | null
  }

  export type GenreTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
  }

  export type GenreTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
  }

  export type GenreTagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    _all: number
  }


  export type GenreTagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
  }

  export type GenreTagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
  }

  export type GenreTagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    _all?: true
  }

  export type GenreTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GenreTag to aggregate.
     */
    where?: GenreTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenreTags to fetch.
     */
    orderBy?: GenreTagOrderByWithRelationInput | GenreTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenreTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenreTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenreTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GenreTags
    **/
    _count?: true | GenreTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenreTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenreTagMaxAggregateInputType
  }

  export type GetGenreTagAggregateType<T extends GenreTagAggregateArgs> = {
        [P in keyof T & keyof AggregateGenreTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenreTag[P]>
      : GetScalarType<T[P], AggregateGenreTag[P]>
  }




  export type GenreTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreTagWhereInput
    orderBy?: GenreTagOrderByWithAggregationInput | GenreTagOrderByWithAggregationInput[]
    by: GenreTagScalarFieldEnum[] | GenreTagScalarFieldEnum
    having?: GenreTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenreTagCountAggregateInputType | true
    _min?: GenreTagMinAggregateInputType
    _max?: GenreTagMaxAggregateInputType
  }

  export type GenreTagGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    _count: GenreTagCountAggregateOutputType | null
    _min: GenreTagMinAggregateOutputType | null
    _max: GenreTagMaxAggregateOutputType | null
  }

  type GetGenreTagGroupByPayload<T extends GenreTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenreTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenreTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreTagGroupByOutputType[P]>
            : GetScalarType<T[P], GenreTagGroupByOutputType[P]>
        }
      >
    >


  export type GenreTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    gameGenreTags?: boolean | GenreTag$gameGenreTagsArgs<ExtArgs>
    _count?: boolean | GenreTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genreTag"]>

  export type GenreTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["genreTag"]>

  export type GenreTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["genreTag"]>

  export type GenreTagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
  }

  export type GenreTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt", ExtArgs["result"]["genreTag"]>
  export type GenreTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameGenreTags?: boolean | GenreTag$gameGenreTagsArgs<ExtArgs>
    _count?: boolean | GenreTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenreTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GenreTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenreTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GenreTag"
    objects: {
      gameGenreTags: Prisma.$GameGenreTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      createdAt: Date
    }, ExtArgs["result"]["genreTag"]>
    composites: {}
  }

  type GenreTagGetPayload<S extends boolean | null | undefined | GenreTagDefaultArgs> = $Result.GetResult<Prisma.$GenreTagPayload, S>

  type GenreTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenreTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenreTagCountAggregateInputType | true
    }

  export interface GenreTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GenreTag'], meta: { name: 'GenreTag' } }
    /**
     * Find zero or one GenreTag that matches the filter.
     * @param {GenreTagFindUniqueArgs} args - Arguments to find a GenreTag
     * @example
     * // Get one GenreTag
     * const genreTag = await prisma.genreTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenreTagFindUniqueArgs>(args: SelectSubset<T, GenreTagFindUniqueArgs<ExtArgs>>): Prisma__GenreTagClient<$Result.GetResult<Prisma.$GenreTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GenreTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenreTagFindUniqueOrThrowArgs} args - Arguments to find a GenreTag
     * @example
     * // Get one GenreTag
     * const genreTag = await prisma.genreTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenreTagFindUniqueOrThrowArgs>(args: SelectSubset<T, GenreTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenreTagClient<$Result.GetResult<Prisma.$GenreTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GenreTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreTagFindFirstArgs} args - Arguments to find a GenreTag
     * @example
     * // Get one GenreTag
     * const genreTag = await prisma.genreTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenreTagFindFirstArgs>(args?: SelectSubset<T, GenreTagFindFirstArgs<ExtArgs>>): Prisma__GenreTagClient<$Result.GetResult<Prisma.$GenreTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GenreTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreTagFindFirstOrThrowArgs} args - Arguments to find a GenreTag
     * @example
     * // Get one GenreTag
     * const genreTag = await prisma.genreTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenreTagFindFirstOrThrowArgs>(args?: SelectSubset<T, GenreTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenreTagClient<$Result.GetResult<Prisma.$GenreTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GenreTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GenreTags
     * const genreTags = await prisma.genreTag.findMany()
     * 
     * // Get first 10 GenreTags
     * const genreTags = await prisma.genreTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genreTagWithIdOnly = await prisma.genreTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenreTagFindManyArgs>(args?: SelectSubset<T, GenreTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenreTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GenreTag.
     * @param {GenreTagCreateArgs} args - Arguments to create a GenreTag.
     * @example
     * // Create one GenreTag
     * const GenreTag = await prisma.genreTag.create({
     *   data: {
     *     // ... data to create a GenreTag
     *   }
     * })
     * 
     */
    create<T extends GenreTagCreateArgs>(args: SelectSubset<T, GenreTagCreateArgs<ExtArgs>>): Prisma__GenreTagClient<$Result.GetResult<Prisma.$GenreTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GenreTags.
     * @param {GenreTagCreateManyArgs} args - Arguments to create many GenreTags.
     * @example
     * // Create many GenreTags
     * const genreTag = await prisma.genreTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenreTagCreateManyArgs>(args?: SelectSubset<T, GenreTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GenreTags and returns the data saved in the database.
     * @param {GenreTagCreateManyAndReturnArgs} args - Arguments to create many GenreTags.
     * @example
     * // Create many GenreTags
     * const genreTag = await prisma.genreTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GenreTags and only return the `id`
     * const genreTagWithIdOnly = await prisma.genreTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenreTagCreateManyAndReturnArgs>(args?: SelectSubset<T, GenreTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenreTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GenreTag.
     * @param {GenreTagDeleteArgs} args - Arguments to delete one GenreTag.
     * @example
     * // Delete one GenreTag
     * const GenreTag = await prisma.genreTag.delete({
     *   where: {
     *     // ... filter to delete one GenreTag
     *   }
     * })
     * 
     */
    delete<T extends GenreTagDeleteArgs>(args: SelectSubset<T, GenreTagDeleteArgs<ExtArgs>>): Prisma__GenreTagClient<$Result.GetResult<Prisma.$GenreTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GenreTag.
     * @param {GenreTagUpdateArgs} args - Arguments to update one GenreTag.
     * @example
     * // Update one GenreTag
     * const genreTag = await prisma.genreTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenreTagUpdateArgs>(args: SelectSubset<T, GenreTagUpdateArgs<ExtArgs>>): Prisma__GenreTagClient<$Result.GetResult<Prisma.$GenreTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GenreTags.
     * @param {GenreTagDeleteManyArgs} args - Arguments to filter GenreTags to delete.
     * @example
     * // Delete a few GenreTags
     * const { count } = await prisma.genreTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenreTagDeleteManyArgs>(args?: SelectSubset<T, GenreTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenreTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GenreTags
     * const genreTag = await prisma.genreTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenreTagUpdateManyArgs>(args: SelectSubset<T, GenreTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenreTags and returns the data updated in the database.
     * @param {GenreTagUpdateManyAndReturnArgs} args - Arguments to update many GenreTags.
     * @example
     * // Update many GenreTags
     * const genreTag = await prisma.genreTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GenreTags and only return the `id`
     * const genreTagWithIdOnly = await prisma.genreTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenreTagUpdateManyAndReturnArgs>(args: SelectSubset<T, GenreTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenreTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GenreTag.
     * @param {GenreTagUpsertArgs} args - Arguments to update or create a GenreTag.
     * @example
     * // Update or create a GenreTag
     * const genreTag = await prisma.genreTag.upsert({
     *   create: {
     *     // ... data to create a GenreTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GenreTag we want to update
     *   }
     * })
     */
    upsert<T extends GenreTagUpsertArgs>(args: SelectSubset<T, GenreTagUpsertArgs<ExtArgs>>): Prisma__GenreTagClient<$Result.GetResult<Prisma.$GenreTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GenreTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreTagCountArgs} args - Arguments to filter GenreTags to count.
     * @example
     * // Count the number of GenreTags
     * const count = await prisma.genreTag.count({
     *   where: {
     *     // ... the filter for the GenreTags we want to count
     *   }
     * })
    **/
    count<T extends GenreTagCountArgs>(
      args?: Subset<T, GenreTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GenreTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreTagAggregateArgs>(args: Subset<T, GenreTagAggregateArgs>): Prisma.PrismaPromise<GetGenreTagAggregateType<T>>

    /**
     * Group by GenreTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenreTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenreTagGroupByArgs['orderBy'] }
        : { orderBy?: GenreTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenreTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenreTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GenreTag model
   */
  readonly fields: GenreTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GenreTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenreTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gameGenreTags<T extends GenreTag$gameGenreTagsArgs<ExtArgs> = {}>(args?: Subset<T, GenreTag$gameGenreTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GenreTag model
   */
  interface GenreTagFieldRefs {
    readonly id: FieldRef<"GenreTag", 'String'>
    readonly name: FieldRef<"GenreTag", 'String'>
    readonly slug: FieldRef<"GenreTag", 'String'>
    readonly createdAt: FieldRef<"GenreTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GenreTag findUnique
   */
  export type GenreTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTag
     */
    select?: GenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreTag
     */
    omit?: GenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreTagInclude<ExtArgs> | null
    /**
     * Filter, which GenreTag to fetch.
     */
    where: GenreTagWhereUniqueInput
  }

  /**
   * GenreTag findUniqueOrThrow
   */
  export type GenreTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTag
     */
    select?: GenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreTag
     */
    omit?: GenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreTagInclude<ExtArgs> | null
    /**
     * Filter, which GenreTag to fetch.
     */
    where: GenreTagWhereUniqueInput
  }

  /**
   * GenreTag findFirst
   */
  export type GenreTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTag
     */
    select?: GenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreTag
     */
    omit?: GenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreTagInclude<ExtArgs> | null
    /**
     * Filter, which GenreTag to fetch.
     */
    where?: GenreTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenreTags to fetch.
     */
    orderBy?: GenreTagOrderByWithRelationInput | GenreTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenreTags.
     */
    cursor?: GenreTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenreTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenreTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenreTags.
     */
    distinct?: GenreTagScalarFieldEnum | GenreTagScalarFieldEnum[]
  }

  /**
   * GenreTag findFirstOrThrow
   */
  export type GenreTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTag
     */
    select?: GenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreTag
     */
    omit?: GenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreTagInclude<ExtArgs> | null
    /**
     * Filter, which GenreTag to fetch.
     */
    where?: GenreTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenreTags to fetch.
     */
    orderBy?: GenreTagOrderByWithRelationInput | GenreTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenreTags.
     */
    cursor?: GenreTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenreTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenreTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenreTags.
     */
    distinct?: GenreTagScalarFieldEnum | GenreTagScalarFieldEnum[]
  }

  /**
   * GenreTag findMany
   */
  export type GenreTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTag
     */
    select?: GenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreTag
     */
    omit?: GenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreTagInclude<ExtArgs> | null
    /**
     * Filter, which GenreTags to fetch.
     */
    where?: GenreTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenreTags to fetch.
     */
    orderBy?: GenreTagOrderByWithRelationInput | GenreTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GenreTags.
     */
    cursor?: GenreTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenreTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenreTags.
     */
    skip?: number
    distinct?: GenreTagScalarFieldEnum | GenreTagScalarFieldEnum[]
  }

  /**
   * GenreTag create
   */
  export type GenreTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTag
     */
    select?: GenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreTag
     */
    omit?: GenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreTagInclude<ExtArgs> | null
    /**
     * The data needed to create a GenreTag.
     */
    data: XOR<GenreTagCreateInput, GenreTagUncheckedCreateInput>
  }

  /**
   * GenreTag createMany
   */
  export type GenreTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GenreTags.
     */
    data: GenreTagCreateManyInput | GenreTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GenreTag createManyAndReturn
   */
  export type GenreTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTag
     */
    select?: GenreTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GenreTag
     */
    omit?: GenreTagOmit<ExtArgs> | null
    /**
     * The data used to create many GenreTags.
     */
    data: GenreTagCreateManyInput | GenreTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GenreTag update
   */
  export type GenreTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTag
     */
    select?: GenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreTag
     */
    omit?: GenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreTagInclude<ExtArgs> | null
    /**
     * The data needed to update a GenreTag.
     */
    data: XOR<GenreTagUpdateInput, GenreTagUncheckedUpdateInput>
    /**
     * Choose, which GenreTag to update.
     */
    where: GenreTagWhereUniqueInput
  }

  /**
   * GenreTag updateMany
   */
  export type GenreTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GenreTags.
     */
    data: XOR<GenreTagUpdateManyMutationInput, GenreTagUncheckedUpdateManyInput>
    /**
     * Filter which GenreTags to update
     */
    where?: GenreTagWhereInput
    /**
     * Limit how many GenreTags to update.
     */
    limit?: number
  }

  /**
   * GenreTag updateManyAndReturn
   */
  export type GenreTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTag
     */
    select?: GenreTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GenreTag
     */
    omit?: GenreTagOmit<ExtArgs> | null
    /**
     * The data used to update GenreTags.
     */
    data: XOR<GenreTagUpdateManyMutationInput, GenreTagUncheckedUpdateManyInput>
    /**
     * Filter which GenreTags to update
     */
    where?: GenreTagWhereInput
    /**
     * Limit how many GenreTags to update.
     */
    limit?: number
  }

  /**
   * GenreTag upsert
   */
  export type GenreTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTag
     */
    select?: GenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreTag
     */
    omit?: GenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreTagInclude<ExtArgs> | null
    /**
     * The filter to search for the GenreTag to update in case it exists.
     */
    where: GenreTagWhereUniqueInput
    /**
     * In case the GenreTag found by the `where` argument doesn't exist, create a new GenreTag with this data.
     */
    create: XOR<GenreTagCreateInput, GenreTagUncheckedCreateInput>
    /**
     * In case the GenreTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenreTagUpdateInput, GenreTagUncheckedUpdateInput>
  }

  /**
   * GenreTag delete
   */
  export type GenreTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTag
     */
    select?: GenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreTag
     */
    omit?: GenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreTagInclude<ExtArgs> | null
    /**
     * Filter which GenreTag to delete.
     */
    where: GenreTagWhereUniqueInput
  }

  /**
   * GenreTag deleteMany
   */
  export type GenreTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GenreTags to delete
     */
    where?: GenreTagWhereInput
    /**
     * Limit how many GenreTags to delete.
     */
    limit?: number
  }

  /**
   * GenreTag.gameGenreTags
   */
  export type GenreTag$gameGenreTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagInclude<ExtArgs> | null
    where?: GameGenreTagWhereInput
    orderBy?: GameGenreTagOrderByWithRelationInput | GameGenreTagOrderByWithRelationInput[]
    cursor?: GameGenreTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameGenreTagScalarFieldEnum | GameGenreTagScalarFieldEnum[]
  }

  /**
   * GenreTag without action
   */
  export type GenreTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreTag
     */
    select?: GenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreTag
     */
    omit?: GenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreTagInclude<ExtArgs> | null
  }


  /**
   * Model GameGenreTag
   */

  export type AggregateGameGenreTag = {
    _count: GameGenreTagCountAggregateOutputType | null
    _min: GameGenreTagMinAggregateOutputType | null
    _max: GameGenreTagMaxAggregateOutputType | null
  }

  export type GameGenreTagMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    genreTagId: string | null
    assignedAt: Date | null
  }

  export type GameGenreTagMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    genreTagId: string | null
    assignedAt: Date | null
  }

  export type GameGenreTagCountAggregateOutputType = {
    id: number
    gameId: number
    genreTagId: number
    assignedAt: number
    _all: number
  }


  export type GameGenreTagMinAggregateInputType = {
    id?: true
    gameId?: true
    genreTagId?: true
    assignedAt?: true
  }

  export type GameGenreTagMaxAggregateInputType = {
    id?: true
    gameId?: true
    genreTagId?: true
    assignedAt?: true
  }

  export type GameGenreTagCountAggregateInputType = {
    id?: true
    gameId?: true
    genreTagId?: true
    assignedAt?: true
    _all?: true
  }

  export type GameGenreTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameGenreTag to aggregate.
     */
    where?: GameGenreTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameGenreTags to fetch.
     */
    orderBy?: GameGenreTagOrderByWithRelationInput | GameGenreTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameGenreTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameGenreTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameGenreTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameGenreTags
    **/
    _count?: true | GameGenreTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameGenreTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameGenreTagMaxAggregateInputType
  }

  export type GetGameGenreTagAggregateType<T extends GameGenreTagAggregateArgs> = {
        [P in keyof T & keyof AggregateGameGenreTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameGenreTag[P]>
      : GetScalarType<T[P], AggregateGameGenreTag[P]>
  }




  export type GameGenreTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameGenreTagWhereInput
    orderBy?: GameGenreTagOrderByWithAggregationInput | GameGenreTagOrderByWithAggregationInput[]
    by: GameGenreTagScalarFieldEnum[] | GameGenreTagScalarFieldEnum
    having?: GameGenreTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameGenreTagCountAggregateInputType | true
    _min?: GameGenreTagMinAggregateInputType
    _max?: GameGenreTagMaxAggregateInputType
  }

  export type GameGenreTagGroupByOutputType = {
    id: string
    gameId: string
    genreTagId: string
    assignedAt: Date
    _count: GameGenreTagCountAggregateOutputType | null
    _min: GameGenreTagMinAggregateOutputType | null
    _max: GameGenreTagMaxAggregateOutputType | null
  }

  type GetGameGenreTagGroupByPayload<T extends GameGenreTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGenreTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGenreTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGenreTagGroupByOutputType[P]>
            : GetScalarType<T[P], GameGenreTagGroupByOutputType[P]>
        }
      >
    >


  export type GameGenreTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    genreTagId?: boolean
    assignedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    genreTag?: boolean | GenreTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameGenreTag"]>

  export type GameGenreTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    genreTagId?: boolean
    assignedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    genreTag?: boolean | GenreTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameGenreTag"]>

  export type GameGenreTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    genreTagId?: boolean
    assignedAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    genreTag?: boolean | GenreTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameGenreTag"]>

  export type GameGenreTagSelectScalar = {
    id?: boolean
    gameId?: boolean
    genreTagId?: boolean
    assignedAt?: boolean
  }

  export type GameGenreTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "genreTagId" | "assignedAt", ExtArgs["result"]["gameGenreTag"]>
  export type GameGenreTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    genreTag?: boolean | GenreTagDefaultArgs<ExtArgs>
  }
  export type GameGenreTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    genreTag?: boolean | GenreTagDefaultArgs<ExtArgs>
  }
  export type GameGenreTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    genreTag?: boolean | GenreTagDefaultArgs<ExtArgs>
  }

  export type $GameGenreTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameGenreTag"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      genreTag: Prisma.$GenreTagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      genreTagId: string
      assignedAt: Date
    }, ExtArgs["result"]["gameGenreTag"]>
    composites: {}
  }

  type GameGenreTagGetPayload<S extends boolean | null | undefined | GameGenreTagDefaultArgs> = $Result.GetResult<Prisma.$GameGenreTagPayload, S>

  type GameGenreTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameGenreTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameGenreTagCountAggregateInputType | true
    }

  export interface GameGenreTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameGenreTag'], meta: { name: 'GameGenreTag' } }
    /**
     * Find zero or one GameGenreTag that matches the filter.
     * @param {GameGenreTagFindUniqueArgs} args - Arguments to find a GameGenreTag
     * @example
     * // Get one GameGenreTag
     * const gameGenreTag = await prisma.gameGenreTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameGenreTagFindUniqueArgs>(args: SelectSubset<T, GameGenreTagFindUniqueArgs<ExtArgs>>): Prisma__GameGenreTagClient<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameGenreTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameGenreTagFindUniqueOrThrowArgs} args - Arguments to find a GameGenreTag
     * @example
     * // Get one GameGenreTag
     * const gameGenreTag = await prisma.gameGenreTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameGenreTagFindUniqueOrThrowArgs>(args: SelectSubset<T, GameGenreTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameGenreTagClient<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameGenreTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreTagFindFirstArgs} args - Arguments to find a GameGenreTag
     * @example
     * // Get one GameGenreTag
     * const gameGenreTag = await prisma.gameGenreTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameGenreTagFindFirstArgs>(args?: SelectSubset<T, GameGenreTagFindFirstArgs<ExtArgs>>): Prisma__GameGenreTagClient<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameGenreTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreTagFindFirstOrThrowArgs} args - Arguments to find a GameGenreTag
     * @example
     * // Get one GameGenreTag
     * const gameGenreTag = await prisma.gameGenreTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameGenreTagFindFirstOrThrowArgs>(args?: SelectSubset<T, GameGenreTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameGenreTagClient<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameGenreTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameGenreTags
     * const gameGenreTags = await prisma.gameGenreTag.findMany()
     * 
     * // Get first 10 GameGenreTags
     * const gameGenreTags = await prisma.gameGenreTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameGenreTagWithIdOnly = await prisma.gameGenreTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameGenreTagFindManyArgs>(args?: SelectSubset<T, GameGenreTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameGenreTag.
     * @param {GameGenreTagCreateArgs} args - Arguments to create a GameGenreTag.
     * @example
     * // Create one GameGenreTag
     * const GameGenreTag = await prisma.gameGenreTag.create({
     *   data: {
     *     // ... data to create a GameGenreTag
     *   }
     * })
     * 
     */
    create<T extends GameGenreTagCreateArgs>(args: SelectSubset<T, GameGenreTagCreateArgs<ExtArgs>>): Prisma__GameGenreTagClient<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameGenreTags.
     * @param {GameGenreTagCreateManyArgs} args - Arguments to create many GameGenreTags.
     * @example
     * // Create many GameGenreTags
     * const gameGenreTag = await prisma.gameGenreTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameGenreTagCreateManyArgs>(args?: SelectSubset<T, GameGenreTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameGenreTags and returns the data saved in the database.
     * @param {GameGenreTagCreateManyAndReturnArgs} args - Arguments to create many GameGenreTags.
     * @example
     * // Create many GameGenreTags
     * const gameGenreTag = await prisma.gameGenreTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameGenreTags and only return the `id`
     * const gameGenreTagWithIdOnly = await prisma.gameGenreTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameGenreTagCreateManyAndReturnArgs>(args?: SelectSubset<T, GameGenreTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameGenreTag.
     * @param {GameGenreTagDeleteArgs} args - Arguments to delete one GameGenreTag.
     * @example
     * // Delete one GameGenreTag
     * const GameGenreTag = await prisma.gameGenreTag.delete({
     *   where: {
     *     // ... filter to delete one GameGenreTag
     *   }
     * })
     * 
     */
    delete<T extends GameGenreTagDeleteArgs>(args: SelectSubset<T, GameGenreTagDeleteArgs<ExtArgs>>): Prisma__GameGenreTagClient<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameGenreTag.
     * @param {GameGenreTagUpdateArgs} args - Arguments to update one GameGenreTag.
     * @example
     * // Update one GameGenreTag
     * const gameGenreTag = await prisma.gameGenreTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameGenreTagUpdateArgs>(args: SelectSubset<T, GameGenreTagUpdateArgs<ExtArgs>>): Prisma__GameGenreTagClient<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameGenreTags.
     * @param {GameGenreTagDeleteManyArgs} args - Arguments to filter GameGenreTags to delete.
     * @example
     * // Delete a few GameGenreTags
     * const { count } = await prisma.gameGenreTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameGenreTagDeleteManyArgs>(args?: SelectSubset<T, GameGenreTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameGenreTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameGenreTags
     * const gameGenreTag = await prisma.gameGenreTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameGenreTagUpdateManyArgs>(args: SelectSubset<T, GameGenreTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameGenreTags and returns the data updated in the database.
     * @param {GameGenreTagUpdateManyAndReturnArgs} args - Arguments to update many GameGenreTags.
     * @example
     * // Update many GameGenreTags
     * const gameGenreTag = await prisma.gameGenreTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameGenreTags and only return the `id`
     * const gameGenreTagWithIdOnly = await prisma.gameGenreTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameGenreTagUpdateManyAndReturnArgs>(args: SelectSubset<T, GameGenreTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameGenreTag.
     * @param {GameGenreTagUpsertArgs} args - Arguments to update or create a GameGenreTag.
     * @example
     * // Update or create a GameGenreTag
     * const gameGenreTag = await prisma.gameGenreTag.upsert({
     *   create: {
     *     // ... data to create a GameGenreTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameGenreTag we want to update
     *   }
     * })
     */
    upsert<T extends GameGenreTagUpsertArgs>(args: SelectSubset<T, GameGenreTagUpsertArgs<ExtArgs>>): Prisma__GameGenreTagClient<$Result.GetResult<Prisma.$GameGenreTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameGenreTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreTagCountArgs} args - Arguments to filter GameGenreTags to count.
     * @example
     * // Count the number of GameGenreTags
     * const count = await prisma.gameGenreTag.count({
     *   where: {
     *     // ... the filter for the GameGenreTags we want to count
     *   }
     * })
    **/
    count<T extends GameGenreTagCountArgs>(
      args?: Subset<T, GameGenreTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameGenreTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameGenreTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameGenreTagAggregateArgs>(args: Subset<T, GameGenreTagAggregateArgs>): Prisma.PrismaPromise<GetGameGenreTagAggregateType<T>>

    /**
     * Group by GameGenreTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGenreTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGenreTagGroupByArgs['orderBy'] }
        : { orderBy?: GameGenreTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGenreTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGenreTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameGenreTag model
   */
  readonly fields: GameGenreTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameGenreTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameGenreTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    genreTag<T extends GenreTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenreTagDefaultArgs<ExtArgs>>): Prisma__GenreTagClient<$Result.GetResult<Prisma.$GenreTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameGenreTag model
   */
  interface GameGenreTagFieldRefs {
    readonly id: FieldRef<"GameGenreTag", 'String'>
    readonly gameId: FieldRef<"GameGenreTag", 'String'>
    readonly genreTagId: FieldRef<"GameGenreTag", 'String'>
    readonly assignedAt: FieldRef<"GameGenreTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameGenreTag findUnique
   */
  export type GameGenreTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagInclude<ExtArgs> | null
    /**
     * Filter, which GameGenreTag to fetch.
     */
    where: GameGenreTagWhereUniqueInput
  }

  /**
   * GameGenreTag findUniqueOrThrow
   */
  export type GameGenreTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagInclude<ExtArgs> | null
    /**
     * Filter, which GameGenreTag to fetch.
     */
    where: GameGenreTagWhereUniqueInput
  }

  /**
   * GameGenreTag findFirst
   */
  export type GameGenreTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagInclude<ExtArgs> | null
    /**
     * Filter, which GameGenreTag to fetch.
     */
    where?: GameGenreTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameGenreTags to fetch.
     */
    orderBy?: GameGenreTagOrderByWithRelationInput | GameGenreTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameGenreTags.
     */
    cursor?: GameGenreTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameGenreTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameGenreTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameGenreTags.
     */
    distinct?: GameGenreTagScalarFieldEnum | GameGenreTagScalarFieldEnum[]
  }

  /**
   * GameGenreTag findFirstOrThrow
   */
  export type GameGenreTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagInclude<ExtArgs> | null
    /**
     * Filter, which GameGenreTag to fetch.
     */
    where?: GameGenreTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameGenreTags to fetch.
     */
    orderBy?: GameGenreTagOrderByWithRelationInput | GameGenreTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameGenreTags.
     */
    cursor?: GameGenreTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameGenreTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameGenreTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameGenreTags.
     */
    distinct?: GameGenreTagScalarFieldEnum | GameGenreTagScalarFieldEnum[]
  }

  /**
   * GameGenreTag findMany
   */
  export type GameGenreTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagInclude<ExtArgs> | null
    /**
     * Filter, which GameGenreTags to fetch.
     */
    where?: GameGenreTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameGenreTags to fetch.
     */
    orderBy?: GameGenreTagOrderByWithRelationInput | GameGenreTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameGenreTags.
     */
    cursor?: GameGenreTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameGenreTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameGenreTags.
     */
    skip?: number
    distinct?: GameGenreTagScalarFieldEnum | GameGenreTagScalarFieldEnum[]
  }

  /**
   * GameGenreTag create
   */
  export type GameGenreTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagInclude<ExtArgs> | null
    /**
     * The data needed to create a GameGenreTag.
     */
    data: XOR<GameGenreTagCreateInput, GameGenreTagUncheckedCreateInput>
  }

  /**
   * GameGenreTag createMany
   */
  export type GameGenreTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameGenreTags.
     */
    data: GameGenreTagCreateManyInput | GameGenreTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameGenreTag createManyAndReturn
   */
  export type GameGenreTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * The data used to create many GameGenreTags.
     */
    data: GameGenreTagCreateManyInput | GameGenreTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameGenreTag update
   */
  export type GameGenreTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagInclude<ExtArgs> | null
    /**
     * The data needed to update a GameGenreTag.
     */
    data: XOR<GameGenreTagUpdateInput, GameGenreTagUncheckedUpdateInput>
    /**
     * Choose, which GameGenreTag to update.
     */
    where: GameGenreTagWhereUniqueInput
  }

  /**
   * GameGenreTag updateMany
   */
  export type GameGenreTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameGenreTags.
     */
    data: XOR<GameGenreTagUpdateManyMutationInput, GameGenreTagUncheckedUpdateManyInput>
    /**
     * Filter which GameGenreTags to update
     */
    where?: GameGenreTagWhereInput
    /**
     * Limit how many GameGenreTags to update.
     */
    limit?: number
  }

  /**
   * GameGenreTag updateManyAndReturn
   */
  export type GameGenreTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * The data used to update GameGenreTags.
     */
    data: XOR<GameGenreTagUpdateManyMutationInput, GameGenreTagUncheckedUpdateManyInput>
    /**
     * Filter which GameGenreTags to update
     */
    where?: GameGenreTagWhereInput
    /**
     * Limit how many GameGenreTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameGenreTag upsert
   */
  export type GameGenreTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagInclude<ExtArgs> | null
    /**
     * The filter to search for the GameGenreTag to update in case it exists.
     */
    where: GameGenreTagWhereUniqueInput
    /**
     * In case the GameGenreTag found by the `where` argument doesn't exist, create a new GameGenreTag with this data.
     */
    create: XOR<GameGenreTagCreateInput, GameGenreTagUncheckedCreateInput>
    /**
     * In case the GameGenreTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameGenreTagUpdateInput, GameGenreTagUncheckedUpdateInput>
  }

  /**
   * GameGenreTag delete
   */
  export type GameGenreTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagInclude<ExtArgs> | null
    /**
     * Filter which GameGenreTag to delete.
     */
    where: GameGenreTagWhereUniqueInput
  }

  /**
   * GameGenreTag deleteMany
   */
  export type GameGenreTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameGenreTags to delete
     */
    where?: GameGenreTagWhereInput
    /**
     * Limit how many GameGenreTags to delete.
     */
    limit?: number
  }

  /**
   * GameGenreTag without action
   */
  export type GameGenreTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameGenreTag
     */
    select?: GameGenreTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameGenreTag
     */
    omit?: GameGenreTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreTagInclude<ExtArgs> | null
  }


  /**
   * Model GameLike
   */

  export type AggregateGameLike = {
    _count: GameLikeCountAggregateOutputType | null
    _min: GameLikeMinAggregateOutputType | null
    _max: GameLikeMaxAggregateOutputType | null
  }

  export type GameLikeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    gameId: string | null
    createdAt: Date | null
  }

  export type GameLikeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    gameId: string | null
    createdAt: Date | null
  }

  export type GameLikeCountAggregateOutputType = {
    id: number
    userId: number
    gameId: number
    createdAt: number
    _all: number
  }


  export type GameLikeMinAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    createdAt?: true
  }

  export type GameLikeMaxAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    createdAt?: true
  }

  export type GameLikeCountAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    createdAt?: true
    _all?: true
  }

  export type GameLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameLike to aggregate.
     */
    where?: GameLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameLikes to fetch.
     */
    orderBy?: GameLikeOrderByWithRelationInput | GameLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameLikes
    **/
    _count?: true | GameLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameLikeMaxAggregateInputType
  }

  export type GetGameLikeAggregateType<T extends GameLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateGameLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameLike[P]>
      : GetScalarType<T[P], AggregateGameLike[P]>
  }




  export type GameLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameLikeWhereInput
    orderBy?: GameLikeOrderByWithAggregationInput | GameLikeOrderByWithAggregationInput[]
    by: GameLikeScalarFieldEnum[] | GameLikeScalarFieldEnum
    having?: GameLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameLikeCountAggregateInputType | true
    _min?: GameLikeMinAggregateInputType
    _max?: GameLikeMaxAggregateInputType
  }

  export type GameLikeGroupByOutputType = {
    id: string
    userId: string
    gameId: string
    createdAt: Date
    _count: GameLikeCountAggregateOutputType | null
    _min: GameLikeMinAggregateOutputType | null
    _max: GameLikeMaxAggregateOutputType | null
  }

  type GetGameLikeGroupByPayload<T extends GameLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameLikeGroupByOutputType[P]>
            : GetScalarType<T[P], GameLikeGroupByOutputType[P]>
        }
      >
    >


  export type GameLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameLike"]>

  export type GameLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameLike"]>

  export type GameLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameLike"]>

  export type GameLikeSelectScalar = {
    id?: boolean
    userId?: boolean
    gameId?: boolean
    createdAt?: boolean
  }

  export type GameLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "gameId" | "createdAt", ExtArgs["result"]["gameLike"]>
  export type GameLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $GameLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameLike"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      gameId: string
      createdAt: Date
    }, ExtArgs["result"]["gameLike"]>
    composites: {}
  }

  type GameLikeGetPayload<S extends boolean | null | undefined | GameLikeDefaultArgs> = $Result.GetResult<Prisma.$GameLikePayload, S>

  type GameLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameLikeCountAggregateInputType | true
    }

  export interface GameLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameLike'], meta: { name: 'GameLike' } }
    /**
     * Find zero or one GameLike that matches the filter.
     * @param {GameLikeFindUniqueArgs} args - Arguments to find a GameLike
     * @example
     * // Get one GameLike
     * const gameLike = await prisma.gameLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameLikeFindUniqueArgs>(args: SelectSubset<T, GameLikeFindUniqueArgs<ExtArgs>>): Prisma__GameLikeClient<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameLikeFindUniqueOrThrowArgs} args - Arguments to find a GameLike
     * @example
     * // Get one GameLike
     * const gameLike = await prisma.gameLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, GameLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameLikeClient<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLikeFindFirstArgs} args - Arguments to find a GameLike
     * @example
     * // Get one GameLike
     * const gameLike = await prisma.gameLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameLikeFindFirstArgs>(args?: SelectSubset<T, GameLikeFindFirstArgs<ExtArgs>>): Prisma__GameLikeClient<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLikeFindFirstOrThrowArgs} args - Arguments to find a GameLike
     * @example
     * // Get one GameLike
     * const gameLike = await prisma.gameLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, GameLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameLikeClient<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameLikes
     * const gameLikes = await prisma.gameLike.findMany()
     * 
     * // Get first 10 GameLikes
     * const gameLikes = await prisma.gameLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameLikeWithIdOnly = await prisma.gameLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameLikeFindManyArgs>(args?: SelectSubset<T, GameLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameLike.
     * @param {GameLikeCreateArgs} args - Arguments to create a GameLike.
     * @example
     * // Create one GameLike
     * const GameLike = await prisma.gameLike.create({
     *   data: {
     *     // ... data to create a GameLike
     *   }
     * })
     * 
     */
    create<T extends GameLikeCreateArgs>(args: SelectSubset<T, GameLikeCreateArgs<ExtArgs>>): Prisma__GameLikeClient<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameLikes.
     * @param {GameLikeCreateManyArgs} args - Arguments to create many GameLikes.
     * @example
     * // Create many GameLikes
     * const gameLike = await prisma.gameLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameLikeCreateManyArgs>(args?: SelectSubset<T, GameLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameLikes and returns the data saved in the database.
     * @param {GameLikeCreateManyAndReturnArgs} args - Arguments to create many GameLikes.
     * @example
     * // Create many GameLikes
     * const gameLike = await prisma.gameLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameLikes and only return the `id`
     * const gameLikeWithIdOnly = await prisma.gameLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, GameLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameLike.
     * @param {GameLikeDeleteArgs} args - Arguments to delete one GameLike.
     * @example
     * // Delete one GameLike
     * const GameLike = await prisma.gameLike.delete({
     *   where: {
     *     // ... filter to delete one GameLike
     *   }
     * })
     * 
     */
    delete<T extends GameLikeDeleteArgs>(args: SelectSubset<T, GameLikeDeleteArgs<ExtArgs>>): Prisma__GameLikeClient<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameLike.
     * @param {GameLikeUpdateArgs} args - Arguments to update one GameLike.
     * @example
     * // Update one GameLike
     * const gameLike = await prisma.gameLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameLikeUpdateArgs>(args: SelectSubset<T, GameLikeUpdateArgs<ExtArgs>>): Prisma__GameLikeClient<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameLikes.
     * @param {GameLikeDeleteManyArgs} args - Arguments to filter GameLikes to delete.
     * @example
     * // Delete a few GameLikes
     * const { count } = await prisma.gameLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameLikeDeleteManyArgs>(args?: SelectSubset<T, GameLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameLikes
     * const gameLike = await prisma.gameLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameLikeUpdateManyArgs>(args: SelectSubset<T, GameLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameLikes and returns the data updated in the database.
     * @param {GameLikeUpdateManyAndReturnArgs} args - Arguments to update many GameLikes.
     * @example
     * // Update many GameLikes
     * const gameLike = await prisma.gameLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameLikes and only return the `id`
     * const gameLikeWithIdOnly = await prisma.gameLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, GameLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameLike.
     * @param {GameLikeUpsertArgs} args - Arguments to update or create a GameLike.
     * @example
     * // Update or create a GameLike
     * const gameLike = await prisma.gameLike.upsert({
     *   create: {
     *     // ... data to create a GameLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameLike we want to update
     *   }
     * })
     */
    upsert<T extends GameLikeUpsertArgs>(args: SelectSubset<T, GameLikeUpsertArgs<ExtArgs>>): Prisma__GameLikeClient<$Result.GetResult<Prisma.$GameLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLikeCountArgs} args - Arguments to filter GameLikes to count.
     * @example
     * // Count the number of GameLikes
     * const count = await prisma.gameLike.count({
     *   where: {
     *     // ... the filter for the GameLikes we want to count
     *   }
     * })
    **/
    count<T extends GameLikeCountArgs>(
      args?: Subset<T, GameLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameLikeAggregateArgs>(args: Subset<T, GameLikeAggregateArgs>): Prisma.PrismaPromise<GetGameLikeAggregateType<T>>

    /**
     * Group by GameLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameLikeGroupByArgs['orderBy'] }
        : { orderBy?: GameLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameLike model
   */
  readonly fields: GameLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameLike model
   */
  interface GameLikeFieldRefs {
    readonly id: FieldRef<"GameLike", 'String'>
    readonly userId: FieldRef<"GameLike", 'String'>
    readonly gameId: FieldRef<"GameLike", 'String'>
    readonly createdAt: FieldRef<"GameLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameLike findUnique
   */
  export type GameLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeInclude<ExtArgs> | null
    /**
     * Filter, which GameLike to fetch.
     */
    where: GameLikeWhereUniqueInput
  }

  /**
   * GameLike findUniqueOrThrow
   */
  export type GameLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeInclude<ExtArgs> | null
    /**
     * Filter, which GameLike to fetch.
     */
    where: GameLikeWhereUniqueInput
  }

  /**
   * GameLike findFirst
   */
  export type GameLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeInclude<ExtArgs> | null
    /**
     * Filter, which GameLike to fetch.
     */
    where?: GameLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameLikes to fetch.
     */
    orderBy?: GameLikeOrderByWithRelationInput | GameLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameLikes.
     */
    cursor?: GameLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameLikes.
     */
    distinct?: GameLikeScalarFieldEnum | GameLikeScalarFieldEnum[]
  }

  /**
   * GameLike findFirstOrThrow
   */
  export type GameLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeInclude<ExtArgs> | null
    /**
     * Filter, which GameLike to fetch.
     */
    where?: GameLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameLikes to fetch.
     */
    orderBy?: GameLikeOrderByWithRelationInput | GameLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameLikes.
     */
    cursor?: GameLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameLikes.
     */
    distinct?: GameLikeScalarFieldEnum | GameLikeScalarFieldEnum[]
  }

  /**
   * GameLike findMany
   */
  export type GameLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeInclude<ExtArgs> | null
    /**
     * Filter, which GameLikes to fetch.
     */
    where?: GameLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameLikes to fetch.
     */
    orderBy?: GameLikeOrderByWithRelationInput | GameLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameLikes.
     */
    cursor?: GameLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameLikes.
     */
    skip?: number
    distinct?: GameLikeScalarFieldEnum | GameLikeScalarFieldEnum[]
  }

  /**
   * GameLike create
   */
  export type GameLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a GameLike.
     */
    data: XOR<GameLikeCreateInput, GameLikeUncheckedCreateInput>
  }

  /**
   * GameLike createMany
   */
  export type GameLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameLikes.
     */
    data: GameLikeCreateManyInput | GameLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameLike createManyAndReturn
   */
  export type GameLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * The data used to create many GameLikes.
     */
    data: GameLikeCreateManyInput | GameLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameLike update
   */
  export type GameLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a GameLike.
     */
    data: XOR<GameLikeUpdateInput, GameLikeUncheckedUpdateInput>
    /**
     * Choose, which GameLike to update.
     */
    where: GameLikeWhereUniqueInput
  }

  /**
   * GameLike updateMany
   */
  export type GameLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameLikes.
     */
    data: XOR<GameLikeUpdateManyMutationInput, GameLikeUncheckedUpdateManyInput>
    /**
     * Filter which GameLikes to update
     */
    where?: GameLikeWhereInput
    /**
     * Limit how many GameLikes to update.
     */
    limit?: number
  }

  /**
   * GameLike updateManyAndReturn
   */
  export type GameLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * The data used to update GameLikes.
     */
    data: XOR<GameLikeUpdateManyMutationInput, GameLikeUncheckedUpdateManyInput>
    /**
     * Filter which GameLikes to update
     */
    where?: GameLikeWhereInput
    /**
     * Limit how many GameLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameLike upsert
   */
  export type GameLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the GameLike to update in case it exists.
     */
    where: GameLikeWhereUniqueInput
    /**
     * In case the GameLike found by the `where` argument doesn't exist, create a new GameLike with this data.
     */
    create: XOR<GameLikeCreateInput, GameLikeUncheckedCreateInput>
    /**
     * In case the GameLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameLikeUpdateInput, GameLikeUncheckedUpdateInput>
  }

  /**
   * GameLike delete
   */
  export type GameLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeInclude<ExtArgs> | null
    /**
     * Filter which GameLike to delete.
     */
    where: GameLikeWhereUniqueInput
  }

  /**
   * GameLike deleteMany
   */
  export type GameLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameLikes to delete
     */
    where?: GameLikeWhereInput
    /**
     * Limit how many GameLikes to delete.
     */
    limit?: number
  }

  /**
   * GameLike without action
   */
  export type GameLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameLike
     */
    select?: GameLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameLike
     */
    omit?: GameLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameLikeInclude<ExtArgs> | null
  }


  /**
   * Model GameRating
   */

  export type AggregateGameRating = {
    _count: GameRatingCountAggregateOutputType | null
    _avg: GameRatingAvgAggregateOutputType | null
    _sum: GameRatingSumAggregateOutputType | null
    _min: GameRatingMinAggregateOutputType | null
    _max: GameRatingMaxAggregateOutputType | null
  }

  export type GameRatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type GameRatingSumAggregateOutputType = {
    rating: number | null
  }

  export type GameRatingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    gameId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameRatingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    gameId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameRatingCountAggregateOutputType = {
    id: number
    userId: number
    gameId: number
    rating: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameRatingAvgAggregateInputType = {
    rating?: true
  }

  export type GameRatingSumAggregateInputType = {
    rating?: true
  }

  export type GameRatingMinAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameRatingMaxAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameRatingCountAggregateInputType = {
    id?: true
    userId?: true
    gameId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameRating to aggregate.
     */
    where?: GameRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameRatings to fetch.
     */
    orderBy?: GameRatingOrderByWithRelationInput | GameRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameRatings
    **/
    _count?: true | GameRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameRatingMaxAggregateInputType
  }

  export type GetGameRatingAggregateType<T extends GameRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateGameRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameRating[P]>
      : GetScalarType<T[P], AggregateGameRating[P]>
  }




  export type GameRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameRatingWhereInput
    orderBy?: GameRatingOrderByWithAggregationInput | GameRatingOrderByWithAggregationInput[]
    by: GameRatingScalarFieldEnum[] | GameRatingScalarFieldEnum
    having?: GameRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameRatingCountAggregateInputType | true
    _avg?: GameRatingAvgAggregateInputType
    _sum?: GameRatingSumAggregateInputType
    _min?: GameRatingMinAggregateInputType
    _max?: GameRatingMaxAggregateInputType
  }

  export type GameRatingGroupByOutputType = {
    id: string
    userId: string
    gameId: string
    rating: number
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: GameRatingCountAggregateOutputType | null
    _avg: GameRatingAvgAggregateOutputType | null
    _sum: GameRatingSumAggregateOutputType | null
    _min: GameRatingMinAggregateOutputType | null
    _max: GameRatingMaxAggregateOutputType | null
  }

  type GetGameRatingGroupByPayload<T extends GameRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameRatingGroupByOutputType[P]>
            : GetScalarType<T[P], GameRatingGroupByOutputType[P]>
        }
      >
    >


  export type GameRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameRating"]>

  export type GameRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameRating"]>

  export type GameRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gameId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameRating"]>

  export type GameRatingSelectScalar = {
    id?: boolean
    userId?: boolean
    gameId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "gameId" | "rating" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["gameRating"]>
  export type GameRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type GameRatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $GameRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameRating"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      gameId: string
      rating: number
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameRating"]>
    composites: {}
  }

  type GameRatingGetPayload<S extends boolean | null | undefined | GameRatingDefaultArgs> = $Result.GetResult<Prisma.$GameRatingPayload, S>

  type GameRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameRatingCountAggregateInputType | true
    }

  export interface GameRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameRating'], meta: { name: 'GameRating' } }
    /**
     * Find zero or one GameRating that matches the filter.
     * @param {GameRatingFindUniqueArgs} args - Arguments to find a GameRating
     * @example
     * // Get one GameRating
     * const gameRating = await prisma.gameRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameRatingFindUniqueArgs>(args: SelectSubset<T, GameRatingFindUniqueArgs<ExtArgs>>): Prisma__GameRatingClient<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameRatingFindUniqueOrThrowArgs} args - Arguments to find a GameRating
     * @example
     * // Get one GameRating
     * const gameRating = await prisma.gameRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, GameRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameRatingClient<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameRatingFindFirstArgs} args - Arguments to find a GameRating
     * @example
     * // Get one GameRating
     * const gameRating = await prisma.gameRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameRatingFindFirstArgs>(args?: SelectSubset<T, GameRatingFindFirstArgs<ExtArgs>>): Prisma__GameRatingClient<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameRatingFindFirstOrThrowArgs} args - Arguments to find a GameRating
     * @example
     * // Get one GameRating
     * const gameRating = await prisma.gameRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, GameRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameRatingClient<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameRatings
     * const gameRatings = await prisma.gameRating.findMany()
     * 
     * // Get first 10 GameRatings
     * const gameRatings = await prisma.gameRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameRatingWithIdOnly = await prisma.gameRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameRatingFindManyArgs>(args?: SelectSubset<T, GameRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameRating.
     * @param {GameRatingCreateArgs} args - Arguments to create a GameRating.
     * @example
     * // Create one GameRating
     * const GameRating = await prisma.gameRating.create({
     *   data: {
     *     // ... data to create a GameRating
     *   }
     * })
     * 
     */
    create<T extends GameRatingCreateArgs>(args: SelectSubset<T, GameRatingCreateArgs<ExtArgs>>): Prisma__GameRatingClient<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameRatings.
     * @param {GameRatingCreateManyArgs} args - Arguments to create many GameRatings.
     * @example
     * // Create many GameRatings
     * const gameRating = await prisma.gameRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameRatingCreateManyArgs>(args?: SelectSubset<T, GameRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameRatings and returns the data saved in the database.
     * @param {GameRatingCreateManyAndReturnArgs} args - Arguments to create many GameRatings.
     * @example
     * // Create many GameRatings
     * const gameRating = await prisma.gameRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameRatings and only return the `id`
     * const gameRatingWithIdOnly = await prisma.gameRating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, GameRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameRating.
     * @param {GameRatingDeleteArgs} args - Arguments to delete one GameRating.
     * @example
     * // Delete one GameRating
     * const GameRating = await prisma.gameRating.delete({
     *   where: {
     *     // ... filter to delete one GameRating
     *   }
     * })
     * 
     */
    delete<T extends GameRatingDeleteArgs>(args: SelectSubset<T, GameRatingDeleteArgs<ExtArgs>>): Prisma__GameRatingClient<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameRating.
     * @param {GameRatingUpdateArgs} args - Arguments to update one GameRating.
     * @example
     * // Update one GameRating
     * const gameRating = await prisma.gameRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameRatingUpdateArgs>(args: SelectSubset<T, GameRatingUpdateArgs<ExtArgs>>): Prisma__GameRatingClient<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameRatings.
     * @param {GameRatingDeleteManyArgs} args - Arguments to filter GameRatings to delete.
     * @example
     * // Delete a few GameRatings
     * const { count } = await prisma.gameRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameRatingDeleteManyArgs>(args?: SelectSubset<T, GameRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameRatings
     * const gameRating = await prisma.gameRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameRatingUpdateManyArgs>(args: SelectSubset<T, GameRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameRatings and returns the data updated in the database.
     * @param {GameRatingUpdateManyAndReturnArgs} args - Arguments to update many GameRatings.
     * @example
     * // Update many GameRatings
     * const gameRating = await prisma.gameRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameRatings and only return the `id`
     * const gameRatingWithIdOnly = await prisma.gameRating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, GameRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameRating.
     * @param {GameRatingUpsertArgs} args - Arguments to update or create a GameRating.
     * @example
     * // Update or create a GameRating
     * const gameRating = await prisma.gameRating.upsert({
     *   create: {
     *     // ... data to create a GameRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameRating we want to update
     *   }
     * })
     */
    upsert<T extends GameRatingUpsertArgs>(args: SelectSubset<T, GameRatingUpsertArgs<ExtArgs>>): Prisma__GameRatingClient<$Result.GetResult<Prisma.$GameRatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameRatingCountArgs} args - Arguments to filter GameRatings to count.
     * @example
     * // Count the number of GameRatings
     * const count = await prisma.gameRating.count({
     *   where: {
     *     // ... the filter for the GameRatings we want to count
     *   }
     * })
    **/
    count<T extends GameRatingCountArgs>(
      args?: Subset<T, GameRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameRatingAggregateArgs>(args: Subset<T, GameRatingAggregateArgs>): Prisma.PrismaPromise<GetGameRatingAggregateType<T>>

    /**
     * Group by GameRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameRatingGroupByArgs['orderBy'] }
        : { orderBy?: GameRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameRating model
   */
  readonly fields: GameRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameRating model
   */
  interface GameRatingFieldRefs {
    readonly id: FieldRef<"GameRating", 'String'>
    readonly userId: FieldRef<"GameRating", 'String'>
    readonly gameId: FieldRef<"GameRating", 'String'>
    readonly rating: FieldRef<"GameRating", 'Int'>
    readonly comment: FieldRef<"GameRating", 'String'>
    readonly createdAt: FieldRef<"GameRating", 'DateTime'>
    readonly updatedAt: FieldRef<"GameRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameRating findUnique
   */
  export type GameRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingInclude<ExtArgs> | null
    /**
     * Filter, which GameRating to fetch.
     */
    where: GameRatingWhereUniqueInput
  }

  /**
   * GameRating findUniqueOrThrow
   */
  export type GameRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingInclude<ExtArgs> | null
    /**
     * Filter, which GameRating to fetch.
     */
    where: GameRatingWhereUniqueInput
  }

  /**
   * GameRating findFirst
   */
  export type GameRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingInclude<ExtArgs> | null
    /**
     * Filter, which GameRating to fetch.
     */
    where?: GameRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameRatings to fetch.
     */
    orderBy?: GameRatingOrderByWithRelationInput | GameRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameRatings.
     */
    cursor?: GameRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameRatings.
     */
    distinct?: GameRatingScalarFieldEnum | GameRatingScalarFieldEnum[]
  }

  /**
   * GameRating findFirstOrThrow
   */
  export type GameRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingInclude<ExtArgs> | null
    /**
     * Filter, which GameRating to fetch.
     */
    where?: GameRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameRatings to fetch.
     */
    orderBy?: GameRatingOrderByWithRelationInput | GameRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameRatings.
     */
    cursor?: GameRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameRatings.
     */
    distinct?: GameRatingScalarFieldEnum | GameRatingScalarFieldEnum[]
  }

  /**
   * GameRating findMany
   */
  export type GameRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingInclude<ExtArgs> | null
    /**
     * Filter, which GameRatings to fetch.
     */
    where?: GameRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameRatings to fetch.
     */
    orderBy?: GameRatingOrderByWithRelationInput | GameRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameRatings.
     */
    cursor?: GameRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameRatings.
     */
    skip?: number
    distinct?: GameRatingScalarFieldEnum | GameRatingScalarFieldEnum[]
  }

  /**
   * GameRating create
   */
  export type GameRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a GameRating.
     */
    data: XOR<GameRatingCreateInput, GameRatingUncheckedCreateInput>
  }

  /**
   * GameRating createMany
   */
  export type GameRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameRatings.
     */
    data: GameRatingCreateManyInput | GameRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameRating createManyAndReturn
   */
  export type GameRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * The data used to create many GameRatings.
     */
    data: GameRatingCreateManyInput | GameRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameRating update
   */
  export type GameRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a GameRating.
     */
    data: XOR<GameRatingUpdateInput, GameRatingUncheckedUpdateInput>
    /**
     * Choose, which GameRating to update.
     */
    where: GameRatingWhereUniqueInput
  }

  /**
   * GameRating updateMany
   */
  export type GameRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameRatings.
     */
    data: XOR<GameRatingUpdateManyMutationInput, GameRatingUncheckedUpdateManyInput>
    /**
     * Filter which GameRatings to update
     */
    where?: GameRatingWhereInput
    /**
     * Limit how many GameRatings to update.
     */
    limit?: number
  }

  /**
   * GameRating updateManyAndReturn
   */
  export type GameRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * The data used to update GameRatings.
     */
    data: XOR<GameRatingUpdateManyMutationInput, GameRatingUncheckedUpdateManyInput>
    /**
     * Filter which GameRatings to update
     */
    where?: GameRatingWhereInput
    /**
     * Limit how many GameRatings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameRating upsert
   */
  export type GameRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the GameRating to update in case it exists.
     */
    where: GameRatingWhereUniqueInput
    /**
     * In case the GameRating found by the `where` argument doesn't exist, create a new GameRating with this data.
     */
    create: XOR<GameRatingCreateInput, GameRatingUncheckedCreateInput>
    /**
     * In case the GameRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameRatingUpdateInput, GameRatingUncheckedUpdateInput>
  }

  /**
   * GameRating delete
   */
  export type GameRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingInclude<ExtArgs> | null
    /**
     * Filter which GameRating to delete.
     */
    where: GameRatingWhereUniqueInput
  }

  /**
   * GameRating deleteMany
   */
  export type GameRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameRatings to delete
     */
    where?: GameRatingWhereInput
    /**
     * Limit how many GameRatings to delete.
     */
    limit?: number
  }

  /**
   * GameRating without action
   */
  export type GameRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameRating
     */
    select?: GameRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameRating
     */
    omit?: GameRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameRatingInclude<ExtArgs> | null
  }


  /**
   * Model GameCategory
   */

  export type AggregateGameCategory = {
    _count: GameCategoryCountAggregateOutputType | null
    _min: GameCategoryMinAggregateOutputType | null
    _max: GameCategoryMaxAggregateOutputType | null
  }

  export type GameCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    iconUrl: string | null
    createdAt: Date | null
  }

  export type GameCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    iconUrl: string | null
    createdAt: Date | null
  }

  export type GameCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    iconUrl: number
    createdAt: number
    _all: number
  }


  export type GameCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    iconUrl?: true
    createdAt?: true
  }

  export type GameCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    iconUrl?: true
    createdAt?: true
  }

  export type GameCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    iconUrl?: true
    createdAt?: true
    _all?: true
  }

  export type GameCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameCategory to aggregate.
     */
    where?: GameCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameCategories to fetch.
     */
    orderBy?: GameCategoryOrderByWithRelationInput | GameCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameCategories
    **/
    _count?: true | GameCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameCategoryMaxAggregateInputType
  }

  export type GetGameCategoryAggregateType<T extends GameCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateGameCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameCategory[P]>
      : GetScalarType<T[P], AggregateGameCategory[P]>
  }




  export type GameCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameCategoryWhereInput
    orderBy?: GameCategoryOrderByWithAggregationInput | GameCategoryOrderByWithAggregationInput[]
    by: GameCategoryScalarFieldEnum[] | GameCategoryScalarFieldEnum
    having?: GameCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCategoryCountAggregateInputType | true
    _min?: GameCategoryMinAggregateInputType
    _max?: GameCategoryMaxAggregateInputType
  }

  export type GameCategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    iconUrl: string | null
    createdAt: Date
    _count: GameCategoryCountAggregateOutputType | null
    _min: GameCategoryMinAggregateOutputType | null
    _max: GameCategoryMaxAggregateOutputType | null
  }

  type GetGameCategoryGroupByPayload<T extends GameCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], GameCategoryGroupByOutputType[P]>
        }
      >
    >


  export type GameCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    iconUrl?: boolean
    createdAt?: boolean
    games?: boolean | GameCategory$gamesArgs<ExtArgs>
    _count?: boolean | GameCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameCategory"]>

  export type GameCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    iconUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["gameCategory"]>

  export type GameCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    iconUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["gameCategory"]>

  export type GameCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    iconUrl?: boolean
    createdAt?: boolean
  }

  export type GameCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "iconUrl" | "createdAt", ExtArgs["result"]["gameCategory"]>
  export type GameCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | GameCategory$gamesArgs<ExtArgs>
    _count?: boolean | GameCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GameCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GameCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameCategory"
    objects: {
      games: Prisma.$GamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      iconUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["gameCategory"]>
    composites: {}
  }

  type GameCategoryGetPayload<S extends boolean | null | undefined | GameCategoryDefaultArgs> = $Result.GetResult<Prisma.$GameCategoryPayload, S>

  type GameCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCategoryCountAggregateInputType | true
    }

  export interface GameCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameCategory'], meta: { name: 'GameCategory' } }
    /**
     * Find zero or one GameCategory that matches the filter.
     * @param {GameCategoryFindUniqueArgs} args - Arguments to find a GameCategory
     * @example
     * // Get one GameCategory
     * const gameCategory = await prisma.gameCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameCategoryFindUniqueArgs>(args: SelectSubset<T, GameCategoryFindUniqueArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameCategoryFindUniqueOrThrowArgs} args - Arguments to find a GameCategory
     * @example
     * // Get one GameCategory
     * const gameCategory = await prisma.gameCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, GameCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryFindFirstArgs} args - Arguments to find a GameCategory
     * @example
     * // Get one GameCategory
     * const gameCategory = await prisma.gameCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameCategoryFindFirstArgs>(args?: SelectSubset<T, GameCategoryFindFirstArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryFindFirstOrThrowArgs} args - Arguments to find a GameCategory
     * @example
     * // Get one GameCategory
     * const gameCategory = await prisma.gameCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, GameCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameCategories
     * const gameCategories = await prisma.gameCategory.findMany()
     * 
     * // Get first 10 GameCategories
     * const gameCategories = await prisma.gameCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameCategoryWithIdOnly = await prisma.gameCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameCategoryFindManyArgs>(args?: SelectSubset<T, GameCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameCategory.
     * @param {GameCategoryCreateArgs} args - Arguments to create a GameCategory.
     * @example
     * // Create one GameCategory
     * const GameCategory = await prisma.gameCategory.create({
     *   data: {
     *     // ... data to create a GameCategory
     *   }
     * })
     * 
     */
    create<T extends GameCategoryCreateArgs>(args: SelectSubset<T, GameCategoryCreateArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameCategories.
     * @param {GameCategoryCreateManyArgs} args - Arguments to create many GameCategories.
     * @example
     * // Create many GameCategories
     * const gameCategory = await prisma.gameCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCategoryCreateManyArgs>(args?: SelectSubset<T, GameCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameCategories and returns the data saved in the database.
     * @param {GameCategoryCreateManyAndReturnArgs} args - Arguments to create many GameCategories.
     * @example
     * // Create many GameCategories
     * const gameCategory = await prisma.gameCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameCategories and only return the `id`
     * const gameCategoryWithIdOnly = await prisma.gameCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameCategory.
     * @param {GameCategoryDeleteArgs} args - Arguments to delete one GameCategory.
     * @example
     * // Delete one GameCategory
     * const GameCategory = await prisma.gameCategory.delete({
     *   where: {
     *     // ... filter to delete one GameCategory
     *   }
     * })
     * 
     */
    delete<T extends GameCategoryDeleteArgs>(args: SelectSubset<T, GameCategoryDeleteArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameCategory.
     * @param {GameCategoryUpdateArgs} args - Arguments to update one GameCategory.
     * @example
     * // Update one GameCategory
     * const gameCategory = await prisma.gameCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameCategoryUpdateArgs>(args: SelectSubset<T, GameCategoryUpdateArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameCategories.
     * @param {GameCategoryDeleteManyArgs} args - Arguments to filter GameCategories to delete.
     * @example
     * // Delete a few GameCategories
     * const { count } = await prisma.gameCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameCategoryDeleteManyArgs>(args?: SelectSubset<T, GameCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameCategories
     * const gameCategory = await prisma.gameCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameCategoryUpdateManyArgs>(args: SelectSubset<T, GameCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameCategories and returns the data updated in the database.
     * @param {GameCategoryUpdateManyAndReturnArgs} args - Arguments to update many GameCategories.
     * @example
     * // Update many GameCategories
     * const gameCategory = await prisma.gameCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameCategories and only return the `id`
     * const gameCategoryWithIdOnly = await prisma.gameCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, GameCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameCategory.
     * @param {GameCategoryUpsertArgs} args - Arguments to update or create a GameCategory.
     * @example
     * // Update or create a GameCategory
     * const gameCategory = await prisma.gameCategory.upsert({
     *   create: {
     *     // ... data to create a GameCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameCategory we want to update
     *   }
     * })
     */
    upsert<T extends GameCategoryUpsertArgs>(args: SelectSubset<T, GameCategoryUpsertArgs<ExtArgs>>): Prisma__GameCategoryClient<$Result.GetResult<Prisma.$GameCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryCountArgs} args - Arguments to filter GameCategories to count.
     * @example
     * // Count the number of GameCategories
     * const count = await prisma.gameCategory.count({
     *   where: {
     *     // ... the filter for the GameCategories we want to count
     *   }
     * })
    **/
    count<T extends GameCategoryCountArgs>(
      args?: Subset<T, GameCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameCategoryAggregateArgs>(args: Subset<T, GameCategoryAggregateArgs>): Prisma.PrismaPromise<GetGameCategoryAggregateType<T>>

    /**
     * Group by GameCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameCategoryGroupByArgs['orderBy'] }
        : { orderBy?: GameCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameCategory model
   */
  readonly fields: GameCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends GameCategory$gamesArgs<ExtArgs> = {}>(args?: Subset<T, GameCategory$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameCategory model
   */
  interface GameCategoryFieldRefs {
    readonly id: FieldRef<"GameCategory", 'String'>
    readonly name: FieldRef<"GameCategory", 'String'>
    readonly slug: FieldRef<"GameCategory", 'String'>
    readonly iconUrl: FieldRef<"GameCategory", 'String'>
    readonly createdAt: FieldRef<"GameCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameCategory findUnique
   */
  export type GameCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GameCategory to fetch.
     */
    where: GameCategoryWhereUniqueInput
  }

  /**
   * GameCategory findUniqueOrThrow
   */
  export type GameCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GameCategory to fetch.
     */
    where: GameCategoryWhereUniqueInput
  }

  /**
   * GameCategory findFirst
   */
  export type GameCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GameCategory to fetch.
     */
    where?: GameCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameCategories to fetch.
     */
    orderBy?: GameCategoryOrderByWithRelationInput | GameCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameCategories.
     */
    cursor?: GameCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameCategories.
     */
    distinct?: GameCategoryScalarFieldEnum | GameCategoryScalarFieldEnum[]
  }

  /**
   * GameCategory findFirstOrThrow
   */
  export type GameCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GameCategory to fetch.
     */
    where?: GameCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameCategories to fetch.
     */
    orderBy?: GameCategoryOrderByWithRelationInput | GameCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameCategories.
     */
    cursor?: GameCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameCategories.
     */
    distinct?: GameCategoryScalarFieldEnum | GameCategoryScalarFieldEnum[]
  }

  /**
   * GameCategory findMany
   */
  export type GameCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GameCategories to fetch.
     */
    where?: GameCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameCategories to fetch.
     */
    orderBy?: GameCategoryOrderByWithRelationInput | GameCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameCategories.
     */
    cursor?: GameCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameCategories.
     */
    skip?: number
    distinct?: GameCategoryScalarFieldEnum | GameCategoryScalarFieldEnum[]
  }

  /**
   * GameCategory create
   */
  export type GameCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a GameCategory.
     */
    data: XOR<GameCategoryCreateInput, GameCategoryUncheckedCreateInput>
  }

  /**
   * GameCategory createMany
   */
  export type GameCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameCategories.
     */
    data: GameCategoryCreateManyInput | GameCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameCategory createManyAndReturn
   */
  export type GameCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many GameCategories.
     */
    data: GameCategoryCreateManyInput | GameCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameCategory update
   */
  export type GameCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a GameCategory.
     */
    data: XOR<GameCategoryUpdateInput, GameCategoryUncheckedUpdateInput>
    /**
     * Choose, which GameCategory to update.
     */
    where: GameCategoryWhereUniqueInput
  }

  /**
   * GameCategory updateMany
   */
  export type GameCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameCategories.
     */
    data: XOR<GameCategoryUpdateManyMutationInput, GameCategoryUncheckedUpdateManyInput>
    /**
     * Filter which GameCategories to update
     */
    where?: GameCategoryWhereInput
    /**
     * Limit how many GameCategories to update.
     */
    limit?: number
  }

  /**
   * GameCategory updateManyAndReturn
   */
  export type GameCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * The data used to update GameCategories.
     */
    data: XOR<GameCategoryUpdateManyMutationInput, GameCategoryUncheckedUpdateManyInput>
    /**
     * Filter which GameCategories to update
     */
    where?: GameCategoryWhereInput
    /**
     * Limit how many GameCategories to update.
     */
    limit?: number
  }

  /**
   * GameCategory upsert
   */
  export type GameCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the GameCategory to update in case it exists.
     */
    where: GameCategoryWhereUniqueInput
    /**
     * In case the GameCategory found by the `where` argument doesn't exist, create a new GameCategory with this data.
     */
    create: XOR<GameCategoryCreateInput, GameCategoryUncheckedCreateInput>
    /**
     * In case the GameCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameCategoryUpdateInput, GameCategoryUncheckedUpdateInput>
  }

  /**
   * GameCategory delete
   */
  export type GameCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
    /**
     * Filter which GameCategory to delete.
     */
    where: GameCategoryWhereUniqueInput
  }

  /**
   * GameCategory deleteMany
   */
  export type GameCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameCategories to delete
     */
    where?: GameCategoryWhereInput
    /**
     * Limit how many GameCategories to delete.
     */
    limit?: number
  }

  /**
   * GameCategory.games
   */
  export type GameCategory$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * GameCategory without action
   */
  export type GameCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCategory
     */
    select?: GameCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameCategory
     */
    omit?: GameCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCategoryInclude<ExtArgs> | null
  }


  /**
   * Model GameSession
   */

  export type AggregateGameSession = {
    _count: GameSessionCountAggregateOutputType | null
    _avg: GameSessionAvgAggregateOutputType | null
    _sum: GameSessionSumAggregateOutputType | null
    _min: GameSessionMinAggregateOutputType | null
    _max: GameSessionMaxAggregateOutputType | null
  }

  export type GameSessionAvgAggregateOutputType = {
    maxPlayers: number | null
    currentPlayers: number | null
  }

  export type GameSessionSumAggregateOutputType = {
    maxPlayers: number | null
    currentPlayers: number | null
  }

  export type GameSessionMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    hostId: string | null
    maxPlayers: number | null
    currentPlayers: number | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.GameSessionStatus | null
    createdAt: Date | null
  }

  export type GameSessionMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    hostId: string | null
    maxPlayers: number | null
    currentPlayers: number | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.GameSessionStatus | null
    createdAt: Date | null
  }

  export type GameSessionCountAggregateOutputType = {
    id: number
    gameId: number
    hostId: number
    participants: number
    viewerIds: number
    maxPlayers: number
    currentPlayers: number
    startTime: number
    endTime: number
    status: number
    createdAt: number
    _all: number
  }


  export type GameSessionAvgAggregateInputType = {
    maxPlayers?: true
    currentPlayers?: true
  }

  export type GameSessionSumAggregateInputType = {
    maxPlayers?: true
    currentPlayers?: true
  }

  export type GameSessionMinAggregateInputType = {
    id?: true
    gameId?: true
    hostId?: true
    maxPlayers?: true
    currentPlayers?: true
    startTime?: true
    endTime?: true
    status?: true
    createdAt?: true
  }

  export type GameSessionMaxAggregateInputType = {
    id?: true
    gameId?: true
    hostId?: true
    maxPlayers?: true
    currentPlayers?: true
    startTime?: true
    endTime?: true
    status?: true
    createdAt?: true
  }

  export type GameSessionCountAggregateInputType = {
    id?: true
    gameId?: true
    hostId?: true
    participants?: true
    viewerIds?: true
    maxPlayers?: true
    currentPlayers?: true
    startTime?: true
    endTime?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type GameSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameSession to aggregate.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameSessions
    **/
    _count?: true | GameSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameSessionMaxAggregateInputType
  }

  export type GetGameSessionAggregateType<T extends GameSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateGameSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameSession[P]>
      : GetScalarType<T[P], AggregateGameSession[P]>
  }




  export type GameSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithAggregationInput | GameSessionOrderByWithAggregationInput[]
    by: GameSessionScalarFieldEnum[] | GameSessionScalarFieldEnum
    having?: GameSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameSessionCountAggregateInputType | true
    _avg?: GameSessionAvgAggregateInputType
    _sum?: GameSessionSumAggregateInputType
    _min?: GameSessionMinAggregateInputType
    _max?: GameSessionMaxAggregateInputType
  }

  export type GameSessionGroupByOutputType = {
    id: string
    gameId: string
    hostId: string
    participants: JsonValue | null
    viewerIds: JsonValue | null
    maxPlayers: number
    currentPlayers: number
    startTime: Date | null
    endTime: Date | null
    status: $Enums.GameSessionStatus
    createdAt: Date
    _count: GameSessionCountAggregateOutputType | null
    _avg: GameSessionAvgAggregateOutputType | null
    _sum: GameSessionSumAggregateOutputType | null
    _min: GameSessionMinAggregateOutputType | null
    _max: GameSessionMaxAggregateOutputType | null
  }

  type GetGameSessionGroupByPayload<T extends GameSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameSessionGroupByOutputType[P]>
            : GetScalarType<T[P], GameSessionGroupByOutputType[P]>
        }
      >
    >


  export type GameSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    hostId?: boolean
    participants?: boolean
    viewerIds?: boolean
    maxPlayers?: boolean
    currentPlayers?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    createdAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    host?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameSession"]>

  export type GameSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    hostId?: boolean
    participants?: boolean
    viewerIds?: boolean
    maxPlayers?: boolean
    currentPlayers?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    createdAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    host?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameSession"]>

  export type GameSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    hostId?: boolean
    participants?: boolean
    viewerIds?: boolean
    maxPlayers?: boolean
    currentPlayers?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    createdAt?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    host?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameSession"]>

  export type GameSessionSelectScalar = {
    id?: boolean
    gameId?: boolean
    hostId?: boolean
    participants?: boolean
    viewerIds?: boolean
    maxPlayers?: boolean
    currentPlayers?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type GameSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "hostId" | "participants" | "viewerIds" | "maxPlayers" | "currentPlayers" | "startTime" | "endTime" | "status" | "createdAt", ExtArgs["result"]["gameSession"]>
  export type GameSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    host?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GameSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    host?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GameSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    host?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GameSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameSession"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      host: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      hostId: string
      participants: Prisma.JsonValue | null
      viewerIds: Prisma.JsonValue | null
      maxPlayers: number
      currentPlayers: number
      startTime: Date | null
      endTime: Date | null
      status: $Enums.GameSessionStatus
      createdAt: Date
    }, ExtArgs["result"]["gameSession"]>
    composites: {}
  }

  type GameSessionGetPayload<S extends boolean | null | undefined | GameSessionDefaultArgs> = $Result.GetResult<Prisma.$GameSessionPayload, S>

  type GameSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameSessionCountAggregateInputType | true
    }

  export interface GameSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameSession'], meta: { name: 'GameSession' } }
    /**
     * Find zero or one GameSession that matches the filter.
     * @param {GameSessionFindUniqueArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameSessionFindUniqueArgs>(args: SelectSubset<T, GameSessionFindUniqueArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameSessionFindUniqueOrThrowArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, GameSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindFirstArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameSessionFindFirstArgs>(args?: SelectSubset<T, GameSessionFindFirstArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindFirstOrThrowArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, GameSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameSessions
     * const gameSessions = await prisma.gameSession.findMany()
     * 
     * // Get first 10 GameSessions
     * const gameSessions = await prisma.gameSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameSessionWithIdOnly = await prisma.gameSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameSessionFindManyArgs>(args?: SelectSubset<T, GameSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameSession.
     * @param {GameSessionCreateArgs} args - Arguments to create a GameSession.
     * @example
     * // Create one GameSession
     * const GameSession = await prisma.gameSession.create({
     *   data: {
     *     // ... data to create a GameSession
     *   }
     * })
     * 
     */
    create<T extends GameSessionCreateArgs>(args: SelectSubset<T, GameSessionCreateArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameSessions.
     * @param {GameSessionCreateManyArgs} args - Arguments to create many GameSessions.
     * @example
     * // Create many GameSessions
     * const gameSession = await prisma.gameSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameSessionCreateManyArgs>(args?: SelectSubset<T, GameSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameSessions and returns the data saved in the database.
     * @param {GameSessionCreateManyAndReturnArgs} args - Arguments to create many GameSessions.
     * @example
     * // Create many GameSessions
     * const gameSession = await prisma.gameSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameSessions and only return the `id`
     * const gameSessionWithIdOnly = await prisma.gameSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, GameSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameSession.
     * @param {GameSessionDeleteArgs} args - Arguments to delete one GameSession.
     * @example
     * // Delete one GameSession
     * const GameSession = await prisma.gameSession.delete({
     *   where: {
     *     // ... filter to delete one GameSession
     *   }
     * })
     * 
     */
    delete<T extends GameSessionDeleteArgs>(args: SelectSubset<T, GameSessionDeleteArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameSession.
     * @param {GameSessionUpdateArgs} args - Arguments to update one GameSession.
     * @example
     * // Update one GameSession
     * const gameSession = await prisma.gameSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameSessionUpdateArgs>(args: SelectSubset<T, GameSessionUpdateArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameSessions.
     * @param {GameSessionDeleteManyArgs} args - Arguments to filter GameSessions to delete.
     * @example
     * // Delete a few GameSessions
     * const { count } = await prisma.gameSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameSessionDeleteManyArgs>(args?: SelectSubset<T, GameSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameSessions
     * const gameSession = await prisma.gameSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameSessionUpdateManyArgs>(args: SelectSubset<T, GameSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameSessions and returns the data updated in the database.
     * @param {GameSessionUpdateManyAndReturnArgs} args - Arguments to update many GameSessions.
     * @example
     * // Update many GameSessions
     * const gameSession = await prisma.gameSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameSessions and only return the `id`
     * const gameSessionWithIdOnly = await prisma.gameSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, GameSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameSession.
     * @param {GameSessionUpsertArgs} args - Arguments to update or create a GameSession.
     * @example
     * // Update or create a GameSession
     * const gameSession = await prisma.gameSession.upsert({
     *   create: {
     *     // ... data to create a GameSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameSession we want to update
     *   }
     * })
     */
    upsert<T extends GameSessionUpsertArgs>(args: SelectSubset<T, GameSessionUpsertArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionCountArgs} args - Arguments to filter GameSessions to count.
     * @example
     * // Count the number of GameSessions
     * const count = await prisma.gameSession.count({
     *   where: {
     *     // ... the filter for the GameSessions we want to count
     *   }
     * })
    **/
    count<T extends GameSessionCountArgs>(
      args?: Subset<T, GameSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameSessionAggregateArgs>(args: Subset<T, GameSessionAggregateArgs>): Prisma.PrismaPromise<GetGameSessionAggregateType<T>>

    /**
     * Group by GameSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameSessionGroupByArgs['orderBy'] }
        : { orderBy?: GameSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameSession model
   */
  readonly fields: GameSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    host<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameSession model
   */
  interface GameSessionFieldRefs {
    readonly id: FieldRef<"GameSession", 'String'>
    readonly gameId: FieldRef<"GameSession", 'String'>
    readonly hostId: FieldRef<"GameSession", 'String'>
    readonly participants: FieldRef<"GameSession", 'Json'>
    readonly viewerIds: FieldRef<"GameSession", 'Json'>
    readonly maxPlayers: FieldRef<"GameSession", 'Int'>
    readonly currentPlayers: FieldRef<"GameSession", 'Int'>
    readonly startTime: FieldRef<"GameSession", 'DateTime'>
    readonly endTime: FieldRef<"GameSession", 'DateTime'>
    readonly status: FieldRef<"GameSession", 'GameSessionStatus'>
    readonly createdAt: FieldRef<"GameSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameSession findUnique
   */
  export type GameSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession findUniqueOrThrow
   */
  export type GameSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession findFirst
   */
  export type GameSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameSessions.
     */
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession findFirstOrThrow
   */
  export type GameSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameSessions.
     */
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession findMany
   */
  export type GameSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSessions to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession create
   */
  export type GameSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a GameSession.
     */
    data: XOR<GameSessionCreateInput, GameSessionUncheckedCreateInput>
  }

  /**
   * GameSession createMany
   */
  export type GameSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameSessions.
     */
    data: GameSessionCreateManyInput | GameSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameSession createManyAndReturn
   */
  export type GameSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * The data used to create many GameSessions.
     */
    data: GameSessionCreateManyInput | GameSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameSession update
   */
  export type GameSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a GameSession.
     */
    data: XOR<GameSessionUpdateInput, GameSessionUncheckedUpdateInput>
    /**
     * Choose, which GameSession to update.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession updateMany
   */
  export type GameSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameSessions.
     */
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyInput>
    /**
     * Filter which GameSessions to update
     */
    where?: GameSessionWhereInput
    /**
     * Limit how many GameSessions to update.
     */
    limit?: number
  }

  /**
   * GameSession updateManyAndReturn
   */
  export type GameSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * The data used to update GameSessions.
     */
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyInput>
    /**
     * Filter which GameSessions to update
     */
    where?: GameSessionWhereInput
    /**
     * Limit how many GameSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameSession upsert
   */
  export type GameSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the GameSession to update in case it exists.
     */
    where: GameSessionWhereUniqueInput
    /**
     * In case the GameSession found by the `where` argument doesn't exist, create a new GameSession with this data.
     */
    create: XOR<GameSessionCreateInput, GameSessionUncheckedCreateInput>
    /**
     * In case the GameSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameSessionUpdateInput, GameSessionUncheckedUpdateInput>
  }

  /**
   * GameSession delete
   */
  export type GameSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter which GameSession to delete.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession deleteMany
   */
  export type GameSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameSessions to delete
     */
    where?: GameSessionWhereInput
    /**
     * Limit how many GameSessions to delete.
     */
    limit?: number
  }

  /**
   * GameSession without action
   */
  export type GameSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameSession
     */
    omit?: GameSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
  }


  /**
   * Model Gift
   */

  export type AggregateGift = {
    _count: GiftCountAggregateOutputType | null
    _avg: GiftAvgAggregateOutputType | null
    _sum: GiftSumAggregateOutputType | null
    _min: GiftMinAggregateOutputType | null
    _max: GiftMaxAggregateOutputType | null
  }

  export type GiftAvgAggregateOutputType = {
    cost: number | null
    value: number | null
  }

  export type GiftSumAggregateOutputType = {
    cost: bigint | null
    value: bigint | null
  }

  export type GiftMinAggregateOutputType = {
    id: string | null
    giftId: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    animationUrl: string | null
    cost: bigint | null
    value: bigint | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type GiftMaxAggregateOutputType = {
    id: string | null
    giftId: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    animationUrl: string | null
    cost: bigint | null
    value: bigint | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type GiftCountAggregateOutputType = {
    id: number
    giftId: number
    name: number
    description: number
    imageUrl: number
    animationUrl: number
    cost: number
    value: number
    category: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type GiftAvgAggregateInputType = {
    cost?: true
    value?: true
  }

  export type GiftSumAggregateInputType = {
    cost?: true
    value?: true
  }

  export type GiftMinAggregateInputType = {
    id?: true
    giftId?: true
    name?: true
    description?: true
    imageUrl?: true
    animationUrl?: true
    cost?: true
    value?: true
    category?: true
    isActive?: true
    createdAt?: true
  }

  export type GiftMaxAggregateInputType = {
    id?: true
    giftId?: true
    name?: true
    description?: true
    imageUrl?: true
    animationUrl?: true
    cost?: true
    value?: true
    category?: true
    isActive?: true
    createdAt?: true
  }

  export type GiftCountAggregateInputType = {
    id?: true
    giftId?: true
    name?: true
    description?: true
    imageUrl?: true
    animationUrl?: true
    cost?: true
    value?: true
    category?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type GiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gift to aggregate.
     */
    where?: GiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gifts to fetch.
     */
    orderBy?: GiftOrderByWithRelationInput | GiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gifts
    **/
    _count?: true | GiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GiftMaxAggregateInputType
  }

  export type GetGiftAggregateType<T extends GiftAggregateArgs> = {
        [P in keyof T & keyof AggregateGift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGift[P]>
      : GetScalarType<T[P], AggregateGift[P]>
  }




  export type GiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiftWhereInput
    orderBy?: GiftOrderByWithAggregationInput | GiftOrderByWithAggregationInput[]
    by: GiftScalarFieldEnum[] | GiftScalarFieldEnum
    having?: GiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GiftCountAggregateInputType | true
    _avg?: GiftAvgAggregateInputType
    _sum?: GiftSumAggregateInputType
    _min?: GiftMinAggregateInputType
    _max?: GiftMaxAggregateInputType
  }

  export type GiftGroupByOutputType = {
    id: string
    giftId: string
    name: string
    description: string | null
    imageUrl: string
    animationUrl: string | null
    cost: bigint
    value: bigint
    category: string | null
    isActive: boolean
    createdAt: Date
    _count: GiftCountAggregateOutputType | null
    _avg: GiftAvgAggregateOutputType | null
    _sum: GiftSumAggregateOutputType | null
    _min: GiftMinAggregateOutputType | null
    _max: GiftMaxAggregateOutputType | null
  }

  type GetGiftGroupByPayload<T extends GiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GiftGroupByOutputType[P]>
            : GetScalarType<T[P], GiftGroupByOutputType[P]>
        }
      >
    >


  export type GiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    giftId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    animationUrl?: boolean
    cost?: boolean
    value?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    messages?: boolean | Gift$messagesArgs<ExtArgs>
    _count?: boolean | GiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gift"]>

  export type GiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    giftId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    animationUrl?: boolean
    cost?: boolean
    value?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["gift"]>

  export type GiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    giftId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    animationUrl?: boolean
    cost?: boolean
    value?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["gift"]>

  export type GiftSelectScalar = {
    id?: boolean
    giftId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    animationUrl?: boolean
    cost?: boolean
    value?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type GiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "giftId" | "name" | "description" | "imageUrl" | "animationUrl" | "cost" | "value" | "category" | "isActive" | "createdAt", ExtArgs["result"]["gift"]>
  export type GiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Gift$messagesArgs<ExtArgs>
    _count?: boolean | GiftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gift"
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      giftId: string
      name: string
      description: string | null
      imageUrl: string
      animationUrl: string | null
      cost: bigint
      value: bigint
      category: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["gift"]>
    composites: {}
  }

  type GiftGetPayload<S extends boolean | null | undefined | GiftDefaultArgs> = $Result.GetResult<Prisma.$GiftPayload, S>

  type GiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GiftCountAggregateInputType | true
    }

  export interface GiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gift'], meta: { name: 'Gift' } }
    /**
     * Find zero or one Gift that matches the filter.
     * @param {GiftFindUniqueArgs} args - Arguments to find a Gift
     * @example
     * // Get one Gift
     * const gift = await prisma.gift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GiftFindUniqueArgs>(args: SelectSubset<T, GiftFindUniqueArgs<ExtArgs>>): Prisma__GiftClient<$Result.GetResult<Prisma.$GiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GiftFindUniqueOrThrowArgs} args - Arguments to find a Gift
     * @example
     * // Get one Gift
     * const gift = await prisma.gift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GiftFindUniqueOrThrowArgs>(args: SelectSubset<T, GiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GiftClient<$Result.GetResult<Prisma.$GiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftFindFirstArgs} args - Arguments to find a Gift
     * @example
     * // Get one Gift
     * const gift = await prisma.gift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GiftFindFirstArgs>(args?: SelectSubset<T, GiftFindFirstArgs<ExtArgs>>): Prisma__GiftClient<$Result.GetResult<Prisma.$GiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftFindFirstOrThrowArgs} args - Arguments to find a Gift
     * @example
     * // Get one Gift
     * const gift = await prisma.gift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GiftFindFirstOrThrowArgs>(args?: SelectSubset<T, GiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__GiftClient<$Result.GetResult<Prisma.$GiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gifts
     * const gifts = await prisma.gift.findMany()
     * 
     * // Get first 10 Gifts
     * const gifts = await prisma.gift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const giftWithIdOnly = await prisma.gift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GiftFindManyArgs>(args?: SelectSubset<T, GiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gift.
     * @param {GiftCreateArgs} args - Arguments to create a Gift.
     * @example
     * // Create one Gift
     * const Gift = await prisma.gift.create({
     *   data: {
     *     // ... data to create a Gift
     *   }
     * })
     * 
     */
    create<T extends GiftCreateArgs>(args: SelectSubset<T, GiftCreateArgs<ExtArgs>>): Prisma__GiftClient<$Result.GetResult<Prisma.$GiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gifts.
     * @param {GiftCreateManyArgs} args - Arguments to create many Gifts.
     * @example
     * // Create many Gifts
     * const gift = await prisma.gift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GiftCreateManyArgs>(args?: SelectSubset<T, GiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gifts and returns the data saved in the database.
     * @param {GiftCreateManyAndReturnArgs} args - Arguments to create many Gifts.
     * @example
     * // Create many Gifts
     * const gift = await prisma.gift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gifts and only return the `id`
     * const giftWithIdOnly = await prisma.gift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GiftCreateManyAndReturnArgs>(args?: SelectSubset<T, GiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gift.
     * @param {GiftDeleteArgs} args - Arguments to delete one Gift.
     * @example
     * // Delete one Gift
     * const Gift = await prisma.gift.delete({
     *   where: {
     *     // ... filter to delete one Gift
     *   }
     * })
     * 
     */
    delete<T extends GiftDeleteArgs>(args: SelectSubset<T, GiftDeleteArgs<ExtArgs>>): Prisma__GiftClient<$Result.GetResult<Prisma.$GiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gift.
     * @param {GiftUpdateArgs} args - Arguments to update one Gift.
     * @example
     * // Update one Gift
     * const gift = await prisma.gift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GiftUpdateArgs>(args: SelectSubset<T, GiftUpdateArgs<ExtArgs>>): Prisma__GiftClient<$Result.GetResult<Prisma.$GiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gifts.
     * @param {GiftDeleteManyArgs} args - Arguments to filter Gifts to delete.
     * @example
     * // Delete a few Gifts
     * const { count } = await prisma.gift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GiftDeleteManyArgs>(args?: SelectSubset<T, GiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gifts
     * const gift = await prisma.gift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GiftUpdateManyArgs>(args: SelectSubset<T, GiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gifts and returns the data updated in the database.
     * @param {GiftUpdateManyAndReturnArgs} args - Arguments to update many Gifts.
     * @example
     * // Update many Gifts
     * const gift = await prisma.gift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gifts and only return the `id`
     * const giftWithIdOnly = await prisma.gift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GiftUpdateManyAndReturnArgs>(args: SelectSubset<T, GiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gift.
     * @param {GiftUpsertArgs} args - Arguments to update or create a Gift.
     * @example
     * // Update or create a Gift
     * const gift = await prisma.gift.upsert({
     *   create: {
     *     // ... data to create a Gift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gift we want to update
     *   }
     * })
     */
    upsert<T extends GiftUpsertArgs>(args: SelectSubset<T, GiftUpsertArgs<ExtArgs>>): Prisma__GiftClient<$Result.GetResult<Prisma.$GiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCountArgs} args - Arguments to filter Gifts to count.
     * @example
     * // Count the number of Gifts
     * const count = await prisma.gift.count({
     *   where: {
     *     // ... the filter for the Gifts we want to count
     *   }
     * })
    **/
    count<T extends GiftCountArgs>(
      args?: Subset<T, GiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GiftAggregateArgs>(args: Subset<T, GiftAggregateArgs>): Prisma.PrismaPromise<GetGiftAggregateType<T>>

    /**
     * Group by Gift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GiftGroupByArgs['orderBy'] }
        : { orderBy?: GiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gift model
   */
  readonly fields: GiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends Gift$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Gift$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gift model
   */
  interface GiftFieldRefs {
    readonly id: FieldRef<"Gift", 'String'>
    readonly giftId: FieldRef<"Gift", 'String'>
    readonly name: FieldRef<"Gift", 'String'>
    readonly description: FieldRef<"Gift", 'String'>
    readonly imageUrl: FieldRef<"Gift", 'String'>
    readonly animationUrl: FieldRef<"Gift", 'String'>
    readonly cost: FieldRef<"Gift", 'BigInt'>
    readonly value: FieldRef<"Gift", 'BigInt'>
    readonly category: FieldRef<"Gift", 'String'>
    readonly isActive: FieldRef<"Gift", 'Boolean'>
    readonly createdAt: FieldRef<"Gift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Gift findUnique
   */
  export type GiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftInclude<ExtArgs> | null
    /**
     * Filter, which Gift to fetch.
     */
    where: GiftWhereUniqueInput
  }

  /**
   * Gift findUniqueOrThrow
   */
  export type GiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftInclude<ExtArgs> | null
    /**
     * Filter, which Gift to fetch.
     */
    where: GiftWhereUniqueInput
  }

  /**
   * Gift findFirst
   */
  export type GiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftInclude<ExtArgs> | null
    /**
     * Filter, which Gift to fetch.
     */
    where?: GiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gifts to fetch.
     */
    orderBy?: GiftOrderByWithRelationInput | GiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gifts.
     */
    cursor?: GiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gifts.
     */
    distinct?: GiftScalarFieldEnum | GiftScalarFieldEnum[]
  }

  /**
   * Gift findFirstOrThrow
   */
  export type GiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftInclude<ExtArgs> | null
    /**
     * Filter, which Gift to fetch.
     */
    where?: GiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gifts to fetch.
     */
    orderBy?: GiftOrderByWithRelationInput | GiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gifts.
     */
    cursor?: GiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gifts.
     */
    distinct?: GiftScalarFieldEnum | GiftScalarFieldEnum[]
  }

  /**
   * Gift findMany
   */
  export type GiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftInclude<ExtArgs> | null
    /**
     * Filter, which Gifts to fetch.
     */
    where?: GiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gifts to fetch.
     */
    orderBy?: GiftOrderByWithRelationInput | GiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gifts.
     */
    cursor?: GiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gifts.
     */
    skip?: number
    distinct?: GiftScalarFieldEnum | GiftScalarFieldEnum[]
  }

  /**
   * Gift create
   */
  export type GiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Gift.
     */
    data: XOR<GiftCreateInput, GiftUncheckedCreateInput>
  }

  /**
   * Gift createMany
   */
  export type GiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gifts.
     */
    data: GiftCreateManyInput | GiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gift createManyAndReturn
   */
  export type GiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * The data used to create many Gifts.
     */
    data: GiftCreateManyInput | GiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gift update
   */
  export type GiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Gift.
     */
    data: XOR<GiftUpdateInput, GiftUncheckedUpdateInput>
    /**
     * Choose, which Gift to update.
     */
    where: GiftWhereUniqueInput
  }

  /**
   * Gift updateMany
   */
  export type GiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gifts.
     */
    data: XOR<GiftUpdateManyMutationInput, GiftUncheckedUpdateManyInput>
    /**
     * Filter which Gifts to update
     */
    where?: GiftWhereInput
    /**
     * Limit how many Gifts to update.
     */
    limit?: number
  }

  /**
   * Gift updateManyAndReturn
   */
  export type GiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * The data used to update Gifts.
     */
    data: XOR<GiftUpdateManyMutationInput, GiftUncheckedUpdateManyInput>
    /**
     * Filter which Gifts to update
     */
    where?: GiftWhereInput
    /**
     * Limit how many Gifts to update.
     */
    limit?: number
  }

  /**
   * Gift upsert
   */
  export type GiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Gift to update in case it exists.
     */
    where: GiftWhereUniqueInput
    /**
     * In case the Gift found by the `where` argument doesn't exist, create a new Gift with this data.
     */
    create: XOR<GiftCreateInput, GiftUncheckedCreateInput>
    /**
     * In case the Gift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GiftUpdateInput, GiftUncheckedUpdateInput>
  }

  /**
   * Gift delete
   */
  export type GiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftInclude<ExtArgs> | null
    /**
     * Filter which Gift to delete.
     */
    where: GiftWhereUniqueInput
  }

  /**
   * Gift deleteMany
   */
  export type GiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gifts to delete
     */
    where?: GiftWhereInput
    /**
     * Limit how many Gifts to delete.
     */
    limit?: number
  }

  /**
   * Gift.messages
   */
  export type Gift$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Gift without action
   */
  export type GiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gift
     */
    select?: GiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gift
     */
    omit?: GiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    reporterId: string | null
    reportedUserId: string | null
    reportedStreamId: string | null
    reportedRoomId: string | null
    reportedMessageId: string | null
    reason: string | null
    description: string | null
    status: $Enums.ReportStatus | null
    reviewedById: string | null
    reviewTimestamp: Date | null
    createdAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    reporterId: string | null
    reportedUserId: string | null
    reportedStreamId: string | null
    reportedRoomId: string | null
    reportedMessageId: string | null
    reason: string | null
    description: string | null
    status: $Enums.ReportStatus | null
    reviewedById: string | null
    reviewTimestamp: Date | null
    createdAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    reporterId: number
    reportedUserId: number
    reportedStreamId: number
    reportedRoomId: number
    reportedMessageId: number
    reason: number
    description: number
    status: number
    reviewedById: number
    reviewTimestamp: number
    createdAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    reporterId?: true
    reportedUserId?: true
    reportedStreamId?: true
    reportedRoomId?: true
    reportedMessageId?: true
    reason?: true
    description?: true
    status?: true
    reviewedById?: true
    reviewTimestamp?: true
    createdAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    reporterId?: true
    reportedUserId?: true
    reportedStreamId?: true
    reportedRoomId?: true
    reportedMessageId?: true
    reason?: true
    description?: true
    status?: true
    reviewedById?: true
    reviewTimestamp?: true
    createdAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    reporterId?: true
    reportedUserId?: true
    reportedStreamId?: true
    reportedRoomId?: true
    reportedMessageId?: true
    reason?: true
    description?: true
    status?: true
    reviewedById?: true
    reviewTimestamp?: true
    createdAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    reporterId: string
    reportedUserId: string | null
    reportedStreamId: string | null
    reportedRoomId: string | null
    reportedMessageId: string | null
    reason: string
    description: string | null
    status: $Enums.ReportStatus
    reviewedById: string | null
    reviewTimestamp: Date | null
    createdAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    reportedStreamId?: boolean
    reportedRoomId?: boolean
    reportedMessageId?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    reviewedById?: boolean
    reviewTimestamp?: boolean
    createdAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    reportedUser?: boolean | Report$reportedUserArgs<ExtArgs>
    reportedStream?: boolean | Report$reportedStreamArgs<ExtArgs>
    reportedRoom?: boolean | Report$reportedRoomArgs<ExtArgs>
    reportedMessage?: boolean | Report$reportedMessageArgs<ExtArgs>
    reviewer?: boolean | Report$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    reportedStreamId?: boolean
    reportedRoomId?: boolean
    reportedMessageId?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    reviewedById?: boolean
    reviewTimestamp?: boolean
    createdAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    reportedUser?: boolean | Report$reportedUserArgs<ExtArgs>
    reportedStream?: boolean | Report$reportedStreamArgs<ExtArgs>
    reportedRoom?: boolean | Report$reportedRoomArgs<ExtArgs>
    reportedMessage?: boolean | Report$reportedMessageArgs<ExtArgs>
    reviewer?: boolean | Report$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    reportedStreamId?: boolean
    reportedRoomId?: boolean
    reportedMessageId?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    reviewedById?: boolean
    reviewTimestamp?: boolean
    createdAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    reportedUser?: boolean | Report$reportedUserArgs<ExtArgs>
    reportedStream?: boolean | Report$reportedStreamArgs<ExtArgs>
    reportedRoom?: boolean | Report$reportedRoomArgs<ExtArgs>
    reportedMessage?: boolean | Report$reportedMessageArgs<ExtArgs>
    reviewer?: boolean | Report$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    reportedStreamId?: boolean
    reportedRoomId?: boolean
    reportedMessageId?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    reviewedById?: boolean
    reviewTimestamp?: boolean
    createdAt?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reporterId" | "reportedUserId" | "reportedStreamId" | "reportedRoomId" | "reportedMessageId" | "reason" | "description" | "status" | "reviewedById" | "reviewTimestamp" | "createdAt", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    reportedUser?: boolean | Report$reportedUserArgs<ExtArgs>
    reportedStream?: boolean | Report$reportedStreamArgs<ExtArgs>
    reportedRoom?: boolean | Report$reportedRoomArgs<ExtArgs>
    reportedMessage?: boolean | Report$reportedMessageArgs<ExtArgs>
    reviewer?: boolean | Report$reviewerArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    reportedUser?: boolean | Report$reportedUserArgs<ExtArgs>
    reportedStream?: boolean | Report$reportedStreamArgs<ExtArgs>
    reportedRoom?: boolean | Report$reportedRoomArgs<ExtArgs>
    reportedMessage?: boolean | Report$reportedMessageArgs<ExtArgs>
    reviewer?: boolean | Report$reviewerArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    reportedUser?: boolean | Report$reportedUserArgs<ExtArgs>
    reportedStream?: boolean | Report$reportedStreamArgs<ExtArgs>
    reportedRoom?: boolean | Report$reportedRoomArgs<ExtArgs>
    reportedMessage?: boolean | Report$reportedMessageArgs<ExtArgs>
    reviewer?: boolean | Report$reviewerArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      reporter: Prisma.$UserPayload<ExtArgs>
      reportedUser: Prisma.$UserPayload<ExtArgs> | null
      reportedStream: Prisma.$StreamPayload<ExtArgs> | null
      reportedRoom: Prisma.$ChatRoomPayload<ExtArgs> | null
      reportedMessage: Prisma.$MessagePayload<ExtArgs> | null
      reviewer: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reporterId: string
      reportedUserId: string | null
      reportedStreamId: string | null
      reportedRoomId: string | null
      reportedMessageId: string | null
      reason: string
      description: string | null
      status: $Enums.ReportStatus
      reviewedById: string | null
      reviewTimestamp: Date | null
      createdAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reporter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportedUser<T extends Report$reportedUserArgs<ExtArgs> = {}>(args?: Subset<T, Report$reportedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reportedStream<T extends Report$reportedStreamArgs<ExtArgs> = {}>(args?: Subset<T, Report$reportedStreamArgs<ExtArgs>>): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reportedRoom<T extends Report$reportedRoomArgs<ExtArgs> = {}>(args?: Subset<T, Report$reportedRoomArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reportedMessage<T extends Report$reportedMessageArgs<ExtArgs> = {}>(args?: Subset<T, Report$reportedMessageArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends Report$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, Report$reviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly reporterId: FieldRef<"Report", 'String'>
    readonly reportedUserId: FieldRef<"Report", 'String'>
    readonly reportedStreamId: FieldRef<"Report", 'String'>
    readonly reportedRoomId: FieldRef<"Report", 'String'>
    readonly reportedMessageId: FieldRef<"Report", 'String'>
    readonly reason: FieldRef<"Report", 'String'>
    readonly description: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly reviewedById: FieldRef<"Report", 'String'>
    readonly reviewTimestamp: FieldRef<"Report", 'DateTime'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report.reportedUser
   */
  export type Report$reportedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Report.reportedStream
   */
  export type Report$reportedStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    where?: StreamWhereInput
  }

  /**
   * Report.reportedRoom
   */
  export type Report$reportedRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    where?: ChatRoomWhereInput
  }

  /**
   * Report.reportedMessage
   */
  export type Report$reportedMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Report.reviewer
   */
  export type Report$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    recipientId: string | null
    senderId: string | null
    type: $Enums.NotificationType | null
    relatedEntityId: string | null
    relatedEntityType: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    recipientId: string | null
    senderId: string | null
    type: $Enums.NotificationType | null
    relatedEntityId: string | null
    relatedEntityType: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    recipientId: number
    senderId: number
    type: number
    relatedEntityId: number
    relatedEntityType: number
    content: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    recipientId?: true
    senderId?: true
    type?: true
    relatedEntityId?: true
    relatedEntityType?: true
    content?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    recipientId?: true
    senderId?: true
    type?: true
    relatedEntityId?: true
    relatedEntityType?: true
    content?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    recipientId?: true
    senderId?: true
    type?: true
    relatedEntityId?: true
    relatedEntityType?: true
    content?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    recipientId: string
    senderId: string | null
    type: $Enums.NotificationType
    relatedEntityId: string | null
    relatedEntityType: string | null
    content: string | null
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    senderId?: boolean
    type?: boolean
    relatedEntityId?: boolean
    relatedEntityType?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    senderId?: boolean
    type?: boolean
    relatedEntityId?: boolean
    relatedEntityType?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    senderId?: boolean
    type?: boolean
    relatedEntityId?: boolean
    relatedEntityType?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    recipientId?: boolean
    senderId?: boolean
    type?: boolean
    relatedEntityId?: boolean
    relatedEntityType?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipientId" | "senderId" | "type" | "relatedEntityId" | "relatedEntityType" | "content" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      recipient: Prisma.$UserPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipientId: string
      senderId: string | null
      type: $Enums.NotificationType
      relatedEntityId: string | null
      relatedEntityType: string | null
      content: string | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends Notification$senderArgs<ExtArgs> = {}>(args?: Subset<T, Notification$senderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly senderId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly relatedEntityId: FieldRef<"Notification", 'String'>
    readonly relatedEntityType: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.sender
   */
  export type Notification$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Stream
   */

  export type AggregateStream = {
    _count: StreamCountAggregateOutputType | null
    _avg: StreamAvgAggregateOutputType | null
    _sum: StreamSumAggregateOutputType | null
    _min: StreamMinAggregateOutputType | null
    _max: StreamMaxAggregateOutputType | null
  }

  export type StreamAvgAggregateOutputType = {
    currentViewers: number | null
    peakViewers: number | null
    totalDiamondsReceived: number | null
  }

  export type StreamSumAggregateOutputType = {
    currentViewers: number | null
    peakViewers: number | null
    totalDiamondsReceived: bigint | null
  }

  export type StreamMinAggregateOutputType = {
    id: string | null
    broadcasterId: string | null
    title: string | null
    coverImageUrl: string | null
    status: $Enums.StreamStatus | null
    startTime: Date | null
    endTime: Date | null
    currentViewers: number | null
    peakViewers: number | null
    totalDiamondsReceived: bigint | null
    rtcChannelName: string | null
    recordingUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StreamMaxAggregateOutputType = {
    id: string | null
    broadcasterId: string | null
    title: string | null
    coverImageUrl: string | null
    status: $Enums.StreamStatus | null
    startTime: Date | null
    endTime: Date | null
    currentViewers: number | null
    peakViewers: number | null
    totalDiamondsReceived: bigint | null
    rtcChannelName: string | null
    recordingUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StreamCountAggregateOutputType = {
    id: number
    broadcasterId: number
    title: number
    coverImageUrl: number
    status: number
    startTime: number
    endTime: number
    currentViewers: number
    peakViewers: number
    totalDiamondsReceived: number
    tags: number
    location: number
    rtcChannelName: number
    recordingUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StreamAvgAggregateInputType = {
    currentViewers?: true
    peakViewers?: true
    totalDiamondsReceived?: true
  }

  export type StreamSumAggregateInputType = {
    currentViewers?: true
    peakViewers?: true
    totalDiamondsReceived?: true
  }

  export type StreamMinAggregateInputType = {
    id?: true
    broadcasterId?: true
    title?: true
    coverImageUrl?: true
    status?: true
    startTime?: true
    endTime?: true
    currentViewers?: true
    peakViewers?: true
    totalDiamondsReceived?: true
    rtcChannelName?: true
    recordingUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StreamMaxAggregateInputType = {
    id?: true
    broadcasterId?: true
    title?: true
    coverImageUrl?: true
    status?: true
    startTime?: true
    endTime?: true
    currentViewers?: true
    peakViewers?: true
    totalDiamondsReceived?: true
    rtcChannelName?: true
    recordingUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StreamCountAggregateInputType = {
    id?: true
    broadcasterId?: true
    title?: true
    coverImageUrl?: true
    status?: true
    startTime?: true
    endTime?: true
    currentViewers?: true
    peakViewers?: true
    totalDiamondsReceived?: true
    tags?: true
    location?: true
    rtcChannelName?: true
    recordingUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StreamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stream to aggregate.
     */
    where?: StreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streams to fetch.
     */
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Streams
    **/
    _count?: true | StreamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StreamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StreamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StreamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StreamMaxAggregateInputType
  }

  export type GetStreamAggregateType<T extends StreamAggregateArgs> = {
        [P in keyof T & keyof AggregateStream]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStream[P]>
      : GetScalarType<T[P], AggregateStream[P]>
  }




  export type StreamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreamWhereInput
    orderBy?: StreamOrderByWithAggregationInput | StreamOrderByWithAggregationInput[]
    by: StreamScalarFieldEnum[] | StreamScalarFieldEnum
    having?: StreamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StreamCountAggregateInputType | true
    _avg?: StreamAvgAggregateInputType
    _sum?: StreamSumAggregateInputType
    _min?: StreamMinAggregateInputType
    _max?: StreamMaxAggregateInputType
  }

  export type StreamGroupByOutputType = {
    id: string
    broadcasterId: string
    title: string | null
    coverImageUrl: string | null
    status: $Enums.StreamStatus
    startTime: Date | null
    endTime: Date | null
    currentViewers: number
    peakViewers: number
    totalDiamondsReceived: bigint
    tags: JsonValue | null
    location: JsonValue | null
    rtcChannelName: string | null
    recordingUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: StreamCountAggregateOutputType | null
    _avg: StreamAvgAggregateOutputType | null
    _sum: StreamSumAggregateOutputType | null
    _min: StreamMinAggregateOutputType | null
    _max: StreamMaxAggregateOutputType | null
  }

  type GetStreamGroupByPayload<T extends StreamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StreamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StreamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StreamGroupByOutputType[P]>
            : GetScalarType<T[P], StreamGroupByOutputType[P]>
        }
      >
    >


  export type StreamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    broadcasterId?: boolean
    title?: boolean
    coverImageUrl?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    currentViewers?: boolean
    peakViewers?: boolean
    totalDiamondsReceived?: boolean
    tags?: boolean
    location?: boolean
    rtcChannelName?: boolean
    recordingUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    broadcaster?: boolean | UserDefaultArgs<ExtArgs>
    reports?: boolean | Stream$reportsArgs<ExtArgs>
    _count?: boolean | StreamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stream"]>

  export type StreamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    broadcasterId?: boolean
    title?: boolean
    coverImageUrl?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    currentViewers?: boolean
    peakViewers?: boolean
    totalDiamondsReceived?: boolean
    tags?: boolean
    location?: boolean
    rtcChannelName?: boolean
    recordingUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    broadcaster?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stream"]>

  export type StreamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    broadcasterId?: boolean
    title?: boolean
    coverImageUrl?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    currentViewers?: boolean
    peakViewers?: boolean
    totalDiamondsReceived?: boolean
    tags?: boolean
    location?: boolean
    rtcChannelName?: boolean
    recordingUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    broadcaster?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stream"]>

  export type StreamSelectScalar = {
    id?: boolean
    broadcasterId?: boolean
    title?: boolean
    coverImageUrl?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    currentViewers?: boolean
    peakViewers?: boolean
    totalDiamondsReceived?: boolean
    tags?: boolean
    location?: boolean
    rtcChannelName?: boolean
    recordingUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StreamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "broadcasterId" | "title" | "coverImageUrl" | "status" | "startTime" | "endTime" | "currentViewers" | "peakViewers" | "totalDiamondsReceived" | "tags" | "location" | "rtcChannelName" | "recordingUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["stream"]>
  export type StreamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadcaster?: boolean | UserDefaultArgs<ExtArgs>
    reports?: boolean | Stream$reportsArgs<ExtArgs>
    _count?: boolean | StreamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StreamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadcaster?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StreamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    broadcaster?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StreamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stream"
    objects: {
      broadcaster: Prisma.$UserPayload<ExtArgs>
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      broadcasterId: string
      title: string | null
      coverImageUrl: string | null
      status: $Enums.StreamStatus
      startTime: Date | null
      endTime: Date | null
      currentViewers: number
      peakViewers: number
      totalDiamondsReceived: bigint
      tags: Prisma.JsonValue | null
      location: Prisma.JsonValue | null
      rtcChannelName: string | null
      recordingUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stream"]>
    composites: {}
  }

  type StreamGetPayload<S extends boolean | null | undefined | StreamDefaultArgs> = $Result.GetResult<Prisma.$StreamPayload, S>

  type StreamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StreamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StreamCountAggregateInputType | true
    }

  export interface StreamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stream'], meta: { name: 'Stream' } }
    /**
     * Find zero or one Stream that matches the filter.
     * @param {StreamFindUniqueArgs} args - Arguments to find a Stream
     * @example
     * // Get one Stream
     * const stream = await prisma.stream.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StreamFindUniqueArgs>(args: SelectSubset<T, StreamFindUniqueArgs<ExtArgs>>): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stream that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StreamFindUniqueOrThrowArgs} args - Arguments to find a Stream
     * @example
     * // Get one Stream
     * const stream = await prisma.stream.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StreamFindUniqueOrThrowArgs>(args: SelectSubset<T, StreamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stream that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamFindFirstArgs} args - Arguments to find a Stream
     * @example
     * // Get one Stream
     * const stream = await prisma.stream.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StreamFindFirstArgs>(args?: SelectSubset<T, StreamFindFirstArgs<ExtArgs>>): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stream that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamFindFirstOrThrowArgs} args - Arguments to find a Stream
     * @example
     * // Get one Stream
     * const stream = await prisma.stream.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StreamFindFirstOrThrowArgs>(args?: SelectSubset<T, StreamFindFirstOrThrowArgs<ExtArgs>>): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Streams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Streams
     * const streams = await prisma.stream.findMany()
     * 
     * // Get first 10 Streams
     * const streams = await prisma.stream.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const streamWithIdOnly = await prisma.stream.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StreamFindManyArgs>(args?: SelectSubset<T, StreamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stream.
     * @param {StreamCreateArgs} args - Arguments to create a Stream.
     * @example
     * // Create one Stream
     * const Stream = await prisma.stream.create({
     *   data: {
     *     // ... data to create a Stream
     *   }
     * })
     * 
     */
    create<T extends StreamCreateArgs>(args: SelectSubset<T, StreamCreateArgs<ExtArgs>>): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Streams.
     * @param {StreamCreateManyArgs} args - Arguments to create many Streams.
     * @example
     * // Create many Streams
     * const stream = await prisma.stream.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StreamCreateManyArgs>(args?: SelectSubset<T, StreamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Streams and returns the data saved in the database.
     * @param {StreamCreateManyAndReturnArgs} args - Arguments to create many Streams.
     * @example
     * // Create many Streams
     * const stream = await prisma.stream.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Streams and only return the `id`
     * const streamWithIdOnly = await prisma.stream.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StreamCreateManyAndReturnArgs>(args?: SelectSubset<T, StreamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stream.
     * @param {StreamDeleteArgs} args - Arguments to delete one Stream.
     * @example
     * // Delete one Stream
     * const Stream = await prisma.stream.delete({
     *   where: {
     *     // ... filter to delete one Stream
     *   }
     * })
     * 
     */
    delete<T extends StreamDeleteArgs>(args: SelectSubset<T, StreamDeleteArgs<ExtArgs>>): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stream.
     * @param {StreamUpdateArgs} args - Arguments to update one Stream.
     * @example
     * // Update one Stream
     * const stream = await prisma.stream.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StreamUpdateArgs>(args: SelectSubset<T, StreamUpdateArgs<ExtArgs>>): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Streams.
     * @param {StreamDeleteManyArgs} args - Arguments to filter Streams to delete.
     * @example
     * // Delete a few Streams
     * const { count } = await prisma.stream.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StreamDeleteManyArgs>(args?: SelectSubset<T, StreamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Streams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Streams
     * const stream = await prisma.stream.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StreamUpdateManyArgs>(args: SelectSubset<T, StreamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Streams and returns the data updated in the database.
     * @param {StreamUpdateManyAndReturnArgs} args - Arguments to update many Streams.
     * @example
     * // Update many Streams
     * const stream = await prisma.stream.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Streams and only return the `id`
     * const streamWithIdOnly = await prisma.stream.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StreamUpdateManyAndReturnArgs>(args: SelectSubset<T, StreamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stream.
     * @param {StreamUpsertArgs} args - Arguments to update or create a Stream.
     * @example
     * // Update or create a Stream
     * const stream = await prisma.stream.upsert({
     *   create: {
     *     // ... data to create a Stream
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stream we want to update
     *   }
     * })
     */
    upsert<T extends StreamUpsertArgs>(args: SelectSubset<T, StreamUpsertArgs<ExtArgs>>): Prisma__StreamClient<$Result.GetResult<Prisma.$StreamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Streams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamCountArgs} args - Arguments to filter Streams to count.
     * @example
     * // Count the number of Streams
     * const count = await prisma.stream.count({
     *   where: {
     *     // ... the filter for the Streams we want to count
     *   }
     * })
    **/
    count<T extends StreamCountArgs>(
      args?: Subset<T, StreamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StreamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StreamAggregateArgs>(args: Subset<T, StreamAggregateArgs>): Prisma.PrismaPromise<GetStreamAggregateType<T>>

    /**
     * Group by Stream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StreamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StreamGroupByArgs['orderBy'] }
        : { orderBy?: StreamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StreamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStreamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stream model
   */
  readonly fields: StreamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stream.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StreamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    broadcaster<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reports<T extends Stream$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Stream$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stream model
   */
  interface StreamFieldRefs {
    readonly id: FieldRef<"Stream", 'String'>
    readonly broadcasterId: FieldRef<"Stream", 'String'>
    readonly title: FieldRef<"Stream", 'String'>
    readonly coverImageUrl: FieldRef<"Stream", 'String'>
    readonly status: FieldRef<"Stream", 'StreamStatus'>
    readonly startTime: FieldRef<"Stream", 'DateTime'>
    readonly endTime: FieldRef<"Stream", 'DateTime'>
    readonly currentViewers: FieldRef<"Stream", 'Int'>
    readonly peakViewers: FieldRef<"Stream", 'Int'>
    readonly totalDiamondsReceived: FieldRef<"Stream", 'BigInt'>
    readonly tags: FieldRef<"Stream", 'Json'>
    readonly location: FieldRef<"Stream", 'Json'>
    readonly rtcChannelName: FieldRef<"Stream", 'String'>
    readonly recordingUrl: FieldRef<"Stream", 'String'>
    readonly createdAt: FieldRef<"Stream", 'DateTime'>
    readonly updatedAt: FieldRef<"Stream", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stream findUnique
   */
  export type StreamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * Filter, which Stream to fetch.
     */
    where: StreamWhereUniqueInput
  }

  /**
   * Stream findUniqueOrThrow
   */
  export type StreamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * Filter, which Stream to fetch.
     */
    where: StreamWhereUniqueInput
  }

  /**
   * Stream findFirst
   */
  export type StreamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * Filter, which Stream to fetch.
     */
    where?: StreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streams to fetch.
     */
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Streams.
     */
    cursor?: StreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Streams.
     */
    distinct?: StreamScalarFieldEnum | StreamScalarFieldEnum[]
  }

  /**
   * Stream findFirstOrThrow
   */
  export type StreamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * Filter, which Stream to fetch.
     */
    where?: StreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streams to fetch.
     */
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Streams.
     */
    cursor?: StreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Streams.
     */
    distinct?: StreamScalarFieldEnum | StreamScalarFieldEnum[]
  }

  /**
   * Stream findMany
   */
  export type StreamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * Filter, which Streams to fetch.
     */
    where?: StreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streams to fetch.
     */
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Streams.
     */
    cursor?: StreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streams.
     */
    skip?: number
    distinct?: StreamScalarFieldEnum | StreamScalarFieldEnum[]
  }

  /**
   * Stream create
   */
  export type StreamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * The data needed to create a Stream.
     */
    data: XOR<StreamCreateInput, StreamUncheckedCreateInput>
  }

  /**
   * Stream createMany
   */
  export type StreamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Streams.
     */
    data: StreamCreateManyInput | StreamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stream createManyAndReturn
   */
  export type StreamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * The data used to create many Streams.
     */
    data: StreamCreateManyInput | StreamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stream update
   */
  export type StreamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * The data needed to update a Stream.
     */
    data: XOR<StreamUpdateInput, StreamUncheckedUpdateInput>
    /**
     * Choose, which Stream to update.
     */
    where: StreamWhereUniqueInput
  }

  /**
   * Stream updateMany
   */
  export type StreamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Streams.
     */
    data: XOR<StreamUpdateManyMutationInput, StreamUncheckedUpdateManyInput>
    /**
     * Filter which Streams to update
     */
    where?: StreamWhereInput
    /**
     * Limit how many Streams to update.
     */
    limit?: number
  }

  /**
   * Stream updateManyAndReturn
   */
  export type StreamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * The data used to update Streams.
     */
    data: XOR<StreamUpdateManyMutationInput, StreamUncheckedUpdateManyInput>
    /**
     * Filter which Streams to update
     */
    where?: StreamWhereInput
    /**
     * Limit how many Streams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stream upsert
   */
  export type StreamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * The filter to search for the Stream to update in case it exists.
     */
    where: StreamWhereUniqueInput
    /**
     * In case the Stream found by the `where` argument doesn't exist, create a new Stream with this data.
     */
    create: XOR<StreamCreateInput, StreamUncheckedCreateInput>
    /**
     * In case the Stream was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StreamUpdateInput, StreamUncheckedUpdateInput>
  }

  /**
   * Stream delete
   */
  export type StreamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
    /**
     * Filter which Stream to delete.
     */
    where: StreamWhereUniqueInput
  }

  /**
   * Stream deleteMany
   */
  export type StreamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Streams to delete
     */
    where?: StreamWhereInput
    /**
     * Limit how many Streams to delete.
     */
    limit?: number
  }

  /**
   * Stream.reports
   */
  export type Stream$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Stream without action
   */
  export type StreamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    revokedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    lastUsedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    revokedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    lastUsedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    revokedAt: number
    ipAddress: number
    userAgent: number
    lastUsedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    revokedAt?: true
    ipAddress?: true
    userAgent?: true
    lastUsedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    revokedAt?: true
    ipAddress?: true
    userAgent?: true
    lastUsedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    revokedAt?: true
    ipAddress?: true
    userAgent?: true
    lastUsedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    revokedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    lastUsedAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    lastUsedAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "createdAt" | "updatedAt" | "revokedAt" | "ipAddress" | "userAgent" | "lastUsedAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
      revokedAt: Date | null
      ipAddress: string | null
      userAgent: string | null
      lastUsedAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly ipAddress: FieldRef<"RefreshToken", 'String'>
    readonly userAgent: FieldRef<"RefreshToken", 'String'>
    readonly lastUsedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model OneSignalPlayer
   */

  export type AggregateOneSignalPlayer = {
    _count: OneSignalPlayerCountAggregateOutputType | null
    _min: OneSignalPlayerMinAggregateOutputType | null
    _max: OneSignalPlayerMaxAggregateOutputType | null
  }

  export type OneSignalPlayerMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    userId: string | null
    deviceInfo: string | null
    lastSeen: Date | null
    createdAt: Date | null
  }

  export type OneSignalPlayerMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    userId: string | null
    deviceInfo: string | null
    lastSeen: Date | null
    createdAt: Date | null
  }

  export type OneSignalPlayerCountAggregateOutputType = {
    id: number
    playerId: number
    userId: number
    deviceInfo: number
    lastSeen: number
    createdAt: number
    _all: number
  }


  export type OneSignalPlayerMinAggregateInputType = {
    id?: true
    playerId?: true
    userId?: true
    deviceInfo?: true
    lastSeen?: true
    createdAt?: true
  }

  export type OneSignalPlayerMaxAggregateInputType = {
    id?: true
    playerId?: true
    userId?: true
    deviceInfo?: true
    lastSeen?: true
    createdAt?: true
  }

  export type OneSignalPlayerCountAggregateInputType = {
    id?: true
    playerId?: true
    userId?: true
    deviceInfo?: true
    lastSeen?: true
    createdAt?: true
    _all?: true
  }

  export type OneSignalPlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OneSignalPlayer to aggregate.
     */
    where?: OneSignalPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneSignalPlayers to fetch.
     */
    orderBy?: OneSignalPlayerOrderByWithRelationInput | OneSignalPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OneSignalPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneSignalPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneSignalPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OneSignalPlayers
    **/
    _count?: true | OneSignalPlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OneSignalPlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OneSignalPlayerMaxAggregateInputType
  }

  export type GetOneSignalPlayerAggregateType<T extends OneSignalPlayerAggregateArgs> = {
        [P in keyof T & keyof AggregateOneSignalPlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOneSignalPlayer[P]>
      : GetScalarType<T[P], AggregateOneSignalPlayer[P]>
  }




  export type OneSignalPlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OneSignalPlayerWhereInput
    orderBy?: OneSignalPlayerOrderByWithAggregationInput | OneSignalPlayerOrderByWithAggregationInput[]
    by: OneSignalPlayerScalarFieldEnum[] | OneSignalPlayerScalarFieldEnum
    having?: OneSignalPlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OneSignalPlayerCountAggregateInputType | true
    _min?: OneSignalPlayerMinAggregateInputType
    _max?: OneSignalPlayerMaxAggregateInputType
  }

  export type OneSignalPlayerGroupByOutputType = {
    id: string
    playerId: string
    userId: string
    deviceInfo: string | null
    lastSeen: Date
    createdAt: Date
    _count: OneSignalPlayerCountAggregateOutputType | null
    _min: OneSignalPlayerMinAggregateOutputType | null
    _max: OneSignalPlayerMaxAggregateOutputType | null
  }

  type GetOneSignalPlayerGroupByPayload<T extends OneSignalPlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OneSignalPlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OneSignalPlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OneSignalPlayerGroupByOutputType[P]>
            : GetScalarType<T[P], OneSignalPlayerGroupByOutputType[P]>
        }
      >
    >


  export type OneSignalPlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    userId?: boolean
    deviceInfo?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oneSignalPlayer"]>

  export type OneSignalPlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    userId?: boolean
    deviceInfo?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oneSignalPlayer"]>

  export type OneSignalPlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    userId?: boolean
    deviceInfo?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oneSignalPlayer"]>

  export type OneSignalPlayerSelectScalar = {
    id?: boolean
    playerId?: boolean
    userId?: boolean
    deviceInfo?: boolean
    lastSeen?: boolean
    createdAt?: boolean
  }

  export type OneSignalPlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "userId" | "deviceInfo" | "lastSeen" | "createdAt", ExtArgs["result"]["oneSignalPlayer"]>
  export type OneSignalPlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OneSignalPlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OneSignalPlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OneSignalPlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OneSignalPlayer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      userId: string
      deviceInfo: string | null
      lastSeen: Date
      createdAt: Date
    }, ExtArgs["result"]["oneSignalPlayer"]>
    composites: {}
  }

  type OneSignalPlayerGetPayload<S extends boolean | null | undefined | OneSignalPlayerDefaultArgs> = $Result.GetResult<Prisma.$OneSignalPlayerPayload, S>

  type OneSignalPlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OneSignalPlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OneSignalPlayerCountAggregateInputType | true
    }

  export interface OneSignalPlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OneSignalPlayer'], meta: { name: 'OneSignalPlayer' } }
    /**
     * Find zero or one OneSignalPlayer that matches the filter.
     * @param {OneSignalPlayerFindUniqueArgs} args - Arguments to find a OneSignalPlayer
     * @example
     * // Get one OneSignalPlayer
     * const oneSignalPlayer = await prisma.oneSignalPlayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OneSignalPlayerFindUniqueArgs>(args: SelectSubset<T, OneSignalPlayerFindUniqueArgs<ExtArgs>>): Prisma__OneSignalPlayerClient<$Result.GetResult<Prisma.$OneSignalPlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OneSignalPlayer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OneSignalPlayerFindUniqueOrThrowArgs} args - Arguments to find a OneSignalPlayer
     * @example
     * // Get one OneSignalPlayer
     * const oneSignalPlayer = await prisma.oneSignalPlayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OneSignalPlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, OneSignalPlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OneSignalPlayerClient<$Result.GetResult<Prisma.$OneSignalPlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OneSignalPlayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneSignalPlayerFindFirstArgs} args - Arguments to find a OneSignalPlayer
     * @example
     * // Get one OneSignalPlayer
     * const oneSignalPlayer = await prisma.oneSignalPlayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OneSignalPlayerFindFirstArgs>(args?: SelectSubset<T, OneSignalPlayerFindFirstArgs<ExtArgs>>): Prisma__OneSignalPlayerClient<$Result.GetResult<Prisma.$OneSignalPlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OneSignalPlayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneSignalPlayerFindFirstOrThrowArgs} args - Arguments to find a OneSignalPlayer
     * @example
     * // Get one OneSignalPlayer
     * const oneSignalPlayer = await prisma.oneSignalPlayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OneSignalPlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, OneSignalPlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__OneSignalPlayerClient<$Result.GetResult<Prisma.$OneSignalPlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OneSignalPlayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneSignalPlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OneSignalPlayers
     * const oneSignalPlayers = await prisma.oneSignalPlayer.findMany()
     * 
     * // Get first 10 OneSignalPlayers
     * const oneSignalPlayers = await prisma.oneSignalPlayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oneSignalPlayerWithIdOnly = await prisma.oneSignalPlayer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OneSignalPlayerFindManyArgs>(args?: SelectSubset<T, OneSignalPlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneSignalPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OneSignalPlayer.
     * @param {OneSignalPlayerCreateArgs} args - Arguments to create a OneSignalPlayer.
     * @example
     * // Create one OneSignalPlayer
     * const OneSignalPlayer = await prisma.oneSignalPlayer.create({
     *   data: {
     *     // ... data to create a OneSignalPlayer
     *   }
     * })
     * 
     */
    create<T extends OneSignalPlayerCreateArgs>(args: SelectSubset<T, OneSignalPlayerCreateArgs<ExtArgs>>): Prisma__OneSignalPlayerClient<$Result.GetResult<Prisma.$OneSignalPlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OneSignalPlayers.
     * @param {OneSignalPlayerCreateManyArgs} args - Arguments to create many OneSignalPlayers.
     * @example
     * // Create many OneSignalPlayers
     * const oneSignalPlayer = await prisma.oneSignalPlayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OneSignalPlayerCreateManyArgs>(args?: SelectSubset<T, OneSignalPlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OneSignalPlayers and returns the data saved in the database.
     * @param {OneSignalPlayerCreateManyAndReturnArgs} args - Arguments to create many OneSignalPlayers.
     * @example
     * // Create many OneSignalPlayers
     * const oneSignalPlayer = await prisma.oneSignalPlayer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OneSignalPlayers and only return the `id`
     * const oneSignalPlayerWithIdOnly = await prisma.oneSignalPlayer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OneSignalPlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, OneSignalPlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneSignalPlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OneSignalPlayer.
     * @param {OneSignalPlayerDeleteArgs} args - Arguments to delete one OneSignalPlayer.
     * @example
     * // Delete one OneSignalPlayer
     * const OneSignalPlayer = await prisma.oneSignalPlayer.delete({
     *   where: {
     *     // ... filter to delete one OneSignalPlayer
     *   }
     * })
     * 
     */
    delete<T extends OneSignalPlayerDeleteArgs>(args: SelectSubset<T, OneSignalPlayerDeleteArgs<ExtArgs>>): Prisma__OneSignalPlayerClient<$Result.GetResult<Prisma.$OneSignalPlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OneSignalPlayer.
     * @param {OneSignalPlayerUpdateArgs} args - Arguments to update one OneSignalPlayer.
     * @example
     * // Update one OneSignalPlayer
     * const oneSignalPlayer = await prisma.oneSignalPlayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OneSignalPlayerUpdateArgs>(args: SelectSubset<T, OneSignalPlayerUpdateArgs<ExtArgs>>): Prisma__OneSignalPlayerClient<$Result.GetResult<Prisma.$OneSignalPlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OneSignalPlayers.
     * @param {OneSignalPlayerDeleteManyArgs} args - Arguments to filter OneSignalPlayers to delete.
     * @example
     * // Delete a few OneSignalPlayers
     * const { count } = await prisma.oneSignalPlayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OneSignalPlayerDeleteManyArgs>(args?: SelectSubset<T, OneSignalPlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OneSignalPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneSignalPlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OneSignalPlayers
     * const oneSignalPlayer = await prisma.oneSignalPlayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OneSignalPlayerUpdateManyArgs>(args: SelectSubset<T, OneSignalPlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OneSignalPlayers and returns the data updated in the database.
     * @param {OneSignalPlayerUpdateManyAndReturnArgs} args - Arguments to update many OneSignalPlayers.
     * @example
     * // Update many OneSignalPlayers
     * const oneSignalPlayer = await prisma.oneSignalPlayer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OneSignalPlayers and only return the `id`
     * const oneSignalPlayerWithIdOnly = await prisma.oneSignalPlayer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OneSignalPlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, OneSignalPlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneSignalPlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OneSignalPlayer.
     * @param {OneSignalPlayerUpsertArgs} args - Arguments to update or create a OneSignalPlayer.
     * @example
     * // Update or create a OneSignalPlayer
     * const oneSignalPlayer = await prisma.oneSignalPlayer.upsert({
     *   create: {
     *     // ... data to create a OneSignalPlayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OneSignalPlayer we want to update
     *   }
     * })
     */
    upsert<T extends OneSignalPlayerUpsertArgs>(args: SelectSubset<T, OneSignalPlayerUpsertArgs<ExtArgs>>): Prisma__OneSignalPlayerClient<$Result.GetResult<Prisma.$OneSignalPlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OneSignalPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneSignalPlayerCountArgs} args - Arguments to filter OneSignalPlayers to count.
     * @example
     * // Count the number of OneSignalPlayers
     * const count = await prisma.oneSignalPlayer.count({
     *   where: {
     *     // ... the filter for the OneSignalPlayers we want to count
     *   }
     * })
    **/
    count<T extends OneSignalPlayerCountArgs>(
      args?: Subset<T, OneSignalPlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OneSignalPlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OneSignalPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneSignalPlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OneSignalPlayerAggregateArgs>(args: Subset<T, OneSignalPlayerAggregateArgs>): Prisma.PrismaPromise<GetOneSignalPlayerAggregateType<T>>

    /**
     * Group by OneSignalPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneSignalPlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OneSignalPlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OneSignalPlayerGroupByArgs['orderBy'] }
        : { orderBy?: OneSignalPlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OneSignalPlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOneSignalPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OneSignalPlayer model
   */
  readonly fields: OneSignalPlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OneSignalPlayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OneSignalPlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OneSignalPlayer model
   */
  interface OneSignalPlayerFieldRefs {
    readonly id: FieldRef<"OneSignalPlayer", 'String'>
    readonly playerId: FieldRef<"OneSignalPlayer", 'String'>
    readonly userId: FieldRef<"OneSignalPlayer", 'String'>
    readonly deviceInfo: FieldRef<"OneSignalPlayer", 'String'>
    readonly lastSeen: FieldRef<"OneSignalPlayer", 'DateTime'>
    readonly createdAt: FieldRef<"OneSignalPlayer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OneSignalPlayer findUnique
   */
  export type OneSignalPlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerInclude<ExtArgs> | null
    /**
     * Filter, which OneSignalPlayer to fetch.
     */
    where: OneSignalPlayerWhereUniqueInput
  }

  /**
   * OneSignalPlayer findUniqueOrThrow
   */
  export type OneSignalPlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerInclude<ExtArgs> | null
    /**
     * Filter, which OneSignalPlayer to fetch.
     */
    where: OneSignalPlayerWhereUniqueInput
  }

  /**
   * OneSignalPlayer findFirst
   */
  export type OneSignalPlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerInclude<ExtArgs> | null
    /**
     * Filter, which OneSignalPlayer to fetch.
     */
    where?: OneSignalPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneSignalPlayers to fetch.
     */
    orderBy?: OneSignalPlayerOrderByWithRelationInput | OneSignalPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OneSignalPlayers.
     */
    cursor?: OneSignalPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneSignalPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneSignalPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OneSignalPlayers.
     */
    distinct?: OneSignalPlayerScalarFieldEnum | OneSignalPlayerScalarFieldEnum[]
  }

  /**
   * OneSignalPlayer findFirstOrThrow
   */
  export type OneSignalPlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerInclude<ExtArgs> | null
    /**
     * Filter, which OneSignalPlayer to fetch.
     */
    where?: OneSignalPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneSignalPlayers to fetch.
     */
    orderBy?: OneSignalPlayerOrderByWithRelationInput | OneSignalPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OneSignalPlayers.
     */
    cursor?: OneSignalPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneSignalPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneSignalPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OneSignalPlayers.
     */
    distinct?: OneSignalPlayerScalarFieldEnum | OneSignalPlayerScalarFieldEnum[]
  }

  /**
   * OneSignalPlayer findMany
   */
  export type OneSignalPlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerInclude<ExtArgs> | null
    /**
     * Filter, which OneSignalPlayers to fetch.
     */
    where?: OneSignalPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneSignalPlayers to fetch.
     */
    orderBy?: OneSignalPlayerOrderByWithRelationInput | OneSignalPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OneSignalPlayers.
     */
    cursor?: OneSignalPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneSignalPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneSignalPlayers.
     */
    skip?: number
    distinct?: OneSignalPlayerScalarFieldEnum | OneSignalPlayerScalarFieldEnum[]
  }

  /**
   * OneSignalPlayer create
   */
  export type OneSignalPlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a OneSignalPlayer.
     */
    data: XOR<OneSignalPlayerCreateInput, OneSignalPlayerUncheckedCreateInput>
  }

  /**
   * OneSignalPlayer createMany
   */
  export type OneSignalPlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OneSignalPlayers.
     */
    data: OneSignalPlayerCreateManyInput | OneSignalPlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OneSignalPlayer createManyAndReturn
   */
  export type OneSignalPlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * The data used to create many OneSignalPlayers.
     */
    data: OneSignalPlayerCreateManyInput | OneSignalPlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OneSignalPlayer update
   */
  export type OneSignalPlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a OneSignalPlayer.
     */
    data: XOR<OneSignalPlayerUpdateInput, OneSignalPlayerUncheckedUpdateInput>
    /**
     * Choose, which OneSignalPlayer to update.
     */
    where: OneSignalPlayerWhereUniqueInput
  }

  /**
   * OneSignalPlayer updateMany
   */
  export type OneSignalPlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OneSignalPlayers.
     */
    data: XOR<OneSignalPlayerUpdateManyMutationInput, OneSignalPlayerUncheckedUpdateManyInput>
    /**
     * Filter which OneSignalPlayers to update
     */
    where?: OneSignalPlayerWhereInput
    /**
     * Limit how many OneSignalPlayers to update.
     */
    limit?: number
  }

  /**
   * OneSignalPlayer updateManyAndReturn
   */
  export type OneSignalPlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * The data used to update OneSignalPlayers.
     */
    data: XOR<OneSignalPlayerUpdateManyMutationInput, OneSignalPlayerUncheckedUpdateManyInput>
    /**
     * Filter which OneSignalPlayers to update
     */
    where?: OneSignalPlayerWhereInput
    /**
     * Limit how many OneSignalPlayers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OneSignalPlayer upsert
   */
  export type OneSignalPlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the OneSignalPlayer to update in case it exists.
     */
    where: OneSignalPlayerWhereUniqueInput
    /**
     * In case the OneSignalPlayer found by the `where` argument doesn't exist, create a new OneSignalPlayer with this data.
     */
    create: XOR<OneSignalPlayerCreateInput, OneSignalPlayerUncheckedCreateInput>
    /**
     * In case the OneSignalPlayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OneSignalPlayerUpdateInput, OneSignalPlayerUncheckedUpdateInput>
  }

  /**
   * OneSignalPlayer delete
   */
  export type OneSignalPlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerInclude<ExtArgs> | null
    /**
     * Filter which OneSignalPlayer to delete.
     */
    where: OneSignalPlayerWhereUniqueInput
  }

  /**
   * OneSignalPlayer deleteMany
   */
  export type OneSignalPlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OneSignalPlayers to delete
     */
    where?: OneSignalPlayerWhereInput
    /**
     * Limit how many OneSignalPlayers to delete.
     */
    limit?: number
  }

  /**
   * OneSignalPlayer without action
   */
  export type OneSignalPlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneSignalPlayer
     */
    select?: OneSignalPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OneSignalPlayer
     */
    omit?: OneSignalPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneSignalPlayerInclude<ExtArgs> | null
  }


  /**
   * Model TrustedDevice
   */

  export type AggregateTrustedDevice = {
    _count: TrustedDeviceCountAggregateOutputType | null
    _min: TrustedDeviceMinAggregateOutputType | null
    _max: TrustedDeviceMaxAggregateOutputType | null
  }

  export type TrustedDeviceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceName: string | null
    deviceType: string | null
    ipAddress: string | null
    userAgent: string | null
    location: string | null
    isCurrentDevice: boolean | null
    lastUsedAt: Date | null
    createdAt: Date | null
  }

  export type TrustedDeviceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceName: string | null
    deviceType: string | null
    ipAddress: string | null
    userAgent: string | null
    location: string | null
    isCurrentDevice: boolean | null
    lastUsedAt: Date | null
    createdAt: Date | null
  }

  export type TrustedDeviceCountAggregateOutputType = {
    id: number
    userId: number
    deviceName: number
    deviceType: number
    ipAddress: number
    userAgent: number
    location: number
    isCurrentDevice: number
    lastUsedAt: number
    createdAt: number
    _all: number
  }


  export type TrustedDeviceMinAggregateInputType = {
    id?: true
    userId?: true
    deviceName?: true
    deviceType?: true
    ipAddress?: true
    userAgent?: true
    location?: true
    isCurrentDevice?: true
    lastUsedAt?: true
    createdAt?: true
  }

  export type TrustedDeviceMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceName?: true
    deviceType?: true
    ipAddress?: true
    userAgent?: true
    location?: true
    isCurrentDevice?: true
    lastUsedAt?: true
    createdAt?: true
  }

  export type TrustedDeviceCountAggregateInputType = {
    id?: true
    userId?: true
    deviceName?: true
    deviceType?: true
    ipAddress?: true
    userAgent?: true
    location?: true
    isCurrentDevice?: true
    lastUsedAt?: true
    createdAt?: true
    _all?: true
  }

  export type TrustedDeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrustedDevice to aggregate.
     */
    where?: TrustedDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustedDevices to fetch.
     */
    orderBy?: TrustedDeviceOrderByWithRelationInput | TrustedDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrustedDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustedDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustedDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrustedDevices
    **/
    _count?: true | TrustedDeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrustedDeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrustedDeviceMaxAggregateInputType
  }

  export type GetTrustedDeviceAggregateType<T extends TrustedDeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateTrustedDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrustedDevice[P]>
      : GetScalarType<T[P], AggregateTrustedDevice[P]>
  }




  export type TrustedDeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrustedDeviceWhereInput
    orderBy?: TrustedDeviceOrderByWithAggregationInput | TrustedDeviceOrderByWithAggregationInput[]
    by: TrustedDeviceScalarFieldEnum[] | TrustedDeviceScalarFieldEnum
    having?: TrustedDeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrustedDeviceCountAggregateInputType | true
    _min?: TrustedDeviceMinAggregateInputType
    _max?: TrustedDeviceMaxAggregateInputType
  }

  export type TrustedDeviceGroupByOutputType = {
    id: string
    userId: string
    deviceName: string
    deviceType: string | null
    ipAddress: string | null
    userAgent: string | null
    location: string | null
    isCurrentDevice: boolean
    lastUsedAt: Date
    createdAt: Date
    _count: TrustedDeviceCountAggregateOutputType | null
    _min: TrustedDeviceMinAggregateOutputType | null
    _max: TrustedDeviceMaxAggregateOutputType | null
  }

  type GetTrustedDeviceGroupByPayload<T extends TrustedDeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrustedDeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrustedDeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrustedDeviceGroupByOutputType[P]>
            : GetScalarType<T[P], TrustedDeviceGroupByOutputType[P]>
        }
      >
    >


  export type TrustedDeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceName?: boolean
    deviceType?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    location?: boolean
    isCurrentDevice?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trustedDevice"]>

  export type TrustedDeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceName?: boolean
    deviceType?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    location?: boolean
    isCurrentDevice?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trustedDevice"]>

  export type TrustedDeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceName?: boolean
    deviceType?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    location?: boolean
    isCurrentDevice?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trustedDevice"]>

  export type TrustedDeviceSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceName?: boolean
    deviceType?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    location?: boolean
    isCurrentDevice?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
  }

  export type TrustedDeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceName" | "deviceType" | "ipAddress" | "userAgent" | "location" | "isCurrentDevice" | "lastUsedAt" | "createdAt", ExtArgs["result"]["trustedDevice"]>
  export type TrustedDeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrustedDeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrustedDeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrustedDevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrustedDevice"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      deviceName: string
      deviceType: string | null
      ipAddress: string | null
      userAgent: string | null
      location: string | null
      isCurrentDevice: boolean
      lastUsedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["trustedDevice"]>
    composites: {}
  }

  type TrustedDeviceGetPayload<S extends boolean | null | undefined | TrustedDeviceDefaultArgs> = $Result.GetResult<Prisma.$TrustedDevicePayload, S>

  type TrustedDeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrustedDeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrustedDeviceCountAggregateInputType | true
    }

  export interface TrustedDeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrustedDevice'], meta: { name: 'TrustedDevice' } }
    /**
     * Find zero or one TrustedDevice that matches the filter.
     * @param {TrustedDeviceFindUniqueArgs} args - Arguments to find a TrustedDevice
     * @example
     * // Get one TrustedDevice
     * const trustedDevice = await prisma.trustedDevice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrustedDeviceFindUniqueArgs>(args: SelectSubset<T, TrustedDeviceFindUniqueArgs<ExtArgs>>): Prisma__TrustedDeviceClient<$Result.GetResult<Prisma.$TrustedDevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrustedDevice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrustedDeviceFindUniqueOrThrowArgs} args - Arguments to find a TrustedDevice
     * @example
     * // Get one TrustedDevice
     * const trustedDevice = await prisma.trustedDevice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrustedDeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, TrustedDeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrustedDeviceClient<$Result.GetResult<Prisma.$TrustedDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrustedDevice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustedDeviceFindFirstArgs} args - Arguments to find a TrustedDevice
     * @example
     * // Get one TrustedDevice
     * const trustedDevice = await prisma.trustedDevice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrustedDeviceFindFirstArgs>(args?: SelectSubset<T, TrustedDeviceFindFirstArgs<ExtArgs>>): Prisma__TrustedDeviceClient<$Result.GetResult<Prisma.$TrustedDevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrustedDevice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustedDeviceFindFirstOrThrowArgs} args - Arguments to find a TrustedDevice
     * @example
     * // Get one TrustedDevice
     * const trustedDevice = await prisma.trustedDevice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrustedDeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, TrustedDeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrustedDeviceClient<$Result.GetResult<Prisma.$TrustedDevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrustedDevices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustedDeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrustedDevices
     * const trustedDevices = await prisma.trustedDevice.findMany()
     * 
     * // Get first 10 TrustedDevices
     * const trustedDevices = await prisma.trustedDevice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trustedDeviceWithIdOnly = await prisma.trustedDevice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrustedDeviceFindManyArgs>(args?: SelectSubset<T, TrustedDeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustedDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrustedDevice.
     * @param {TrustedDeviceCreateArgs} args - Arguments to create a TrustedDevice.
     * @example
     * // Create one TrustedDevice
     * const TrustedDevice = await prisma.trustedDevice.create({
     *   data: {
     *     // ... data to create a TrustedDevice
     *   }
     * })
     * 
     */
    create<T extends TrustedDeviceCreateArgs>(args: SelectSubset<T, TrustedDeviceCreateArgs<ExtArgs>>): Prisma__TrustedDeviceClient<$Result.GetResult<Prisma.$TrustedDevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrustedDevices.
     * @param {TrustedDeviceCreateManyArgs} args - Arguments to create many TrustedDevices.
     * @example
     * // Create many TrustedDevices
     * const trustedDevice = await prisma.trustedDevice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrustedDeviceCreateManyArgs>(args?: SelectSubset<T, TrustedDeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrustedDevices and returns the data saved in the database.
     * @param {TrustedDeviceCreateManyAndReturnArgs} args - Arguments to create many TrustedDevices.
     * @example
     * // Create many TrustedDevices
     * const trustedDevice = await prisma.trustedDevice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrustedDevices and only return the `id`
     * const trustedDeviceWithIdOnly = await prisma.trustedDevice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrustedDeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, TrustedDeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustedDevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrustedDevice.
     * @param {TrustedDeviceDeleteArgs} args - Arguments to delete one TrustedDevice.
     * @example
     * // Delete one TrustedDevice
     * const TrustedDevice = await prisma.trustedDevice.delete({
     *   where: {
     *     // ... filter to delete one TrustedDevice
     *   }
     * })
     * 
     */
    delete<T extends TrustedDeviceDeleteArgs>(args: SelectSubset<T, TrustedDeviceDeleteArgs<ExtArgs>>): Prisma__TrustedDeviceClient<$Result.GetResult<Prisma.$TrustedDevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrustedDevice.
     * @param {TrustedDeviceUpdateArgs} args - Arguments to update one TrustedDevice.
     * @example
     * // Update one TrustedDevice
     * const trustedDevice = await prisma.trustedDevice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrustedDeviceUpdateArgs>(args: SelectSubset<T, TrustedDeviceUpdateArgs<ExtArgs>>): Prisma__TrustedDeviceClient<$Result.GetResult<Prisma.$TrustedDevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrustedDevices.
     * @param {TrustedDeviceDeleteManyArgs} args - Arguments to filter TrustedDevices to delete.
     * @example
     * // Delete a few TrustedDevices
     * const { count } = await prisma.trustedDevice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrustedDeviceDeleteManyArgs>(args?: SelectSubset<T, TrustedDeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrustedDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustedDeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrustedDevices
     * const trustedDevice = await prisma.trustedDevice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrustedDeviceUpdateManyArgs>(args: SelectSubset<T, TrustedDeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrustedDevices and returns the data updated in the database.
     * @param {TrustedDeviceUpdateManyAndReturnArgs} args - Arguments to update many TrustedDevices.
     * @example
     * // Update many TrustedDevices
     * const trustedDevice = await prisma.trustedDevice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrustedDevices and only return the `id`
     * const trustedDeviceWithIdOnly = await prisma.trustedDevice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrustedDeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, TrustedDeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustedDevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrustedDevice.
     * @param {TrustedDeviceUpsertArgs} args - Arguments to update or create a TrustedDevice.
     * @example
     * // Update or create a TrustedDevice
     * const trustedDevice = await prisma.trustedDevice.upsert({
     *   create: {
     *     // ... data to create a TrustedDevice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrustedDevice we want to update
     *   }
     * })
     */
    upsert<T extends TrustedDeviceUpsertArgs>(args: SelectSubset<T, TrustedDeviceUpsertArgs<ExtArgs>>): Prisma__TrustedDeviceClient<$Result.GetResult<Prisma.$TrustedDevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrustedDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustedDeviceCountArgs} args - Arguments to filter TrustedDevices to count.
     * @example
     * // Count the number of TrustedDevices
     * const count = await prisma.trustedDevice.count({
     *   where: {
     *     // ... the filter for the TrustedDevices we want to count
     *   }
     * })
    **/
    count<T extends TrustedDeviceCountArgs>(
      args?: Subset<T, TrustedDeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrustedDeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrustedDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustedDeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrustedDeviceAggregateArgs>(args: Subset<T, TrustedDeviceAggregateArgs>): Prisma.PrismaPromise<GetTrustedDeviceAggregateType<T>>

    /**
     * Group by TrustedDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustedDeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrustedDeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrustedDeviceGroupByArgs['orderBy'] }
        : { orderBy?: TrustedDeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrustedDeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrustedDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrustedDevice model
   */
  readonly fields: TrustedDeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrustedDevice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrustedDeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrustedDevice model
   */
  interface TrustedDeviceFieldRefs {
    readonly id: FieldRef<"TrustedDevice", 'String'>
    readonly userId: FieldRef<"TrustedDevice", 'String'>
    readonly deviceName: FieldRef<"TrustedDevice", 'String'>
    readonly deviceType: FieldRef<"TrustedDevice", 'String'>
    readonly ipAddress: FieldRef<"TrustedDevice", 'String'>
    readonly userAgent: FieldRef<"TrustedDevice", 'String'>
    readonly location: FieldRef<"TrustedDevice", 'String'>
    readonly isCurrentDevice: FieldRef<"TrustedDevice", 'Boolean'>
    readonly lastUsedAt: FieldRef<"TrustedDevice", 'DateTime'>
    readonly createdAt: FieldRef<"TrustedDevice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrustedDevice findUnique
   */
  export type TrustedDeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceInclude<ExtArgs> | null
    /**
     * Filter, which TrustedDevice to fetch.
     */
    where: TrustedDeviceWhereUniqueInput
  }

  /**
   * TrustedDevice findUniqueOrThrow
   */
  export type TrustedDeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceInclude<ExtArgs> | null
    /**
     * Filter, which TrustedDevice to fetch.
     */
    where: TrustedDeviceWhereUniqueInput
  }

  /**
   * TrustedDevice findFirst
   */
  export type TrustedDeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceInclude<ExtArgs> | null
    /**
     * Filter, which TrustedDevice to fetch.
     */
    where?: TrustedDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustedDevices to fetch.
     */
    orderBy?: TrustedDeviceOrderByWithRelationInput | TrustedDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrustedDevices.
     */
    cursor?: TrustedDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustedDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustedDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrustedDevices.
     */
    distinct?: TrustedDeviceScalarFieldEnum | TrustedDeviceScalarFieldEnum[]
  }

  /**
   * TrustedDevice findFirstOrThrow
   */
  export type TrustedDeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceInclude<ExtArgs> | null
    /**
     * Filter, which TrustedDevice to fetch.
     */
    where?: TrustedDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustedDevices to fetch.
     */
    orderBy?: TrustedDeviceOrderByWithRelationInput | TrustedDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrustedDevices.
     */
    cursor?: TrustedDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustedDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustedDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrustedDevices.
     */
    distinct?: TrustedDeviceScalarFieldEnum | TrustedDeviceScalarFieldEnum[]
  }

  /**
   * TrustedDevice findMany
   */
  export type TrustedDeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceInclude<ExtArgs> | null
    /**
     * Filter, which TrustedDevices to fetch.
     */
    where?: TrustedDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustedDevices to fetch.
     */
    orderBy?: TrustedDeviceOrderByWithRelationInput | TrustedDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrustedDevices.
     */
    cursor?: TrustedDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustedDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustedDevices.
     */
    skip?: number
    distinct?: TrustedDeviceScalarFieldEnum | TrustedDeviceScalarFieldEnum[]
  }

  /**
   * TrustedDevice create
   */
  export type TrustedDeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a TrustedDevice.
     */
    data: XOR<TrustedDeviceCreateInput, TrustedDeviceUncheckedCreateInput>
  }

  /**
   * TrustedDevice createMany
   */
  export type TrustedDeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrustedDevices.
     */
    data: TrustedDeviceCreateManyInput | TrustedDeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrustedDevice createManyAndReturn
   */
  export type TrustedDeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * The data used to create many TrustedDevices.
     */
    data: TrustedDeviceCreateManyInput | TrustedDeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrustedDevice update
   */
  export type TrustedDeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a TrustedDevice.
     */
    data: XOR<TrustedDeviceUpdateInput, TrustedDeviceUncheckedUpdateInput>
    /**
     * Choose, which TrustedDevice to update.
     */
    where: TrustedDeviceWhereUniqueInput
  }

  /**
   * TrustedDevice updateMany
   */
  export type TrustedDeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrustedDevices.
     */
    data: XOR<TrustedDeviceUpdateManyMutationInput, TrustedDeviceUncheckedUpdateManyInput>
    /**
     * Filter which TrustedDevices to update
     */
    where?: TrustedDeviceWhereInput
    /**
     * Limit how many TrustedDevices to update.
     */
    limit?: number
  }

  /**
   * TrustedDevice updateManyAndReturn
   */
  export type TrustedDeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * The data used to update TrustedDevices.
     */
    data: XOR<TrustedDeviceUpdateManyMutationInput, TrustedDeviceUncheckedUpdateManyInput>
    /**
     * Filter which TrustedDevices to update
     */
    where?: TrustedDeviceWhereInput
    /**
     * Limit how many TrustedDevices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrustedDevice upsert
   */
  export type TrustedDeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the TrustedDevice to update in case it exists.
     */
    where: TrustedDeviceWhereUniqueInput
    /**
     * In case the TrustedDevice found by the `where` argument doesn't exist, create a new TrustedDevice with this data.
     */
    create: XOR<TrustedDeviceCreateInput, TrustedDeviceUncheckedCreateInput>
    /**
     * In case the TrustedDevice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrustedDeviceUpdateInput, TrustedDeviceUncheckedUpdateInput>
  }

  /**
   * TrustedDevice delete
   */
  export type TrustedDeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceInclude<ExtArgs> | null
    /**
     * Filter which TrustedDevice to delete.
     */
    where: TrustedDeviceWhereUniqueInput
  }

  /**
   * TrustedDevice deleteMany
   */
  export type TrustedDeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrustedDevices to delete
     */
    where?: TrustedDeviceWhereInput
    /**
     * Limit how many TrustedDevices to delete.
     */
    limit?: number
  }

  /**
   * TrustedDevice without action
   */
  export type TrustedDeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustedDevice
     */
    select?: TrustedDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustedDevice
     */
    omit?: TrustedDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustedDeviceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    authProvider: 'authProvider',
    authId: 'authId',
    username: 'username',
    nickname: 'nickname',
    profilePictureUrl: 'profilePictureUrl',
    bio: 'bio',
    gender: 'gender',
    birthDate: 'birthDate',
    country: 'country',
    region: 'region',
    level: 'level',
    vipLevel: 'vipLevel',
    coins: 'coins',
    diamonds: 'diamonds',
    email: 'email',
    password: 'password',
    passwordChangedAt: 'passwordChangedAt',
    isEmailVerified: 'isEmailVerified',
    lastLoginAt: 'lastLoginAt',
    followingCount: 'followingCount',
    followerCount: 'followerCount',
    status: 'status',
    isOnline: 'isOnline',
    preferences: 'preferences',
    allowDirectMessages: 'allowDirectMessages',
    notificationSettings: 'notificationSettings',
    blockedUserIds: 'blockedUserIds',
    accountStatus: 'accountStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    role: 'role',
    isPrivate: 'isPrivate',
    pinnedMessagesInRooms: 'pinnedMessagesInRooms',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorRecoveryCodes: 'twoFactorRecoveryCodes',
    emailVerificationToken: 'emailVerificationToken',
    emailVerificationExpiresAt: 'emailVerificationExpiresAt',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpiresAt: 'passwordResetExpiresAt',
    postCount: 'postCount',
    invitedByForeignKey: 'invitedByForeignKey'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ChatRoomScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    title: 'title',
    description: 'description',
    coverImageUrl: 'coverImageUrl',
    type: 'type',
    passwordHash: 'passwordHash',
    maxParticipants: 'maxParticipants',
    currentParticipantCount: 'currentParticipantCount',
    activeParticipants: 'activeParticipants',
    moderators: 'moderators',
    speakerSeatCount: 'speakerSeatCount',
    speakerSeatAssignments: 'speakerSeatAssignments',
    rtcChannelName: 'rtcChannelName',
    tags: 'tags',
    status: 'status',
    pinnedMessageIds: 'pinnedMessageIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatRoomScalarFieldEnum = (typeof ChatRoomScalarFieldEnum)[keyof typeof ChatRoomScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    receiverId: 'receiverId',
    roomId: 'roomId',
    messageType: 'messageType',
    content: 'content',
    giftId: 'giftId',
    readStatus: 'readStatus',
    isDeletedFor: 'isDeletedFor',
    isPinned: 'isPinned',
    reactions: 'reactions',
    createdAt: 'createdAt',
    repliedToMessageId: 'repliedToMessageId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    transactionType: 'transactionType',
    amount: 'amount',
    currency: 'currency',
    relatedEntityId: 'relatedEntityId',
    relatedEntityType: 'relatedEntityType',
    description: 'description',
    platform: 'platform',
    platformTransactionId: 'platformTransactionId',
    status: 'status',
    paymentGatewayToken: 'paymentGatewayToken',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followingId: 'followingId',
    createdAt: 'createdAt'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const FollowRequestScalarFieldEnum: {
    id: 'id',
    requesterId: 'requesterId',
    recipientId: 'recipientId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FollowRequestScalarFieldEnum = (typeof FollowRequestScalarFieldEnum)[keyof typeof FollowRequestScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    name: 'name',
    description: 'description',
    iconUrl: 'iconUrl',
    entryCost: 'entryCost',
    rewardStructure: 'rewardStructure',
    isActive: 'isActive',
    developer: 'developer',
    publisher: 'publisher',
    releaseDate: 'releaseDate',
    platformCompat: 'platformCompat',
    likeCount: 'likeCount',
    playCount: 'playCount',
    averageRating: 'averageRating',
    ratingCount: 'ratingCount',
    createdAt: 'createdAt',
    categoryId: 'categoryId'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const GenreTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt'
  };

  export type GenreTagScalarFieldEnum = (typeof GenreTagScalarFieldEnum)[keyof typeof GenreTagScalarFieldEnum]


  export const GameGenreTagScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    genreTagId: 'genreTagId',
    assignedAt: 'assignedAt'
  };

  export type GameGenreTagScalarFieldEnum = (typeof GameGenreTagScalarFieldEnum)[keyof typeof GameGenreTagScalarFieldEnum]


  export const GameLikeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gameId: 'gameId',
    createdAt: 'createdAt'
  };

  export type GameLikeScalarFieldEnum = (typeof GameLikeScalarFieldEnum)[keyof typeof GameLikeScalarFieldEnum]


  export const GameRatingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gameId: 'gameId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameRatingScalarFieldEnum = (typeof GameRatingScalarFieldEnum)[keyof typeof GameRatingScalarFieldEnum]


  export const GameCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    iconUrl: 'iconUrl',
    createdAt: 'createdAt'
  };

  export type GameCategoryScalarFieldEnum = (typeof GameCategoryScalarFieldEnum)[keyof typeof GameCategoryScalarFieldEnum]


  export const GameSessionScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    hostId: 'hostId',
    participants: 'participants',
    viewerIds: 'viewerIds',
    maxPlayers: 'maxPlayers',
    currentPlayers: 'currentPlayers',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type GameSessionScalarFieldEnum = (typeof GameSessionScalarFieldEnum)[keyof typeof GameSessionScalarFieldEnum]


  export const GiftScalarFieldEnum: {
    id: 'id',
    giftId: 'giftId',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    animationUrl: 'animationUrl',
    cost: 'cost',
    value: 'value',
    category: 'category',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type GiftScalarFieldEnum = (typeof GiftScalarFieldEnum)[keyof typeof GiftScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    reporterId: 'reporterId',
    reportedUserId: 'reportedUserId',
    reportedStreamId: 'reportedStreamId',
    reportedRoomId: 'reportedRoomId',
    reportedMessageId: 'reportedMessageId',
    reason: 'reason',
    description: 'description',
    status: 'status',
    reviewedById: 'reviewedById',
    reviewTimestamp: 'reviewTimestamp',
    createdAt: 'createdAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    recipientId: 'recipientId',
    senderId: 'senderId',
    type: 'type',
    relatedEntityId: 'relatedEntityId',
    relatedEntityType: 'relatedEntityType',
    content: 'content',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const StreamScalarFieldEnum: {
    id: 'id',
    broadcasterId: 'broadcasterId',
    title: 'title',
    coverImageUrl: 'coverImageUrl',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    currentViewers: 'currentViewers',
    peakViewers: 'peakViewers',
    totalDiamondsReceived: 'totalDiamondsReceived',
    tags: 'tags',
    location: 'location',
    rtcChannelName: 'rtcChannelName',
    recordingUrl: 'recordingUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StreamScalarFieldEnum = (typeof StreamScalarFieldEnum)[keyof typeof StreamScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    revokedAt: 'revokedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    lastUsedAt: 'lastUsedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const OneSignalPlayerScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    userId: 'userId',
    deviceInfo: 'deviceInfo',
    lastSeen: 'lastSeen',
    createdAt: 'createdAt'
  };

  export type OneSignalPlayerScalarFieldEnum = (typeof OneSignalPlayerScalarFieldEnum)[keyof typeof OneSignalPlayerScalarFieldEnum]


  export const TrustedDeviceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceName: 'deviceName',
    deviceType: 'deviceType',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    location: 'location',
    isCurrentDevice: 'isCurrentDevice',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt'
  };

  export type TrustedDeviceScalarFieldEnum = (typeof TrustedDeviceScalarFieldEnum)[keyof typeof TrustedDeviceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserGender'
   */
  export type EnumUserGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserGender'>
    


  /**
   * Reference to a field of type 'UserGender[]'
   */
  export type ListEnumUserGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserGender[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'UserAccountStatus'
   */
  export type EnumUserAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserAccountStatus'>
    


  /**
   * Reference to a field of type 'UserAccountStatus[]'
   */
  export type ListEnumUserAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserAccountStatus[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'ChatRoomType'
   */
  export type EnumChatRoomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatRoomType'>
    


  /**
   * Reference to a field of type 'ChatRoomType[]'
   */
  export type ListEnumChatRoomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatRoomType[]'>
    


  /**
   * Reference to a field of type 'ChatRoomStatus'
   */
  export type EnumChatRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatRoomStatus'>
    


  /**
   * Reference to a field of type 'ChatRoomStatus[]'
   */
  export type ListEnumChatRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatRoomStatus[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'FollowRequestStatus'
   */
  export type EnumFollowRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowRequestStatus'>
    


  /**
   * Reference to a field of type 'FollowRequestStatus[]'
   */
  export type ListEnumFollowRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowRequestStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'GameSessionStatus'
   */
  export type EnumGameSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameSessionStatus'>
    


  /**
   * Reference to a field of type 'GameSessionStatus[]'
   */
  export type ListEnumGameSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameSessionStatus[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'StreamStatus'
   */
  export type EnumStreamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StreamStatus'>
    


  /**
   * Reference to a field of type 'StreamStatus[]'
   */
  export type ListEnumStreamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StreamStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    authProvider?: StringNullableFilter<"User"> | string | null
    authId?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    nickname?: StringNullableFilter<"User"> | string | null
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    gender?: EnumUserGenderNullableFilter<"User"> | $Enums.UserGender | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    country?: StringNullableFilter<"User"> | string | null
    region?: StringNullableFilter<"User"> | string | null
    level?: IntFilter<"User"> | number
    vipLevel?: IntFilter<"User"> | number
    coins?: BigIntFilter<"User"> | bigint | number
    diamonds?: BigIntFilter<"User"> | bigint | number
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isEmailVerified?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    followingCount?: IntFilter<"User"> | number
    followerCount?: IntFilter<"User"> | number
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    isOnline?: BoolFilter<"User"> | boolean
    preferences?: JsonNullableFilter<"User">
    allowDirectMessages?: BoolFilter<"User"> | boolean
    notificationSettings?: JsonNullableFilter<"User">
    blockedUserIds?: JsonNullableFilter<"User">
    accountStatus?: EnumUserAccountStatusFilter<"User"> | $Enums.UserAccountStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isPrivate?: BoolFilter<"User"> | boolean
    pinnedMessagesInRooms?: JsonNullableFilter<"User">
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorRecoveryCodes?: JsonNullableFilter<"User">
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    emailVerificationExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    postCount?: IntFilter<"User"> | number
    invitedByForeignKey?: StringNullableFilter<"User"> | string | null
    invitedUsers?: UserListRelationFilter
    invitedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    trustedDevices?: TrustedDeviceListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    oneSignalPlayers?: OneSignalPlayerListRelationFilter
    transactions?: TransactionListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    reportsMade?: ReportListRelationFilter
    reportsReceived?: ReportListRelationFilter
    reviewedReports?: ReportListRelationFilter
    hostedGameSessions?: GameSessionListRelationFilter
    streams?: StreamListRelationFilter
    ownedChatRooms?: ChatRoomListRelationFilter
    sentFollowRequests?: FollowRequestListRelationFilter
    receivedFollowRequests?: FollowRequestListRelationFilter
    followedBy?: FollowListRelationFilter
    following?: FollowListRelationFilter
    likedGames?: GameLikeListRelationFilter
    gameRatings?: GameRatingListRelationFilter
    notifications?: NotificationListRelationFilter
    sentNotifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    authProvider?: SortOrderInput | SortOrder
    authId?: SortOrderInput | SortOrder
    username?: SortOrder
    nickname?: SortOrderInput | SortOrder
    profilePictureUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    level?: SortOrder
    vipLevel?: SortOrder
    coins?: SortOrder
    diamonds?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    followingCount?: SortOrder
    followerCount?: SortOrder
    status?: SortOrder
    isOnline?: SortOrder
    preferences?: SortOrderInput | SortOrder
    allowDirectMessages?: SortOrder
    notificationSettings?: SortOrderInput | SortOrder
    blockedUserIds?: SortOrderInput | SortOrder
    accountStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    isPrivate?: SortOrder
    pinnedMessagesInRooms?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorRecoveryCodes?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerificationExpiresAt?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpiresAt?: SortOrderInput | SortOrder
    postCount?: SortOrder
    invitedByForeignKey?: SortOrderInput | SortOrder
    invitedUsers?: UserOrderByRelationAggregateInput
    invitedBy?: UserOrderByWithRelationInput
    trustedDevices?: TrustedDeviceOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    oneSignalPlayers?: OneSignalPlayerOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    reportsMade?: ReportOrderByRelationAggregateInput
    reportsReceived?: ReportOrderByRelationAggregateInput
    reviewedReports?: ReportOrderByRelationAggregateInput
    hostedGameSessions?: GameSessionOrderByRelationAggregateInput
    streams?: StreamOrderByRelationAggregateInput
    ownedChatRooms?: ChatRoomOrderByRelationAggregateInput
    sentFollowRequests?: FollowRequestOrderByRelationAggregateInput
    receivedFollowRequests?: FollowRequestOrderByRelationAggregateInput
    followedBy?: FollowOrderByRelationAggregateInput
    following?: FollowOrderByRelationAggregateInput
    likedGames?: GameLikeOrderByRelationAggregateInput
    gameRatings?: GameRatingOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    sentNotifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    authId?: string
    username?: string
    email?: string
    emailVerificationToken?: string
    passwordResetToken?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    authProvider?: StringNullableFilter<"User"> | string | null
    nickname?: StringNullableFilter<"User"> | string | null
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    gender?: EnumUserGenderNullableFilter<"User"> | $Enums.UserGender | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    country?: StringNullableFilter<"User"> | string | null
    region?: StringNullableFilter<"User"> | string | null
    level?: IntFilter<"User"> | number
    vipLevel?: IntFilter<"User"> | number
    coins?: BigIntFilter<"User"> | bigint | number
    diamonds?: BigIntFilter<"User"> | bigint | number
    password?: StringNullableFilter<"User"> | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isEmailVerified?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    followingCount?: IntFilter<"User"> | number
    followerCount?: IntFilter<"User"> | number
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    isOnline?: BoolFilter<"User"> | boolean
    preferences?: JsonNullableFilter<"User">
    allowDirectMessages?: BoolFilter<"User"> | boolean
    notificationSettings?: JsonNullableFilter<"User">
    blockedUserIds?: JsonNullableFilter<"User">
    accountStatus?: EnumUserAccountStatusFilter<"User"> | $Enums.UserAccountStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isPrivate?: BoolFilter<"User"> | boolean
    pinnedMessagesInRooms?: JsonNullableFilter<"User">
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorRecoveryCodes?: JsonNullableFilter<"User">
    emailVerificationExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    postCount?: IntFilter<"User"> | number
    invitedByForeignKey?: StringNullableFilter<"User"> | string | null
    invitedUsers?: UserListRelationFilter
    invitedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    trustedDevices?: TrustedDeviceListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    oneSignalPlayers?: OneSignalPlayerListRelationFilter
    transactions?: TransactionListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    reportsMade?: ReportListRelationFilter
    reportsReceived?: ReportListRelationFilter
    reviewedReports?: ReportListRelationFilter
    hostedGameSessions?: GameSessionListRelationFilter
    streams?: StreamListRelationFilter
    ownedChatRooms?: ChatRoomListRelationFilter
    sentFollowRequests?: FollowRequestListRelationFilter
    receivedFollowRequests?: FollowRequestListRelationFilter
    followedBy?: FollowListRelationFilter
    following?: FollowListRelationFilter
    likedGames?: GameLikeListRelationFilter
    gameRatings?: GameRatingListRelationFilter
    notifications?: NotificationListRelationFilter
    sentNotifications?: NotificationListRelationFilter
  }, "id" | "authId" | "username" | "email" | "emailVerificationToken" | "passwordResetToken">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    authProvider?: SortOrderInput | SortOrder
    authId?: SortOrderInput | SortOrder
    username?: SortOrder
    nickname?: SortOrderInput | SortOrder
    profilePictureUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    level?: SortOrder
    vipLevel?: SortOrder
    coins?: SortOrder
    diamonds?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    followingCount?: SortOrder
    followerCount?: SortOrder
    status?: SortOrder
    isOnline?: SortOrder
    preferences?: SortOrderInput | SortOrder
    allowDirectMessages?: SortOrder
    notificationSettings?: SortOrderInput | SortOrder
    blockedUserIds?: SortOrderInput | SortOrder
    accountStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    isPrivate?: SortOrder
    pinnedMessagesInRooms?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorRecoveryCodes?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerificationExpiresAt?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpiresAt?: SortOrderInput | SortOrder
    postCount?: SortOrder
    invitedByForeignKey?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    authProvider?: StringNullableWithAggregatesFilter<"User"> | string | null
    authId?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    nickname?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePictureUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: EnumUserGenderNullableWithAggregatesFilter<"User"> | $Enums.UserGender | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    region?: StringNullableWithAggregatesFilter<"User"> | string | null
    level?: IntWithAggregatesFilter<"User"> | number
    vipLevel?: IntWithAggregatesFilter<"User"> | number
    coins?: BigIntWithAggregatesFilter<"User"> | bigint | number
    diamonds?: BigIntWithAggregatesFilter<"User"> | bigint | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordChangedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    followingCount?: IntWithAggregatesFilter<"User"> | number
    followerCount?: IntWithAggregatesFilter<"User"> | number
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    isOnline?: BoolWithAggregatesFilter<"User"> | boolean
    preferences?: JsonNullableWithAggregatesFilter<"User">
    allowDirectMessages?: BoolWithAggregatesFilter<"User"> | boolean
    notificationSettings?: JsonNullableWithAggregatesFilter<"User">
    blockedUserIds?: JsonNullableWithAggregatesFilter<"User">
    accountStatus?: EnumUserAccountStatusWithAggregatesFilter<"User"> | $Enums.UserAccountStatus
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isPrivate?: BoolWithAggregatesFilter<"User"> | boolean
    pinnedMessagesInRooms?: JsonNullableWithAggregatesFilter<"User">
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorRecoveryCodes?: JsonNullableWithAggregatesFilter<"User">
    emailVerificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerificationExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    postCount?: IntWithAggregatesFilter<"User"> | number
    invitedByForeignKey?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ChatRoomWhereInput = {
    AND?: ChatRoomWhereInput | ChatRoomWhereInput[]
    OR?: ChatRoomWhereInput[]
    NOT?: ChatRoomWhereInput | ChatRoomWhereInput[]
    id?: StringFilter<"ChatRoom"> | string
    ownerId?: StringFilter<"ChatRoom"> | string
    title?: StringFilter<"ChatRoom"> | string
    description?: StringNullableFilter<"ChatRoom"> | string | null
    coverImageUrl?: StringNullableFilter<"ChatRoom"> | string | null
    type?: EnumChatRoomTypeFilter<"ChatRoom"> | $Enums.ChatRoomType
    passwordHash?: StringNullableFilter<"ChatRoom"> | string | null
    maxParticipants?: IntFilter<"ChatRoom"> | number
    currentParticipantCount?: IntFilter<"ChatRoom"> | number
    activeParticipants?: JsonNullableFilter<"ChatRoom">
    moderators?: JsonNullableFilter<"ChatRoom">
    speakerSeatCount?: IntFilter<"ChatRoom"> | number
    speakerSeatAssignments?: JsonNullableFilter<"ChatRoom">
    rtcChannelName?: StringNullableFilter<"ChatRoom"> | string | null
    tags?: JsonNullableFilter<"ChatRoom">
    status?: EnumChatRoomStatusFilter<"ChatRoom"> | $Enums.ChatRoomStatus
    pinnedMessageIds?: JsonNullableFilter<"ChatRoom">
    createdAt?: DateTimeFilter<"ChatRoom"> | Date | string
    updatedAt?: DateTimeFilter<"ChatRoom"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    reports?: ReportListRelationFilter
  }

  export type ChatRoomOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    coverImageUrl?: SortOrderInput | SortOrder
    type?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    maxParticipants?: SortOrder
    currentParticipantCount?: SortOrder
    activeParticipants?: SortOrderInput | SortOrder
    moderators?: SortOrderInput | SortOrder
    speakerSeatCount?: SortOrder
    speakerSeatAssignments?: SortOrderInput | SortOrder
    rtcChannelName?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    status?: SortOrder
    pinnedMessageIds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
  }

  export type ChatRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatRoomWhereInput | ChatRoomWhereInput[]
    OR?: ChatRoomWhereInput[]
    NOT?: ChatRoomWhereInput | ChatRoomWhereInput[]
    ownerId?: StringFilter<"ChatRoom"> | string
    title?: StringFilter<"ChatRoom"> | string
    description?: StringNullableFilter<"ChatRoom"> | string | null
    coverImageUrl?: StringNullableFilter<"ChatRoom"> | string | null
    type?: EnumChatRoomTypeFilter<"ChatRoom"> | $Enums.ChatRoomType
    passwordHash?: StringNullableFilter<"ChatRoom"> | string | null
    maxParticipants?: IntFilter<"ChatRoom"> | number
    currentParticipantCount?: IntFilter<"ChatRoom"> | number
    activeParticipants?: JsonNullableFilter<"ChatRoom">
    moderators?: JsonNullableFilter<"ChatRoom">
    speakerSeatCount?: IntFilter<"ChatRoom"> | number
    speakerSeatAssignments?: JsonNullableFilter<"ChatRoom">
    rtcChannelName?: StringNullableFilter<"ChatRoom"> | string | null
    tags?: JsonNullableFilter<"ChatRoom">
    status?: EnumChatRoomStatusFilter<"ChatRoom"> | $Enums.ChatRoomStatus
    pinnedMessageIds?: JsonNullableFilter<"ChatRoom">
    createdAt?: DateTimeFilter<"ChatRoom"> | Date | string
    updatedAt?: DateTimeFilter<"ChatRoom"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    reports?: ReportListRelationFilter
  }, "id">

  export type ChatRoomOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    coverImageUrl?: SortOrderInput | SortOrder
    type?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    maxParticipants?: SortOrder
    currentParticipantCount?: SortOrder
    activeParticipants?: SortOrderInput | SortOrder
    moderators?: SortOrderInput | SortOrder
    speakerSeatCount?: SortOrder
    speakerSeatAssignments?: SortOrderInput | SortOrder
    rtcChannelName?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    status?: SortOrder
    pinnedMessageIds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatRoomCountOrderByAggregateInput
    _avg?: ChatRoomAvgOrderByAggregateInput
    _max?: ChatRoomMaxOrderByAggregateInput
    _min?: ChatRoomMinOrderByAggregateInput
    _sum?: ChatRoomSumOrderByAggregateInput
  }

  export type ChatRoomScalarWhereWithAggregatesInput = {
    AND?: ChatRoomScalarWhereWithAggregatesInput | ChatRoomScalarWhereWithAggregatesInput[]
    OR?: ChatRoomScalarWhereWithAggregatesInput[]
    NOT?: ChatRoomScalarWhereWithAggregatesInput | ChatRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatRoom"> | string
    ownerId?: StringWithAggregatesFilter<"ChatRoom"> | string
    title?: StringWithAggregatesFilter<"ChatRoom"> | string
    description?: StringNullableWithAggregatesFilter<"ChatRoom"> | string | null
    coverImageUrl?: StringNullableWithAggregatesFilter<"ChatRoom"> | string | null
    type?: EnumChatRoomTypeWithAggregatesFilter<"ChatRoom"> | $Enums.ChatRoomType
    passwordHash?: StringNullableWithAggregatesFilter<"ChatRoom"> | string | null
    maxParticipants?: IntWithAggregatesFilter<"ChatRoom"> | number
    currentParticipantCount?: IntWithAggregatesFilter<"ChatRoom"> | number
    activeParticipants?: JsonNullableWithAggregatesFilter<"ChatRoom">
    moderators?: JsonNullableWithAggregatesFilter<"ChatRoom">
    speakerSeatCount?: IntWithAggregatesFilter<"ChatRoom"> | number
    speakerSeatAssignments?: JsonNullableWithAggregatesFilter<"ChatRoom">
    rtcChannelName?: StringNullableWithAggregatesFilter<"ChatRoom"> | string | null
    tags?: JsonNullableWithAggregatesFilter<"ChatRoom">
    status?: EnumChatRoomStatusWithAggregatesFilter<"ChatRoom"> | $Enums.ChatRoomStatus
    pinnedMessageIds?: JsonNullableWithAggregatesFilter<"ChatRoom">
    createdAt?: DateTimeWithAggregatesFilter<"ChatRoom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatRoom"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringNullableFilter<"Message"> | string | null
    roomId?: StringNullableFilter<"Message"> | string | null
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    content?: StringNullableFilter<"Message"> | string | null
    giftId?: StringNullableFilter<"Message"> | string | null
    readStatus?: JsonNullableFilter<"Message">
    isDeletedFor?: JsonNullableFilter<"Message">
    isPinned?: BoolFilter<"Message"> | boolean
    reactions?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    repliedToMessageId?: StringNullableFilter<"Message"> | string | null
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    room?: XOR<ChatRoomNullableScalarRelationFilter, ChatRoomWhereInput> | null
    gift?: XOR<GiftNullableScalarRelationFilter, GiftWhereInput> | null
    repliedToMessage?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    replies?: MessageListRelationFilter
    reports?: ReportListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    messageType?: SortOrder
    content?: SortOrderInput | SortOrder
    giftId?: SortOrderInput | SortOrder
    readStatus?: SortOrderInput | SortOrder
    isDeletedFor?: SortOrderInput | SortOrder
    isPinned?: SortOrder
    reactions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    repliedToMessageId?: SortOrderInput | SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
    room?: ChatRoomOrderByWithRelationInput
    gift?: GiftOrderByWithRelationInput
    repliedToMessage?: MessageOrderByWithRelationInput
    replies?: MessageOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringNullableFilter<"Message"> | string | null
    roomId?: StringNullableFilter<"Message"> | string | null
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    content?: StringNullableFilter<"Message"> | string | null
    giftId?: StringNullableFilter<"Message"> | string | null
    readStatus?: JsonNullableFilter<"Message">
    isDeletedFor?: JsonNullableFilter<"Message">
    isPinned?: BoolFilter<"Message"> | boolean
    reactions?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    repliedToMessageId?: StringNullableFilter<"Message"> | string | null
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    room?: XOR<ChatRoomNullableScalarRelationFilter, ChatRoomWhereInput> | null
    gift?: XOR<GiftNullableScalarRelationFilter, GiftWhereInput> | null
    repliedToMessage?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    replies?: MessageListRelationFilter
    reports?: ReportListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    messageType?: SortOrder
    content?: SortOrderInput | SortOrder
    giftId?: SortOrderInput | SortOrder
    readStatus?: SortOrderInput | SortOrder
    isDeletedFor?: SortOrderInput | SortOrder
    isPinned?: SortOrder
    reactions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    repliedToMessageId?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    receiverId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    roomId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    messageType?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    content?: StringNullableWithAggregatesFilter<"Message"> | string | null
    giftId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    readStatus?: JsonNullableWithAggregatesFilter<"Message">
    isDeletedFor?: JsonNullableWithAggregatesFilter<"Message">
    isPinned?: BoolWithAggregatesFilter<"Message"> | boolean
    reactions?: JsonNullableWithAggregatesFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    repliedToMessageId?: StringNullableWithAggregatesFilter<"Message"> | string | null
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    transactionType?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Transaction"> | string
    relatedEntityId?: StringNullableFilter<"Transaction"> | string | null
    relatedEntityType?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    platform?: StringNullableFilter<"Transaction"> | string | null
    platformTransactionId?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    paymentGatewayToken?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    relatedEntityType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    platformTransactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentGatewayToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    platformTransactionId?: string
    paymentGatewayToken?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    transactionType?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Transaction"> | string
    relatedEntityId?: StringNullableFilter<"Transaction"> | string | null
    relatedEntityType?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    platform?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "platformTransactionId" | "paymentGatewayToken">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    relatedEntityType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    platformTransactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentGatewayToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    relatedEntityId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    relatedEntityType?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    platform?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    platformTransactionId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    paymentGatewayToken?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerId_followingId?: FollowFollowerIdFollowingIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "followerId_followingId">

  export type FollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Follow"> | string
    followerId?: StringWithAggregatesFilter<"Follow"> | string
    followingId?: StringWithAggregatesFilter<"Follow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
  }

  export type FollowRequestWhereInput = {
    AND?: FollowRequestWhereInput | FollowRequestWhereInput[]
    OR?: FollowRequestWhereInput[]
    NOT?: FollowRequestWhereInput | FollowRequestWhereInput[]
    id?: StringFilter<"FollowRequest"> | string
    requesterId?: StringFilter<"FollowRequest"> | string
    recipientId?: StringFilter<"FollowRequest"> | string
    status?: EnumFollowRequestStatusFilter<"FollowRequest"> | $Enums.FollowRequestStatus
    createdAt?: DateTimeFilter<"FollowRequest"> | Date | string
    updatedAt?: DateTimeFilter<"FollowRequest"> | Date | string
    requester?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FollowRequestOrderByWithRelationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    recipientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requester?: UserOrderByWithRelationInput
    recipient?: UserOrderByWithRelationInput
  }

  export type FollowRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    requesterId_recipientId?: FollowRequestRequesterIdRecipientIdCompoundUniqueInput
    AND?: FollowRequestWhereInput | FollowRequestWhereInput[]
    OR?: FollowRequestWhereInput[]
    NOT?: FollowRequestWhereInput | FollowRequestWhereInput[]
    requesterId?: StringFilter<"FollowRequest"> | string
    recipientId?: StringFilter<"FollowRequest"> | string
    status?: EnumFollowRequestStatusFilter<"FollowRequest"> | $Enums.FollowRequestStatus
    createdAt?: DateTimeFilter<"FollowRequest"> | Date | string
    updatedAt?: DateTimeFilter<"FollowRequest"> | Date | string
    requester?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "requesterId_recipientId">

  export type FollowRequestOrderByWithAggregationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    recipientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FollowRequestCountOrderByAggregateInput
    _max?: FollowRequestMaxOrderByAggregateInput
    _min?: FollowRequestMinOrderByAggregateInput
  }

  export type FollowRequestScalarWhereWithAggregatesInput = {
    AND?: FollowRequestScalarWhereWithAggregatesInput | FollowRequestScalarWhereWithAggregatesInput[]
    OR?: FollowRequestScalarWhereWithAggregatesInput[]
    NOT?: FollowRequestScalarWhereWithAggregatesInput | FollowRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FollowRequest"> | string
    requesterId?: StringWithAggregatesFilter<"FollowRequest"> | string
    recipientId?: StringWithAggregatesFilter<"FollowRequest"> | string
    status?: EnumFollowRequestStatusWithAggregatesFilter<"FollowRequest"> | $Enums.FollowRequestStatus
    createdAt?: DateTimeWithAggregatesFilter<"FollowRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FollowRequest"> | Date | string
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    gameId?: StringFilter<"Game"> | string
    name?: StringFilter<"Game"> | string
    description?: StringNullableFilter<"Game"> | string | null
    iconUrl?: StringNullableFilter<"Game"> | string | null
    entryCost?: BigIntFilter<"Game"> | bigint | number
    rewardStructure?: JsonNullableFilter<"Game">
    isActive?: BoolFilter<"Game"> | boolean
    developer?: StringNullableFilter<"Game"> | string | null
    publisher?: StringNullableFilter<"Game"> | string | null
    releaseDate?: DateTimeNullableFilter<"Game"> | Date | string | null
    platformCompat?: JsonNullableFilter<"Game">
    likeCount?: IntFilter<"Game"> | number
    playCount?: IntFilter<"Game"> | number
    averageRating?: FloatFilter<"Game"> | number
    ratingCount?: IntFilter<"Game"> | number
    createdAt?: DateTimeFilter<"Game"> | Date | string
    categoryId?: StringNullableFilter<"Game"> | string | null
    category?: XOR<GameCategoryNullableScalarRelationFilter, GameCategoryWhereInput> | null
    gameGenreTags?: GameGenreTagListRelationFilter
    gameSessions?: GameSessionListRelationFilter
    likes?: GameLikeListRelationFilter
    ratings?: GameRatingListRelationFilter
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    iconUrl?: SortOrderInput | SortOrder
    entryCost?: SortOrder
    rewardStructure?: SortOrderInput | SortOrder
    isActive?: SortOrder
    developer?: SortOrderInput | SortOrder
    publisher?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    platformCompat?: SortOrderInput | SortOrder
    likeCount?: SortOrder
    playCount?: SortOrder
    averageRating?: SortOrder
    ratingCount?: SortOrder
    createdAt?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    category?: GameCategoryOrderByWithRelationInput
    gameGenreTags?: GameGenreTagOrderByRelationAggregateInput
    gameSessions?: GameSessionOrderByRelationAggregateInput
    likes?: GameLikeOrderByRelationAggregateInput
    ratings?: GameRatingOrderByRelationAggregateInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameId?: string
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    name?: StringFilter<"Game"> | string
    description?: StringNullableFilter<"Game"> | string | null
    iconUrl?: StringNullableFilter<"Game"> | string | null
    entryCost?: BigIntFilter<"Game"> | bigint | number
    rewardStructure?: JsonNullableFilter<"Game">
    isActive?: BoolFilter<"Game"> | boolean
    developer?: StringNullableFilter<"Game"> | string | null
    publisher?: StringNullableFilter<"Game"> | string | null
    releaseDate?: DateTimeNullableFilter<"Game"> | Date | string | null
    platformCompat?: JsonNullableFilter<"Game">
    likeCount?: IntFilter<"Game"> | number
    playCount?: IntFilter<"Game"> | number
    averageRating?: FloatFilter<"Game"> | number
    ratingCount?: IntFilter<"Game"> | number
    createdAt?: DateTimeFilter<"Game"> | Date | string
    categoryId?: StringNullableFilter<"Game"> | string | null
    category?: XOR<GameCategoryNullableScalarRelationFilter, GameCategoryWhereInput> | null
    gameGenreTags?: GameGenreTagListRelationFilter
    gameSessions?: GameSessionListRelationFilter
    likes?: GameLikeListRelationFilter
    ratings?: GameRatingListRelationFilter
  }, "id" | "gameId">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    iconUrl?: SortOrderInput | SortOrder
    entryCost?: SortOrder
    rewardStructure?: SortOrderInput | SortOrder
    isActive?: SortOrder
    developer?: SortOrderInput | SortOrder
    publisher?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    platformCompat?: SortOrderInput | SortOrder
    likeCount?: SortOrder
    playCount?: SortOrder
    averageRating?: SortOrder
    ratingCount?: SortOrder
    createdAt?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    gameId?: StringWithAggregatesFilter<"Game"> | string
    name?: StringWithAggregatesFilter<"Game"> | string
    description?: StringNullableWithAggregatesFilter<"Game"> | string | null
    iconUrl?: StringNullableWithAggregatesFilter<"Game"> | string | null
    entryCost?: BigIntWithAggregatesFilter<"Game"> | bigint | number
    rewardStructure?: JsonNullableWithAggregatesFilter<"Game">
    isActive?: BoolWithAggregatesFilter<"Game"> | boolean
    developer?: StringNullableWithAggregatesFilter<"Game"> | string | null
    publisher?: StringNullableWithAggregatesFilter<"Game"> | string | null
    releaseDate?: DateTimeNullableWithAggregatesFilter<"Game"> | Date | string | null
    platformCompat?: JsonNullableWithAggregatesFilter<"Game">
    likeCount?: IntWithAggregatesFilter<"Game"> | number
    playCount?: IntWithAggregatesFilter<"Game"> | number
    averageRating?: FloatWithAggregatesFilter<"Game"> | number
    ratingCount?: IntWithAggregatesFilter<"Game"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    categoryId?: StringNullableWithAggregatesFilter<"Game"> | string | null
  }

  export type GenreTagWhereInput = {
    AND?: GenreTagWhereInput | GenreTagWhereInput[]
    OR?: GenreTagWhereInput[]
    NOT?: GenreTagWhereInput | GenreTagWhereInput[]
    id?: StringFilter<"GenreTag"> | string
    name?: StringFilter<"GenreTag"> | string
    slug?: StringFilter<"GenreTag"> | string
    createdAt?: DateTimeFilter<"GenreTag"> | Date | string
    gameGenreTags?: GameGenreTagListRelationFilter
  }

  export type GenreTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    gameGenreTags?: GameGenreTagOrderByRelationAggregateInput
  }

  export type GenreTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: GenreTagWhereInput | GenreTagWhereInput[]
    OR?: GenreTagWhereInput[]
    NOT?: GenreTagWhereInput | GenreTagWhereInput[]
    createdAt?: DateTimeFilter<"GenreTag"> | Date | string
    gameGenreTags?: GameGenreTagListRelationFilter
  }, "id" | "name" | "slug">

  export type GenreTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    _count?: GenreTagCountOrderByAggregateInput
    _max?: GenreTagMaxOrderByAggregateInput
    _min?: GenreTagMinOrderByAggregateInput
  }

  export type GenreTagScalarWhereWithAggregatesInput = {
    AND?: GenreTagScalarWhereWithAggregatesInput | GenreTagScalarWhereWithAggregatesInput[]
    OR?: GenreTagScalarWhereWithAggregatesInput[]
    NOT?: GenreTagScalarWhereWithAggregatesInput | GenreTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GenreTag"> | string
    name?: StringWithAggregatesFilter<"GenreTag"> | string
    slug?: StringWithAggregatesFilter<"GenreTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GenreTag"> | Date | string
  }

  export type GameGenreTagWhereInput = {
    AND?: GameGenreTagWhereInput | GameGenreTagWhereInput[]
    OR?: GameGenreTagWhereInput[]
    NOT?: GameGenreTagWhereInput | GameGenreTagWhereInput[]
    id?: StringFilter<"GameGenreTag"> | string
    gameId?: StringFilter<"GameGenreTag"> | string
    genreTagId?: StringFilter<"GameGenreTag"> | string
    assignedAt?: DateTimeFilter<"GameGenreTag"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    genreTag?: XOR<GenreTagScalarRelationFilter, GenreTagWhereInput>
  }

  export type GameGenreTagOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    genreTagId?: SortOrder
    assignedAt?: SortOrder
    game?: GameOrderByWithRelationInput
    genreTag?: GenreTagOrderByWithRelationInput
  }

  export type GameGenreTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameId_genreTagId?: GameGenreTagGameIdGenreTagIdCompoundUniqueInput
    AND?: GameGenreTagWhereInput | GameGenreTagWhereInput[]
    OR?: GameGenreTagWhereInput[]
    NOT?: GameGenreTagWhereInput | GameGenreTagWhereInput[]
    gameId?: StringFilter<"GameGenreTag"> | string
    genreTagId?: StringFilter<"GameGenreTag"> | string
    assignedAt?: DateTimeFilter<"GameGenreTag"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    genreTag?: XOR<GenreTagScalarRelationFilter, GenreTagWhereInput>
  }, "id" | "gameId_genreTagId">

  export type GameGenreTagOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    genreTagId?: SortOrder
    assignedAt?: SortOrder
    _count?: GameGenreTagCountOrderByAggregateInput
    _max?: GameGenreTagMaxOrderByAggregateInput
    _min?: GameGenreTagMinOrderByAggregateInput
  }

  export type GameGenreTagScalarWhereWithAggregatesInput = {
    AND?: GameGenreTagScalarWhereWithAggregatesInput | GameGenreTagScalarWhereWithAggregatesInput[]
    OR?: GameGenreTagScalarWhereWithAggregatesInput[]
    NOT?: GameGenreTagScalarWhereWithAggregatesInput | GameGenreTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameGenreTag"> | string
    gameId?: StringWithAggregatesFilter<"GameGenreTag"> | string
    genreTagId?: StringWithAggregatesFilter<"GameGenreTag"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"GameGenreTag"> | Date | string
  }

  export type GameLikeWhereInput = {
    AND?: GameLikeWhereInput | GameLikeWhereInput[]
    OR?: GameLikeWhereInput[]
    NOT?: GameLikeWhereInput | GameLikeWhereInput[]
    id?: StringFilter<"GameLike"> | string
    userId?: StringFilter<"GameLike"> | string
    gameId?: StringFilter<"GameLike"> | string
    createdAt?: DateTimeFilter<"GameLike"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }

  export type GameLikeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type GameLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_gameId?: GameLikeUserIdGameIdCompoundUniqueInput
    AND?: GameLikeWhereInput | GameLikeWhereInput[]
    OR?: GameLikeWhereInput[]
    NOT?: GameLikeWhereInput | GameLikeWhereInput[]
    userId?: StringFilter<"GameLike"> | string
    gameId?: StringFilter<"GameLike"> | string
    createdAt?: DateTimeFilter<"GameLike"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }, "id" | "userId_gameId">

  export type GameLikeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
    _count?: GameLikeCountOrderByAggregateInput
    _max?: GameLikeMaxOrderByAggregateInput
    _min?: GameLikeMinOrderByAggregateInput
  }

  export type GameLikeScalarWhereWithAggregatesInput = {
    AND?: GameLikeScalarWhereWithAggregatesInput | GameLikeScalarWhereWithAggregatesInput[]
    OR?: GameLikeScalarWhereWithAggregatesInput[]
    NOT?: GameLikeScalarWhereWithAggregatesInput | GameLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameLike"> | string
    userId?: StringWithAggregatesFilter<"GameLike"> | string
    gameId?: StringWithAggregatesFilter<"GameLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GameLike"> | Date | string
  }

  export type GameRatingWhereInput = {
    AND?: GameRatingWhereInput | GameRatingWhereInput[]
    OR?: GameRatingWhereInput[]
    NOT?: GameRatingWhereInput | GameRatingWhereInput[]
    id?: StringFilter<"GameRating"> | string
    userId?: StringFilter<"GameRating"> | string
    gameId?: StringFilter<"GameRating"> | string
    rating?: IntFilter<"GameRating"> | number
    comment?: StringNullableFilter<"GameRating"> | string | null
    createdAt?: DateTimeFilter<"GameRating"> | Date | string
    updatedAt?: DateTimeFilter<"GameRating"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }

  export type GameRatingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type GameRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_gameId?: GameRatingUserIdGameIdCompoundUniqueInput
    AND?: GameRatingWhereInput | GameRatingWhereInput[]
    OR?: GameRatingWhereInput[]
    NOT?: GameRatingWhereInput | GameRatingWhereInput[]
    userId?: StringFilter<"GameRating"> | string
    gameId?: StringFilter<"GameRating"> | string
    rating?: IntFilter<"GameRating"> | number
    comment?: StringNullableFilter<"GameRating"> | string | null
    createdAt?: DateTimeFilter<"GameRating"> | Date | string
    updatedAt?: DateTimeFilter<"GameRating"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
  }, "id" | "userId_gameId">

  export type GameRatingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameRatingCountOrderByAggregateInput
    _avg?: GameRatingAvgOrderByAggregateInput
    _max?: GameRatingMaxOrderByAggregateInput
    _min?: GameRatingMinOrderByAggregateInput
    _sum?: GameRatingSumOrderByAggregateInput
  }

  export type GameRatingScalarWhereWithAggregatesInput = {
    AND?: GameRatingScalarWhereWithAggregatesInput | GameRatingScalarWhereWithAggregatesInput[]
    OR?: GameRatingScalarWhereWithAggregatesInput[]
    NOT?: GameRatingScalarWhereWithAggregatesInput | GameRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameRating"> | string
    userId?: StringWithAggregatesFilter<"GameRating"> | string
    gameId?: StringWithAggregatesFilter<"GameRating"> | string
    rating?: IntWithAggregatesFilter<"GameRating"> | number
    comment?: StringNullableWithAggregatesFilter<"GameRating"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GameRating"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameRating"> | Date | string
  }

  export type GameCategoryWhereInput = {
    AND?: GameCategoryWhereInput | GameCategoryWhereInput[]
    OR?: GameCategoryWhereInput[]
    NOT?: GameCategoryWhereInput | GameCategoryWhereInput[]
    id?: StringFilter<"GameCategory"> | string
    name?: StringFilter<"GameCategory"> | string
    slug?: StringFilter<"GameCategory"> | string
    iconUrl?: StringNullableFilter<"GameCategory"> | string | null
    createdAt?: DateTimeFilter<"GameCategory"> | Date | string
    games?: GameListRelationFilter
  }

  export type GameCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    iconUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    games?: GameOrderByRelationAggregateInput
  }

  export type GameCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: GameCategoryWhereInput | GameCategoryWhereInput[]
    OR?: GameCategoryWhereInput[]
    NOT?: GameCategoryWhereInput | GameCategoryWhereInput[]
    iconUrl?: StringNullableFilter<"GameCategory"> | string | null
    createdAt?: DateTimeFilter<"GameCategory"> | Date | string
    games?: GameListRelationFilter
  }, "id" | "name" | "slug">

  export type GameCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    iconUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GameCategoryCountOrderByAggregateInput
    _max?: GameCategoryMaxOrderByAggregateInput
    _min?: GameCategoryMinOrderByAggregateInput
  }

  export type GameCategoryScalarWhereWithAggregatesInput = {
    AND?: GameCategoryScalarWhereWithAggregatesInput | GameCategoryScalarWhereWithAggregatesInput[]
    OR?: GameCategoryScalarWhereWithAggregatesInput[]
    NOT?: GameCategoryScalarWhereWithAggregatesInput | GameCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameCategory"> | string
    name?: StringWithAggregatesFilter<"GameCategory"> | string
    slug?: StringWithAggregatesFilter<"GameCategory"> | string
    iconUrl?: StringNullableWithAggregatesFilter<"GameCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GameCategory"> | Date | string
  }

  export type GameSessionWhereInput = {
    AND?: GameSessionWhereInput | GameSessionWhereInput[]
    OR?: GameSessionWhereInput[]
    NOT?: GameSessionWhereInput | GameSessionWhereInput[]
    id?: StringFilter<"GameSession"> | string
    gameId?: StringFilter<"GameSession"> | string
    hostId?: StringFilter<"GameSession"> | string
    participants?: JsonNullableFilter<"GameSession">
    viewerIds?: JsonNullableFilter<"GameSession">
    maxPlayers?: IntFilter<"GameSession"> | number
    currentPlayers?: IntFilter<"GameSession"> | number
    startTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    status?: EnumGameSessionStatusFilter<"GameSession"> | $Enums.GameSessionStatus
    createdAt?: DateTimeFilter<"GameSession"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    host?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GameSessionOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    hostId?: SortOrder
    participants?: SortOrderInput | SortOrder
    viewerIds?: SortOrderInput | SortOrder
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    game?: GameOrderByWithRelationInput
    host?: UserOrderByWithRelationInput
  }

  export type GameSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameSessionWhereInput | GameSessionWhereInput[]
    OR?: GameSessionWhereInput[]
    NOT?: GameSessionWhereInput | GameSessionWhereInput[]
    gameId?: StringFilter<"GameSession"> | string
    hostId?: StringFilter<"GameSession"> | string
    participants?: JsonNullableFilter<"GameSession">
    viewerIds?: JsonNullableFilter<"GameSession">
    maxPlayers?: IntFilter<"GameSession"> | number
    currentPlayers?: IntFilter<"GameSession"> | number
    startTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    status?: EnumGameSessionStatusFilter<"GameSession"> | $Enums.GameSessionStatus
    createdAt?: DateTimeFilter<"GameSession"> | Date | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    host?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GameSessionOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    hostId?: SortOrder
    participants?: SortOrderInput | SortOrder
    viewerIds?: SortOrderInput | SortOrder
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: GameSessionCountOrderByAggregateInput
    _avg?: GameSessionAvgOrderByAggregateInput
    _max?: GameSessionMaxOrderByAggregateInput
    _min?: GameSessionMinOrderByAggregateInput
    _sum?: GameSessionSumOrderByAggregateInput
  }

  export type GameSessionScalarWhereWithAggregatesInput = {
    AND?: GameSessionScalarWhereWithAggregatesInput | GameSessionScalarWhereWithAggregatesInput[]
    OR?: GameSessionScalarWhereWithAggregatesInput[]
    NOT?: GameSessionScalarWhereWithAggregatesInput | GameSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameSession"> | string
    gameId?: StringWithAggregatesFilter<"GameSession"> | string
    hostId?: StringWithAggregatesFilter<"GameSession"> | string
    participants?: JsonNullableWithAggregatesFilter<"GameSession">
    viewerIds?: JsonNullableWithAggregatesFilter<"GameSession">
    maxPlayers?: IntWithAggregatesFilter<"GameSession"> | number
    currentPlayers?: IntWithAggregatesFilter<"GameSession"> | number
    startTime?: DateTimeNullableWithAggregatesFilter<"GameSession"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"GameSession"> | Date | string | null
    status?: EnumGameSessionStatusWithAggregatesFilter<"GameSession"> | $Enums.GameSessionStatus
    createdAt?: DateTimeWithAggregatesFilter<"GameSession"> | Date | string
  }

  export type GiftWhereInput = {
    AND?: GiftWhereInput | GiftWhereInput[]
    OR?: GiftWhereInput[]
    NOT?: GiftWhereInput | GiftWhereInput[]
    id?: StringFilter<"Gift"> | string
    giftId?: StringFilter<"Gift"> | string
    name?: StringFilter<"Gift"> | string
    description?: StringNullableFilter<"Gift"> | string | null
    imageUrl?: StringFilter<"Gift"> | string
    animationUrl?: StringNullableFilter<"Gift"> | string | null
    cost?: BigIntFilter<"Gift"> | bigint | number
    value?: BigIntFilter<"Gift"> | bigint | number
    category?: StringNullableFilter<"Gift"> | string | null
    isActive?: BoolFilter<"Gift"> | boolean
    createdAt?: DateTimeFilter<"Gift"> | Date | string
    messages?: MessageListRelationFilter
  }

  export type GiftOrderByWithRelationInput = {
    id?: SortOrder
    giftId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    animationUrl?: SortOrderInput | SortOrder
    cost?: SortOrder
    value?: SortOrder
    category?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    messages?: MessageOrderByRelationAggregateInput
  }

  export type GiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    giftId?: string
    AND?: GiftWhereInput | GiftWhereInput[]
    OR?: GiftWhereInput[]
    NOT?: GiftWhereInput | GiftWhereInput[]
    name?: StringFilter<"Gift"> | string
    description?: StringNullableFilter<"Gift"> | string | null
    imageUrl?: StringFilter<"Gift"> | string
    animationUrl?: StringNullableFilter<"Gift"> | string | null
    cost?: BigIntFilter<"Gift"> | bigint | number
    value?: BigIntFilter<"Gift"> | bigint | number
    category?: StringNullableFilter<"Gift"> | string | null
    isActive?: BoolFilter<"Gift"> | boolean
    createdAt?: DateTimeFilter<"Gift"> | Date | string
    messages?: MessageListRelationFilter
  }, "id" | "giftId">

  export type GiftOrderByWithAggregationInput = {
    id?: SortOrder
    giftId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    animationUrl?: SortOrderInput | SortOrder
    cost?: SortOrder
    value?: SortOrder
    category?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: GiftCountOrderByAggregateInput
    _avg?: GiftAvgOrderByAggregateInput
    _max?: GiftMaxOrderByAggregateInput
    _min?: GiftMinOrderByAggregateInput
    _sum?: GiftSumOrderByAggregateInput
  }

  export type GiftScalarWhereWithAggregatesInput = {
    AND?: GiftScalarWhereWithAggregatesInput | GiftScalarWhereWithAggregatesInput[]
    OR?: GiftScalarWhereWithAggregatesInput[]
    NOT?: GiftScalarWhereWithAggregatesInput | GiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gift"> | string
    giftId?: StringWithAggregatesFilter<"Gift"> | string
    name?: StringWithAggregatesFilter<"Gift"> | string
    description?: StringNullableWithAggregatesFilter<"Gift"> | string | null
    imageUrl?: StringWithAggregatesFilter<"Gift"> | string
    animationUrl?: StringNullableWithAggregatesFilter<"Gift"> | string | null
    cost?: BigIntWithAggregatesFilter<"Gift"> | bigint | number
    value?: BigIntWithAggregatesFilter<"Gift"> | bigint | number
    category?: StringNullableWithAggregatesFilter<"Gift"> | string | null
    isActive?: BoolWithAggregatesFilter<"Gift"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Gift"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringNullableFilter<"Report"> | string | null
    reportedStreamId?: StringNullableFilter<"Report"> | string | null
    reportedRoomId?: StringNullableFilter<"Report"> | string | null
    reportedMessageId?: StringNullableFilter<"Report"> | string | null
    reason?: StringFilter<"Report"> | string
    description?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    reviewedById?: StringNullableFilter<"Report"> | string | null
    reviewTimestamp?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    reporter?: XOR<UserScalarRelationFilter, UserWhereInput>
    reportedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reportedStream?: XOR<StreamNullableScalarRelationFilter, StreamWhereInput> | null
    reportedRoom?: XOR<ChatRoomNullableScalarRelationFilter, ChatRoomWhereInput> | null
    reportedMessage?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrderInput | SortOrder
    reportedStreamId?: SortOrderInput | SortOrder
    reportedRoomId?: SortOrderInput | SortOrder
    reportedMessageId?: SortOrderInput | SortOrder
    reason?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewTimestamp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    reporter?: UserOrderByWithRelationInput
    reportedUser?: UserOrderByWithRelationInput
    reportedStream?: StreamOrderByWithRelationInput
    reportedRoom?: ChatRoomOrderByWithRelationInput
    reportedMessage?: MessageOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringNullableFilter<"Report"> | string | null
    reportedStreamId?: StringNullableFilter<"Report"> | string | null
    reportedRoomId?: StringNullableFilter<"Report"> | string | null
    reportedMessageId?: StringNullableFilter<"Report"> | string | null
    reason?: StringFilter<"Report"> | string
    description?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    reviewedById?: StringNullableFilter<"Report"> | string | null
    reviewTimestamp?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    reporter?: XOR<UserScalarRelationFilter, UserWhereInput>
    reportedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reportedStream?: XOR<StreamNullableScalarRelationFilter, StreamWhereInput> | null
    reportedRoom?: XOR<ChatRoomNullableScalarRelationFilter, ChatRoomWhereInput> | null
    reportedMessage?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrderInput | SortOrder
    reportedStreamId?: SortOrderInput | SortOrder
    reportedRoomId?: SortOrderInput | SortOrder
    reportedMessageId?: SortOrderInput | SortOrder
    reason?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewTimestamp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    reporterId?: StringWithAggregatesFilter<"Report"> | string
    reportedUserId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reportedStreamId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reportedRoomId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reportedMessageId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reason?: StringWithAggregatesFilter<"Report"> | string
    description?: StringNullableWithAggregatesFilter<"Report"> | string | null
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    reviewedById?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reviewTimestamp?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    senderId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    relatedEntityType?: StringNullableFilter<"Notification"> | string | null
    content?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    type?: SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    relatedEntityType?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    recipient?: UserOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    recipientId?: StringFilter<"Notification"> | string
    senderId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    relatedEntityType?: StringNullableFilter<"Notification"> | string | null
    content?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    type?: SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    relatedEntityType?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    recipientId?: StringWithAggregatesFilter<"Notification"> | string
    senderId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    relatedEntityId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    relatedEntityType?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    content?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type StreamWhereInput = {
    AND?: StreamWhereInput | StreamWhereInput[]
    OR?: StreamWhereInput[]
    NOT?: StreamWhereInput | StreamWhereInput[]
    id?: StringFilter<"Stream"> | string
    broadcasterId?: StringFilter<"Stream"> | string
    title?: StringNullableFilter<"Stream"> | string | null
    coverImageUrl?: StringNullableFilter<"Stream"> | string | null
    status?: EnumStreamStatusFilter<"Stream"> | $Enums.StreamStatus
    startTime?: DateTimeNullableFilter<"Stream"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Stream"> | Date | string | null
    currentViewers?: IntFilter<"Stream"> | number
    peakViewers?: IntFilter<"Stream"> | number
    totalDiamondsReceived?: BigIntFilter<"Stream"> | bigint | number
    tags?: JsonNullableFilter<"Stream">
    location?: JsonNullableFilter<"Stream">
    rtcChannelName?: StringNullableFilter<"Stream"> | string | null
    recordingUrl?: StringNullableFilter<"Stream"> | string | null
    createdAt?: DateTimeFilter<"Stream"> | Date | string
    updatedAt?: DateTimeFilter<"Stream"> | Date | string
    broadcaster?: XOR<UserScalarRelationFilter, UserWhereInput>
    reports?: ReportListRelationFilter
  }

  export type StreamOrderByWithRelationInput = {
    id?: SortOrder
    broadcasterId?: SortOrder
    title?: SortOrderInput | SortOrder
    coverImageUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    currentViewers?: SortOrder
    peakViewers?: SortOrder
    totalDiamondsReceived?: SortOrder
    tags?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    rtcChannelName?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    broadcaster?: UserOrderByWithRelationInput
    reports?: ReportOrderByRelationAggregateInput
  }

  export type StreamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StreamWhereInput | StreamWhereInput[]
    OR?: StreamWhereInput[]
    NOT?: StreamWhereInput | StreamWhereInput[]
    broadcasterId?: StringFilter<"Stream"> | string
    title?: StringNullableFilter<"Stream"> | string | null
    coverImageUrl?: StringNullableFilter<"Stream"> | string | null
    status?: EnumStreamStatusFilter<"Stream"> | $Enums.StreamStatus
    startTime?: DateTimeNullableFilter<"Stream"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Stream"> | Date | string | null
    currentViewers?: IntFilter<"Stream"> | number
    peakViewers?: IntFilter<"Stream"> | number
    totalDiamondsReceived?: BigIntFilter<"Stream"> | bigint | number
    tags?: JsonNullableFilter<"Stream">
    location?: JsonNullableFilter<"Stream">
    rtcChannelName?: StringNullableFilter<"Stream"> | string | null
    recordingUrl?: StringNullableFilter<"Stream"> | string | null
    createdAt?: DateTimeFilter<"Stream"> | Date | string
    updatedAt?: DateTimeFilter<"Stream"> | Date | string
    broadcaster?: XOR<UserScalarRelationFilter, UserWhereInput>
    reports?: ReportListRelationFilter
  }, "id">

  export type StreamOrderByWithAggregationInput = {
    id?: SortOrder
    broadcasterId?: SortOrder
    title?: SortOrderInput | SortOrder
    coverImageUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    currentViewers?: SortOrder
    peakViewers?: SortOrder
    totalDiamondsReceived?: SortOrder
    tags?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    rtcChannelName?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StreamCountOrderByAggregateInput
    _avg?: StreamAvgOrderByAggregateInput
    _max?: StreamMaxOrderByAggregateInput
    _min?: StreamMinOrderByAggregateInput
    _sum?: StreamSumOrderByAggregateInput
  }

  export type StreamScalarWhereWithAggregatesInput = {
    AND?: StreamScalarWhereWithAggregatesInput | StreamScalarWhereWithAggregatesInput[]
    OR?: StreamScalarWhereWithAggregatesInput[]
    NOT?: StreamScalarWhereWithAggregatesInput | StreamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stream"> | string
    broadcasterId?: StringWithAggregatesFilter<"Stream"> | string
    title?: StringNullableWithAggregatesFilter<"Stream"> | string | null
    coverImageUrl?: StringNullableWithAggregatesFilter<"Stream"> | string | null
    status?: EnumStreamStatusWithAggregatesFilter<"Stream"> | $Enums.StreamStatus
    startTime?: DateTimeNullableWithAggregatesFilter<"Stream"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"Stream"> | Date | string | null
    currentViewers?: IntWithAggregatesFilter<"Stream"> | number
    peakViewers?: IntWithAggregatesFilter<"Stream"> | number
    totalDiamondsReceived?: BigIntWithAggregatesFilter<"Stream"> | bigint | number
    tags?: JsonNullableWithAggregatesFilter<"Stream">
    location?: JsonNullableWithAggregatesFilter<"Stream">
    rtcChannelName?: StringNullableWithAggregatesFilter<"Stream"> | string | null
    recordingUrl?: StringNullableWithAggregatesFilter<"Stream"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Stream"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Stream"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    lastUsedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    lastUsedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    lastUsedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type OneSignalPlayerWhereInput = {
    AND?: OneSignalPlayerWhereInput | OneSignalPlayerWhereInput[]
    OR?: OneSignalPlayerWhereInput[]
    NOT?: OneSignalPlayerWhereInput | OneSignalPlayerWhereInput[]
    id?: StringFilter<"OneSignalPlayer"> | string
    playerId?: StringFilter<"OneSignalPlayer"> | string
    userId?: StringFilter<"OneSignalPlayer"> | string
    deviceInfo?: StringNullableFilter<"OneSignalPlayer"> | string | null
    lastSeen?: DateTimeFilter<"OneSignalPlayer"> | Date | string
    createdAt?: DateTimeFilter<"OneSignalPlayer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OneSignalPlayerOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    userId?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OneSignalPlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    AND?: OneSignalPlayerWhereInput | OneSignalPlayerWhereInput[]
    OR?: OneSignalPlayerWhereInput[]
    NOT?: OneSignalPlayerWhereInput | OneSignalPlayerWhereInput[]
    userId?: StringFilter<"OneSignalPlayer"> | string
    deviceInfo?: StringNullableFilter<"OneSignalPlayer"> | string | null
    lastSeen?: DateTimeFilter<"OneSignalPlayer"> | Date | string
    createdAt?: DateTimeFilter<"OneSignalPlayer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "playerId">

  export type OneSignalPlayerOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    userId?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    _count?: OneSignalPlayerCountOrderByAggregateInput
    _max?: OneSignalPlayerMaxOrderByAggregateInput
    _min?: OneSignalPlayerMinOrderByAggregateInput
  }

  export type OneSignalPlayerScalarWhereWithAggregatesInput = {
    AND?: OneSignalPlayerScalarWhereWithAggregatesInput | OneSignalPlayerScalarWhereWithAggregatesInput[]
    OR?: OneSignalPlayerScalarWhereWithAggregatesInput[]
    NOT?: OneSignalPlayerScalarWhereWithAggregatesInput | OneSignalPlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OneSignalPlayer"> | string
    playerId?: StringWithAggregatesFilter<"OneSignalPlayer"> | string
    userId?: StringWithAggregatesFilter<"OneSignalPlayer"> | string
    deviceInfo?: StringNullableWithAggregatesFilter<"OneSignalPlayer"> | string | null
    lastSeen?: DateTimeWithAggregatesFilter<"OneSignalPlayer"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"OneSignalPlayer"> | Date | string
  }

  export type TrustedDeviceWhereInput = {
    AND?: TrustedDeviceWhereInput | TrustedDeviceWhereInput[]
    OR?: TrustedDeviceWhereInput[]
    NOT?: TrustedDeviceWhereInput | TrustedDeviceWhereInput[]
    id?: StringFilter<"TrustedDevice"> | string
    userId?: StringFilter<"TrustedDevice"> | string
    deviceName?: StringFilter<"TrustedDevice"> | string
    deviceType?: StringNullableFilter<"TrustedDevice"> | string | null
    ipAddress?: StringNullableFilter<"TrustedDevice"> | string | null
    userAgent?: StringNullableFilter<"TrustedDevice"> | string | null
    location?: StringNullableFilter<"TrustedDevice"> | string | null
    isCurrentDevice?: BoolFilter<"TrustedDevice"> | boolean
    lastUsedAt?: DateTimeFilter<"TrustedDevice"> | Date | string
    createdAt?: DateTimeFilter<"TrustedDevice"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrustedDeviceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isCurrentDevice?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TrustedDeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrustedDeviceWhereInput | TrustedDeviceWhereInput[]
    OR?: TrustedDeviceWhereInput[]
    NOT?: TrustedDeviceWhereInput | TrustedDeviceWhereInput[]
    userId?: StringFilter<"TrustedDevice"> | string
    deviceName?: StringFilter<"TrustedDevice"> | string
    deviceType?: StringNullableFilter<"TrustedDevice"> | string | null
    ipAddress?: StringNullableFilter<"TrustedDevice"> | string | null
    userAgent?: StringNullableFilter<"TrustedDevice"> | string | null
    location?: StringNullableFilter<"TrustedDevice"> | string | null
    isCurrentDevice?: BoolFilter<"TrustedDevice"> | boolean
    lastUsedAt?: DateTimeFilter<"TrustedDevice"> | Date | string
    createdAt?: DateTimeFilter<"TrustedDevice"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TrustedDeviceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isCurrentDevice?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    _count?: TrustedDeviceCountOrderByAggregateInput
    _max?: TrustedDeviceMaxOrderByAggregateInput
    _min?: TrustedDeviceMinOrderByAggregateInput
  }

  export type TrustedDeviceScalarWhereWithAggregatesInput = {
    AND?: TrustedDeviceScalarWhereWithAggregatesInput | TrustedDeviceScalarWhereWithAggregatesInput[]
    OR?: TrustedDeviceScalarWhereWithAggregatesInput[]
    NOT?: TrustedDeviceScalarWhereWithAggregatesInput | TrustedDeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrustedDevice"> | string
    userId?: StringWithAggregatesFilter<"TrustedDevice"> | string
    deviceName?: StringWithAggregatesFilter<"TrustedDevice"> | string
    deviceType?: StringNullableWithAggregatesFilter<"TrustedDevice"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"TrustedDevice"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"TrustedDevice"> | string | null
    location?: StringNullableWithAggregatesFilter<"TrustedDevice"> | string | null
    isCurrentDevice?: BoolWithAggregatesFilter<"TrustedDevice"> | boolean
    lastUsedAt?: DateTimeWithAggregatesFilter<"TrustedDevice"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TrustedDevice"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatRoomCreateInput = {
    id?: string
    title: string
    description?: string | null
    coverImageUrl?: string | null
    type: $Enums.ChatRoomType
    passwordHash?: string | null
    maxParticipants: number
    currentParticipantCount?: number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChatRoomsInput
    messages?: MessageCreateNestedManyWithoutRoomInput
    reports?: ReportCreateNestedManyWithoutReportedRoomInput
  }

  export type ChatRoomUncheckedCreateInput = {
    id?: string
    ownerId: string
    title: string
    description?: string | null
    coverImageUrl?: string | null
    type: $Enums.ChatRoomType
    passwordHash?: string | null
    maxParticipants: number
    currentParticipantCount?: number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutRoomInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedRoomInput
  }

  export type ChatRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatRoomTypeFieldUpdateOperationsInput | $Enums.ChatRoomType
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipantCount?: IntFieldUpdateOperationsInput | number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: IntFieldUpdateOperationsInput | number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumChatRoomStatusFieldUpdateOperationsInput | $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChatRoomsNestedInput
    messages?: MessageUpdateManyWithoutRoomNestedInput
    reports?: ReportUpdateManyWithoutReportedRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatRoomTypeFieldUpdateOperationsInput | $Enums.ChatRoomType
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipantCount?: IntFieldUpdateOperationsInput | number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: IntFieldUpdateOperationsInput | number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumChatRoomStatusFieldUpdateOperationsInput | $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutRoomNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedRoomNestedInput
  }

  export type ChatRoomCreateManyInput = {
    id?: string
    ownerId: string
    title: string
    description?: string | null
    coverImageUrl?: string | null
    type: $Enums.ChatRoomType
    passwordHash?: string | null
    maxParticipants: number
    currentParticipantCount?: number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatRoomTypeFieldUpdateOperationsInput | $Enums.ChatRoomType
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipantCount?: IntFieldUpdateOperationsInput | number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: IntFieldUpdateOperationsInput | number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumChatRoomStatusFieldUpdateOperationsInput | $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatRoomTypeFieldUpdateOperationsInput | $Enums.ChatRoomType
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipantCount?: IntFieldUpdateOperationsInput | number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: IntFieldUpdateOperationsInput | number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumChatRoomStatusFieldUpdateOperationsInput | $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    conversationId: string
    messageType: $Enums.MessageType
    content?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver?: UserCreateNestedOneWithoutReceivedMessagesInput
    room?: ChatRoomCreateNestedOneWithoutMessagesInput
    gift?: GiftCreateNestedOneWithoutMessagesInput
    repliedToMessage?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutRepliedToMessageInput
    reports?: ReportCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    receiverId?: string | null
    roomId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    giftId?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    repliedToMessageId?: string | null
    replies?: MessageUncheckedCreateNestedManyWithoutRepliedToMessageInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneWithoutReceivedMessagesNestedInput
    room?: ChatRoomUpdateOneWithoutMessagesNestedInput
    gift?: GiftUpdateOneWithoutMessagesNestedInput
    repliedToMessage?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutRepliedToMessageNestedInput
    reports?: ReportUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    giftId?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repliedToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessageUncheckedUpdateManyWithoutRepliedToMessageNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    receiverId?: string | null
    roomId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    giftId?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    repliedToMessageId?: string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    giftId?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repliedToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateInput = {
    id?: string
    transactionType: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    description?: string | null
    platform?: string | null
    platformTransactionId?: string | null
    status?: $Enums.TransactionStatus
    paymentGatewayToken?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    transactionType: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    description?: string | null
    platform?: string | null
    platformTransactionId?: string | null
    status?: $Enums.TransactionStatus
    paymentGatewayToken?: string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    platformTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentGatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    platformTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentGatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: string
    transactionType: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    description?: string | null
    platform?: string | null
    platformTransactionId?: string | null
    status?: $Enums.TransactionStatus
    paymentGatewayToken?: string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    platformTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentGatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    platformTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentGatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowingInput
    following: UserCreateNestedOneWithoutFollowedByInput
  }

  export type FollowUncheckedCreateInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowingNestedInput
    following?: UserUpdateOneRequiredWithoutFollowedByNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateManyInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowRequestCreateInput = {
    id?: string
    status?: $Enums.FollowRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutSentFollowRequestsInput
    recipient: UserCreateNestedOneWithoutReceivedFollowRequestsInput
  }

  export type FollowRequestUncheckedCreateInput = {
    id?: string
    requesterId: string
    recipientId: string
    status?: $Enums.FollowRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowRequestStatusFieldUpdateOperationsInput | $Enums.FollowRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutSentFollowRequestsNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedFollowRequestsNestedInput
  }

  export type FollowRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowRequestStatusFieldUpdateOperationsInput | $Enums.FollowRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowRequestCreateManyInput = {
    id?: string
    requesterId: string
    recipientId: string
    status?: $Enums.FollowRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowRequestStatusFieldUpdateOperationsInput | $Enums.FollowRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowRequestStatusFieldUpdateOperationsInput | $Enums.FollowRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    category?: GameCategoryCreateNestedOneWithoutGamesInput
    gameGenreTags?: GameGenreTagCreateNestedManyWithoutGameInput
    gameSessions?: GameSessionCreateNestedManyWithoutGameInput
    likes?: GameLikeCreateNestedManyWithoutGameInput
    ratings?: GameRatingCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    categoryId?: string | null
    gameGenreTags?: GameGenreTagUncheckedCreateNestedManyWithoutGameInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    likes?: GameLikeUncheckedCreateNestedManyWithoutGameInput
    ratings?: GameRatingUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: GameCategoryUpdateOneWithoutGamesNestedInput
    gameGenreTags?: GameGenreTagUpdateManyWithoutGameNestedInput
    gameSessions?: GameSessionUpdateManyWithoutGameNestedInput
    likes?: GameLikeUpdateManyWithoutGameNestedInput
    ratings?: GameRatingUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    gameGenreTags?: GameGenreTagUncheckedUpdateManyWithoutGameNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    likes?: GameLikeUncheckedUpdateManyWithoutGameNestedInput
    ratings?: GameRatingUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    categoryId?: string | null
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GenreTagCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    gameGenreTags?: GameGenreTagCreateNestedManyWithoutGenreTagInput
  }

  export type GenreTagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    gameGenreTags?: GameGenreTagUncheckedCreateNestedManyWithoutGenreTagInput
  }

  export type GenreTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameGenreTags?: GameGenreTagUpdateManyWithoutGenreTagNestedInput
  }

  export type GenreTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameGenreTags?: GameGenreTagUncheckedUpdateManyWithoutGenreTagNestedInput
  }

  export type GenreTagCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
  }

  export type GenreTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameGenreTagCreateInput = {
    id?: string
    assignedAt?: Date | string
    game: GameCreateNestedOneWithoutGameGenreTagsInput
    genreTag: GenreTagCreateNestedOneWithoutGameGenreTagsInput
  }

  export type GameGenreTagUncheckedCreateInput = {
    id?: string
    gameId: string
    genreTagId: string
    assignedAt?: Date | string
  }

  export type GameGenreTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutGameGenreTagsNestedInput
    genreTag?: GenreTagUpdateOneRequiredWithoutGameGenreTagsNestedInput
  }

  export type GameGenreTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    genreTagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameGenreTagCreateManyInput = {
    id?: string
    gameId: string
    genreTagId: string
    assignedAt?: Date | string
  }

  export type GameGenreTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameGenreTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    genreTagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameLikeCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikedGamesInput
    game: GameCreateNestedOneWithoutLikesInput
  }

  export type GameLikeUncheckedCreateInput = {
    id?: string
    userId: string
    gameId: string
    createdAt?: Date | string
  }

  export type GameLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedGamesNestedInput
    game?: GameUpdateOneRequiredWithoutLikesNestedInput
  }

  export type GameLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameLikeCreateManyInput = {
    id?: string
    userId: string
    gameId: string
    createdAt?: Date | string
  }

  export type GameLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameRatingCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGameRatingsInput
    game: GameCreateNestedOneWithoutRatingsInput
  }

  export type GameRatingUncheckedCreateInput = {
    id?: string
    userId: string
    gameId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGameRatingsNestedInput
    game?: GameUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type GameRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameRatingCreateManyInput = {
    id?: string
    userId: string
    gameId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCategoryCreateInput = {
    id?: string
    name: string
    slug: string
    iconUrl?: string | null
    createdAt?: Date | string
    games?: GameCreateNestedManyWithoutCategoryInput
  }

  export type GameCategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    iconUrl?: string | null
    createdAt?: Date | string
    games?: GameUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type GameCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUpdateManyWithoutCategoryNestedInput
  }

  export type GameCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type GameCategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    iconUrl?: string | null
    createdAt?: Date | string
  }

  export type GameCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionCreateInput = {
    id?: string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers: number
    currentPlayers?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    status?: $Enums.GameSessionStatus
    createdAt?: Date | string
    game: GameCreateNestedOneWithoutGameSessionsInput
    host: UserCreateNestedOneWithoutHostedGameSessionsInput
  }

  export type GameSessionUncheckedCreateInput = {
    id?: string
    gameId: string
    hostId: string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers: number
    currentPlayers?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    status?: $Enums.GameSessionStatus
    createdAt?: Date | string
  }

  export type GameSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGameSessionStatusFieldUpdateOperationsInput | $Enums.GameSessionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutGameSessionsNestedInput
    host?: UserUpdateOneRequiredWithoutHostedGameSessionsNestedInput
  }

  export type GameSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGameSessionStatusFieldUpdateOperationsInput | $Enums.GameSessionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionCreateManyInput = {
    id?: string
    gameId: string
    hostId: string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers: number
    currentPlayers?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    status?: $Enums.GameSessionStatus
    createdAt?: Date | string
  }

  export type GameSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGameSessionStatusFieldUpdateOperationsInput | $Enums.GameSessionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGameSessionStatusFieldUpdateOperationsInput | $Enums.GameSessionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GiftCreateInput = {
    id?: string
    giftId: string
    name: string
    description?: string | null
    imageUrl: string
    animationUrl?: string | null
    cost: bigint | number
    value: bigint | number
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    messages?: MessageCreateNestedManyWithoutGiftInput
  }

  export type GiftUncheckedCreateInput = {
    id?: string
    giftId: string
    name: string
    description?: string | null
    imageUrl: string
    animationUrl?: string | null
    cost: bigint | number
    value: bigint | number
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutGiftInput
  }

  export type GiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    giftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutGiftNestedInput
  }

  export type GiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    giftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutGiftNestedInput
  }

  export type GiftCreateManyInput = {
    id?: string
    giftId: string
    name: string
    description?: string | null
    imageUrl: string
    animationUrl?: string | null
    cost: bigint | number
    value: bigint | number
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    giftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    giftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsMadeInput
    reportedUser?: UserCreateNestedOneWithoutReportsReceivedInput
    reportedStream?: StreamCreateNestedOneWithoutReportsInput
    reportedRoom?: ChatRoomCreateNestedOneWithoutReportsInput
    reportedMessage?: MessageCreateNestedOneWithoutReportsInput
    reviewer?: UserCreateNestedOneWithoutReviewedReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    reporterId: string
    reportedUserId?: string | null
    reportedStreamId?: string | null
    reportedRoomId?: string | null
    reportedMessageId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewedById?: string | null
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
    reportedUser?: UserUpdateOneWithoutReportsReceivedNestedInput
    reportedStream?: StreamUpdateOneWithoutReportsNestedInput
    reportedRoom?: ChatRoomUpdateOneWithoutReportsNestedInput
    reportedMessage?: MessageUpdateOneWithoutReportsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedStreamId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    reporterId: string
    reportedUserId?: string | null
    reportedStreamId?: string | null
    reportedRoomId?: string | null
    reportedMessageId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewedById?: string | null
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedStreamId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    content?: string | null
    isRead?: boolean
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    content?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    content?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamCreateInput = {
    id?: string
    title?: string | null
    coverImageUrl?: string | null
    status?: $Enums.StreamStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    currentViewers?: number
    peakViewers?: number
    totalDiamondsReceived?: bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    recordingUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    broadcaster: UserCreateNestedOneWithoutStreamsInput
    reports?: ReportCreateNestedManyWithoutReportedStreamInput
  }

  export type StreamUncheckedCreateInput = {
    id?: string
    broadcasterId: string
    title?: string | null
    coverImageUrl?: string | null
    status?: $Enums.StreamStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    currentViewers?: number
    peakViewers?: number
    totalDiamondsReceived?: bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    recordingUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutReportedStreamInput
  }

  export type StreamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentViewers?: IntFieldUpdateOperationsInput | number
    peakViewers?: IntFieldUpdateOperationsInput | number
    totalDiamondsReceived?: BigIntFieldUpdateOperationsInput | bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    broadcaster?: UserUpdateOneRequiredWithoutStreamsNestedInput
    reports?: ReportUpdateManyWithoutReportedStreamNestedInput
  }

  export type StreamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    broadcasterId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentViewers?: IntFieldUpdateOperationsInput | number
    peakViewers?: IntFieldUpdateOperationsInput | number
    totalDiamondsReceived?: BigIntFieldUpdateOperationsInput | bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutReportedStreamNestedInput
  }

  export type StreamCreateManyInput = {
    id?: string
    broadcasterId: string
    title?: string | null
    coverImageUrl?: string | null
    status?: $Enums.StreamStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    currentViewers?: number
    peakViewers?: number
    totalDiamondsReceived?: bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    recordingUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StreamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentViewers?: IntFieldUpdateOperationsInput | number
    peakViewers?: IntFieldUpdateOperationsInput | number
    totalDiamondsReceived?: BigIntFieldUpdateOperationsInput | bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    broadcasterId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentViewers?: IntFieldUpdateOperationsInput | number
    peakViewers?: IntFieldUpdateOperationsInput | number
    totalDiamondsReceived?: BigIntFieldUpdateOperationsInput | bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    lastUsedAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    lastUsedAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    lastUsedAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneSignalPlayerCreateInput = {
    id?: string
    playerId: string
    deviceInfo?: string | null
    lastSeen?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOneSignalPlayersInput
  }

  export type OneSignalPlayerUncheckedCreateInput = {
    id?: string
    playerId: string
    userId: string
    deviceInfo?: string | null
    lastSeen?: Date | string
    createdAt?: Date | string
  }

  export type OneSignalPlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOneSignalPlayersNestedInput
  }

  export type OneSignalPlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneSignalPlayerCreateManyInput = {
    id?: string
    playerId: string
    userId: string
    deviceInfo?: string | null
    lastSeen?: Date | string
    createdAt?: Date | string
  }

  export type OneSignalPlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneSignalPlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustedDeviceCreateInput = {
    id?: string
    deviceName: string
    deviceType?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    location?: string | null
    isCurrentDevice?: boolean
    lastUsedAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrustedDevicesInput
  }

  export type TrustedDeviceUncheckedCreateInput = {
    id?: string
    userId: string
    deviceName: string
    deviceType?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    location?: string | null
    isCurrentDevice?: boolean
    lastUsedAt?: Date | string
    createdAt?: Date | string
  }

  export type TrustedDeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrentDevice?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrustedDevicesNestedInput
  }

  export type TrustedDeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrentDevice?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustedDeviceCreateManyInput = {
    id?: string
    userId: string
    deviceName: string
    deviceType?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    location?: string | null
    isCurrentDevice?: boolean
    lastUsedAt?: Date | string
    createdAt?: Date | string
  }

  export type TrustedDeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrentDevice?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustedDeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrentDevice?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserGender | EnumUserGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserGender[] | ListEnumUserGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserGender[] | ListEnumUserGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserGenderNullableFilter<$PrismaModel> | $Enums.UserGender | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumUserAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserAccountStatus | EnumUserAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserAccountStatus[] | ListEnumUserAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserAccountStatus[] | ListEnumUserAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserAccountStatusFilter<$PrismaModel> | $Enums.UserAccountStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TrustedDeviceListRelationFilter = {
    every?: TrustedDeviceWhereInput
    some?: TrustedDeviceWhereInput
    none?: TrustedDeviceWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type OneSignalPlayerListRelationFilter = {
    every?: OneSignalPlayerWhereInput
    some?: OneSignalPlayerWhereInput
    none?: OneSignalPlayerWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type GameSessionListRelationFilter = {
    every?: GameSessionWhereInput
    some?: GameSessionWhereInput
    none?: GameSessionWhereInput
  }

  export type StreamListRelationFilter = {
    every?: StreamWhereInput
    some?: StreamWhereInput
    none?: StreamWhereInput
  }

  export type ChatRoomListRelationFilter = {
    every?: ChatRoomWhereInput
    some?: ChatRoomWhereInput
    none?: ChatRoomWhereInput
  }

  export type FollowRequestListRelationFilter = {
    every?: FollowRequestWhereInput
    some?: FollowRequestWhereInput
    none?: FollowRequestWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type GameLikeListRelationFilter = {
    every?: GameLikeWhereInput
    some?: GameLikeWhereInput
    none?: GameLikeWhereInput
  }

  export type GameRatingListRelationFilter = {
    every?: GameRatingWhereInput
    some?: GameRatingWhereInput
    none?: GameRatingWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrustedDeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OneSignalPlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StreamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    authProvider?: SortOrder
    authId?: SortOrder
    username?: SortOrder
    nickname?: SortOrder
    profilePictureUrl?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    country?: SortOrder
    region?: SortOrder
    level?: SortOrder
    vipLevel?: SortOrder
    coins?: SortOrder
    diamonds?: SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordChangedAt?: SortOrder
    isEmailVerified?: SortOrder
    lastLoginAt?: SortOrder
    followingCount?: SortOrder
    followerCount?: SortOrder
    status?: SortOrder
    isOnline?: SortOrder
    preferences?: SortOrder
    allowDirectMessages?: SortOrder
    notificationSettings?: SortOrder
    blockedUserIds?: SortOrder
    accountStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    isPrivate?: SortOrder
    pinnedMessagesInRooms?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorRecoveryCodes?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationExpiresAt?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpiresAt?: SortOrder
    postCount?: SortOrder
    invitedByForeignKey?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    level?: SortOrder
    vipLevel?: SortOrder
    coins?: SortOrder
    diamonds?: SortOrder
    followingCount?: SortOrder
    followerCount?: SortOrder
    postCount?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    authProvider?: SortOrder
    authId?: SortOrder
    username?: SortOrder
    nickname?: SortOrder
    profilePictureUrl?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    country?: SortOrder
    region?: SortOrder
    level?: SortOrder
    vipLevel?: SortOrder
    coins?: SortOrder
    diamonds?: SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordChangedAt?: SortOrder
    isEmailVerified?: SortOrder
    lastLoginAt?: SortOrder
    followingCount?: SortOrder
    followerCount?: SortOrder
    status?: SortOrder
    isOnline?: SortOrder
    allowDirectMessages?: SortOrder
    accountStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    isPrivate?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationExpiresAt?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpiresAt?: SortOrder
    postCount?: SortOrder
    invitedByForeignKey?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    authProvider?: SortOrder
    authId?: SortOrder
    username?: SortOrder
    nickname?: SortOrder
    profilePictureUrl?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    country?: SortOrder
    region?: SortOrder
    level?: SortOrder
    vipLevel?: SortOrder
    coins?: SortOrder
    diamonds?: SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordChangedAt?: SortOrder
    isEmailVerified?: SortOrder
    lastLoginAt?: SortOrder
    followingCount?: SortOrder
    followerCount?: SortOrder
    status?: SortOrder
    isOnline?: SortOrder
    allowDirectMessages?: SortOrder
    accountStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    isPrivate?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationExpiresAt?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpiresAt?: SortOrder
    postCount?: SortOrder
    invitedByForeignKey?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    level?: SortOrder
    vipLevel?: SortOrder
    coins?: SortOrder
    diamonds?: SortOrder
    followingCount?: SortOrder
    followerCount?: SortOrder
    postCount?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserGender | EnumUserGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserGender[] | ListEnumUserGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserGender[] | ListEnumUserGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserGender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumUserGenderNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumUserAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserAccountStatus | EnumUserAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserAccountStatus[] | ListEnumUserAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserAccountStatus[] | ListEnumUserAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserAccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumUserAccountStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumChatRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatRoomType | EnumChatRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChatRoomType[] | ListEnumChatRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatRoomType[] | ListEnumChatRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChatRoomTypeFilter<$PrismaModel> | $Enums.ChatRoomType
  }

  export type EnumChatRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatRoomStatus | EnumChatRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChatRoomStatus[] | ListEnumChatRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatRoomStatus[] | ListEnumChatRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChatRoomStatusFilter<$PrismaModel> | $Enums.ChatRoomStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ChatRoomCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverImageUrl?: SortOrder
    type?: SortOrder
    passwordHash?: SortOrder
    maxParticipants?: SortOrder
    currentParticipantCount?: SortOrder
    activeParticipants?: SortOrder
    moderators?: SortOrder
    speakerSeatCount?: SortOrder
    speakerSeatAssignments?: SortOrder
    rtcChannelName?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    pinnedMessageIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatRoomAvgOrderByAggregateInput = {
    maxParticipants?: SortOrder
    currentParticipantCount?: SortOrder
    speakerSeatCount?: SortOrder
  }

  export type ChatRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverImageUrl?: SortOrder
    type?: SortOrder
    passwordHash?: SortOrder
    maxParticipants?: SortOrder
    currentParticipantCount?: SortOrder
    speakerSeatCount?: SortOrder
    rtcChannelName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatRoomMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverImageUrl?: SortOrder
    type?: SortOrder
    passwordHash?: SortOrder
    maxParticipants?: SortOrder
    currentParticipantCount?: SortOrder
    speakerSeatCount?: SortOrder
    rtcChannelName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatRoomSumOrderByAggregateInput = {
    maxParticipants?: SortOrder
    currentParticipantCount?: SortOrder
    speakerSeatCount?: SortOrder
  }

  export type EnumChatRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatRoomType | EnumChatRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChatRoomType[] | ListEnumChatRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatRoomType[] | ListEnumChatRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChatRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChatRoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumChatRoomTypeFilter<$PrismaModel>
  }

  export type EnumChatRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatRoomStatus | EnumChatRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChatRoomStatus[] | ListEnumChatRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatRoomStatus[] | ListEnumChatRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChatRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChatRoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumChatRoomStatusFilter<$PrismaModel>
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type ChatRoomNullableScalarRelationFilter = {
    is?: ChatRoomWhereInput | null
    isNot?: ChatRoomWhereInput | null
  }

  export type GiftNullableScalarRelationFilter = {
    is?: GiftWhereInput | null
    isNot?: GiftWhereInput | null
  }

  export type MessageNullableScalarRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    roomId?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    giftId?: SortOrder
    readStatus?: SortOrder
    isDeletedFor?: SortOrder
    isPinned?: SortOrder
    reactions?: SortOrder
    createdAt?: SortOrder
    repliedToMessageId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    roomId?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    giftId?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    repliedToMessageId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    roomId?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    giftId?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    repliedToMessageId?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    relatedEntityId?: SortOrder
    relatedEntityType?: SortOrder
    description?: SortOrder
    platform?: SortOrder
    platformTransactionId?: SortOrder
    status?: SortOrder
    paymentGatewayToken?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    relatedEntityId?: SortOrder
    relatedEntityType?: SortOrder
    description?: SortOrder
    platform?: SortOrder
    platformTransactionId?: SortOrder
    status?: SortOrder
    paymentGatewayToken?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    relatedEntityId?: SortOrder
    relatedEntityType?: SortOrder
    description?: SortOrder
    platform?: SortOrder
    platformTransactionId?: SortOrder
    status?: SortOrder
    paymentGatewayToken?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type FollowFollowerIdFollowingIdCompoundUniqueInput = {
    followerId: string
    followingId: string
  }

  export type FollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFollowRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowRequestStatus | EnumFollowRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowRequestStatus[] | ListEnumFollowRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowRequestStatus[] | ListEnumFollowRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowRequestStatusFilter<$PrismaModel> | $Enums.FollowRequestStatus
  }

  export type FollowRequestRequesterIdRecipientIdCompoundUniqueInput = {
    requesterId: string
    recipientId: string
  }

  export type FollowRequestCountOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    recipientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    recipientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowRequestMinOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    recipientId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFollowRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowRequestStatus | EnumFollowRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowRequestStatus[] | ListEnumFollowRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowRequestStatus[] | ListEnumFollowRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.FollowRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFollowRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumFollowRequestStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type GameCategoryNullableScalarRelationFilter = {
    is?: GameCategoryWhereInput | null
    isNot?: GameCategoryWhereInput | null
  }

  export type GameGenreTagListRelationFilter = {
    every?: GameGenreTagWhereInput
    some?: GameGenreTagWhereInput
    none?: GameGenreTagWhereInput
  }

  export type GameGenreTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    entryCost?: SortOrder
    rewardStructure?: SortOrder
    isActive?: SortOrder
    developer?: SortOrder
    publisher?: SortOrder
    releaseDate?: SortOrder
    platformCompat?: SortOrder
    likeCount?: SortOrder
    playCount?: SortOrder
    averageRating?: SortOrder
    ratingCount?: SortOrder
    createdAt?: SortOrder
    categoryId?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    entryCost?: SortOrder
    likeCount?: SortOrder
    playCount?: SortOrder
    averageRating?: SortOrder
    ratingCount?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    entryCost?: SortOrder
    isActive?: SortOrder
    developer?: SortOrder
    publisher?: SortOrder
    releaseDate?: SortOrder
    likeCount?: SortOrder
    playCount?: SortOrder
    averageRating?: SortOrder
    ratingCount?: SortOrder
    createdAt?: SortOrder
    categoryId?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    entryCost?: SortOrder
    isActive?: SortOrder
    developer?: SortOrder
    publisher?: SortOrder
    releaseDate?: SortOrder
    likeCount?: SortOrder
    playCount?: SortOrder
    averageRating?: SortOrder
    ratingCount?: SortOrder
    createdAt?: SortOrder
    categoryId?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    entryCost?: SortOrder
    likeCount?: SortOrder
    playCount?: SortOrder
    averageRating?: SortOrder
    ratingCount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type GenreTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
  }

  export type GenreTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
  }

  export type GenreTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
  }

  export type GameScalarRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type GenreTagScalarRelationFilter = {
    is?: GenreTagWhereInput
    isNot?: GenreTagWhereInput
  }

  export type GameGenreTagGameIdGenreTagIdCompoundUniqueInput = {
    gameId: string
    genreTagId: string
  }

  export type GameGenreTagCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    genreTagId?: SortOrder
    assignedAt?: SortOrder
  }

  export type GameGenreTagMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    genreTagId?: SortOrder
    assignedAt?: SortOrder
  }

  export type GameGenreTagMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    genreTagId?: SortOrder
    assignedAt?: SortOrder
  }

  export type GameLikeUserIdGameIdCompoundUniqueInput = {
    userId: string
    gameId: string
  }

  export type GameLikeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
  }

  export type GameLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
  }

  export type GameLikeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
  }

  export type GameRatingUserIdGameIdCompoundUniqueInput = {
    userId: string
    gameId: string
  }

  export type GameRatingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameRatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type GameRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameRatingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameRatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type GameListRelationFilter = {
    every?: GameWhereInput
    some?: GameWhereInput
    none?: GameWhereInput
  }

  export type GameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    iconUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type GameCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    iconUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type GameCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    iconUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumGameSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameSessionStatus | EnumGameSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameSessionStatus[] | ListEnumGameSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameSessionStatus[] | ListEnumGameSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameSessionStatusFilter<$PrismaModel> | $Enums.GameSessionStatus
  }

  export type GameSessionCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    hostId?: SortOrder
    participants?: SortOrder
    viewerIds?: SortOrder
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GameSessionAvgOrderByAggregateInput = {
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
  }

  export type GameSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    hostId?: SortOrder
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GameSessionMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    hostId?: SortOrder
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GameSessionSumOrderByAggregateInput = {
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
  }

  export type EnumGameSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameSessionStatus | EnumGameSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameSessionStatus[] | ListEnumGameSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameSessionStatus[] | ListEnumGameSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumGameSessionStatusFilter<$PrismaModel>
  }

  export type GiftCountOrderByAggregateInput = {
    id?: SortOrder
    giftId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    animationUrl?: SortOrder
    cost?: SortOrder
    value?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type GiftAvgOrderByAggregateInput = {
    cost?: SortOrder
    value?: SortOrder
  }

  export type GiftMaxOrderByAggregateInput = {
    id?: SortOrder
    giftId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    animationUrl?: SortOrder
    cost?: SortOrder
    value?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type GiftMinOrderByAggregateInput = {
    id?: SortOrder
    giftId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    animationUrl?: SortOrder
    cost?: SortOrder
    value?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type GiftSumOrderByAggregateInput = {
    cost?: SortOrder
    value?: SortOrder
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type StreamNullableScalarRelationFilter = {
    is?: StreamWhereInput | null
    isNot?: StreamWhereInput | null
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    reportedStreamId?: SortOrder
    reportedRoomId?: SortOrder
    reportedMessageId?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    reviewTimestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    reportedStreamId?: SortOrder
    reportedRoomId?: SortOrder
    reportedMessageId?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    reviewTimestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    reportedStreamId?: SortOrder
    reportedRoomId?: SortOrder
    reportedMessageId?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    reviewTimestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    relatedEntityId?: SortOrder
    relatedEntityType?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    relatedEntityId?: SortOrder
    relatedEntityType?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    relatedEntityId?: SortOrder
    relatedEntityType?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumStreamStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StreamStatus | EnumStreamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStreamStatusFilter<$PrismaModel> | $Enums.StreamStatus
  }

  export type StreamCountOrderByAggregateInput = {
    id?: SortOrder
    broadcasterId?: SortOrder
    title?: SortOrder
    coverImageUrl?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    currentViewers?: SortOrder
    peakViewers?: SortOrder
    totalDiamondsReceived?: SortOrder
    tags?: SortOrder
    location?: SortOrder
    rtcChannelName?: SortOrder
    recordingUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StreamAvgOrderByAggregateInput = {
    currentViewers?: SortOrder
    peakViewers?: SortOrder
    totalDiamondsReceived?: SortOrder
  }

  export type StreamMaxOrderByAggregateInput = {
    id?: SortOrder
    broadcasterId?: SortOrder
    title?: SortOrder
    coverImageUrl?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    currentViewers?: SortOrder
    peakViewers?: SortOrder
    totalDiamondsReceived?: SortOrder
    rtcChannelName?: SortOrder
    recordingUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StreamMinOrderByAggregateInput = {
    id?: SortOrder
    broadcasterId?: SortOrder
    title?: SortOrder
    coverImageUrl?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    currentViewers?: SortOrder
    peakViewers?: SortOrder
    totalDiamondsReceived?: SortOrder
    rtcChannelName?: SortOrder
    recordingUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StreamSumOrderByAggregateInput = {
    currentViewers?: SortOrder
    peakViewers?: SortOrder
    totalDiamondsReceived?: SortOrder
  }

  export type EnumStreamStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StreamStatus | EnumStreamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStreamStatusWithAggregatesFilter<$PrismaModel> | $Enums.StreamStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStreamStatusFilter<$PrismaModel>
    _max?: NestedEnumStreamStatusFilter<$PrismaModel>
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type OneSignalPlayerCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    userId?: SortOrder
    deviceInfo?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
  }

  export type OneSignalPlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    userId?: SortOrder
    deviceInfo?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
  }

  export type OneSignalPlayerMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    userId?: SortOrder
    deviceInfo?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
  }

  export type TrustedDeviceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    location?: SortOrder
    isCurrentDevice?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TrustedDeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    location?: SortOrder
    isCurrentDevice?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TrustedDeviceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    location?: SortOrder
    isCurrentDevice?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutInvitedByInput = {
    create?: XOR<UserCreateWithoutInvitedByInput, UserUncheckedCreateWithoutInvitedByInput> | UserCreateWithoutInvitedByInput[] | UserUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutInvitedByInput | UserCreateOrConnectWithoutInvitedByInput[]
    createMany?: UserCreateManyInvitedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutInvitedUsersInput = {
    create?: XOR<UserCreateWithoutInvitedUsersInput, UserUncheckedCreateWithoutInvitedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type TrustedDeviceCreateNestedManyWithoutUserInput = {
    create?: XOR<TrustedDeviceCreateWithoutUserInput, TrustedDeviceUncheckedCreateWithoutUserInput> | TrustedDeviceCreateWithoutUserInput[] | TrustedDeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrustedDeviceCreateOrConnectWithoutUserInput | TrustedDeviceCreateOrConnectWithoutUserInput[]
    createMany?: TrustedDeviceCreateManyUserInputEnvelope
    connect?: TrustedDeviceWhereUniqueInput | TrustedDeviceWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type OneSignalPlayerCreateNestedManyWithoutUserInput = {
    create?: XOR<OneSignalPlayerCreateWithoutUserInput, OneSignalPlayerUncheckedCreateWithoutUserInput> | OneSignalPlayerCreateWithoutUserInput[] | OneSignalPlayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OneSignalPlayerCreateOrConnectWithoutUserInput | OneSignalPlayerCreateOrConnectWithoutUserInput[]
    createMany?: OneSignalPlayerCreateManyUserInputEnvelope
    connect?: OneSignalPlayerWhereUniqueInput | OneSignalPlayerWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReporterInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReportedUserInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReviewerInput = {
    create?: XOR<ReportCreateWithoutReviewerInput, ReportUncheckedCreateWithoutReviewerInput> | ReportCreateWithoutReviewerInput[] | ReportUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReviewerInput | ReportCreateOrConnectWithoutReviewerInput[]
    createMany?: ReportCreateManyReviewerInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type GameSessionCreateNestedManyWithoutHostInput = {
    create?: XOR<GameSessionCreateWithoutHostInput, GameSessionUncheckedCreateWithoutHostInput> | GameSessionCreateWithoutHostInput[] | GameSessionUncheckedCreateWithoutHostInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutHostInput | GameSessionCreateOrConnectWithoutHostInput[]
    createMany?: GameSessionCreateManyHostInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type StreamCreateNestedManyWithoutBroadcasterInput = {
    create?: XOR<StreamCreateWithoutBroadcasterInput, StreamUncheckedCreateWithoutBroadcasterInput> | StreamCreateWithoutBroadcasterInput[] | StreamUncheckedCreateWithoutBroadcasterInput[]
    connectOrCreate?: StreamCreateOrConnectWithoutBroadcasterInput | StreamCreateOrConnectWithoutBroadcasterInput[]
    createMany?: StreamCreateManyBroadcasterInputEnvelope
    connect?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
  }

  export type ChatRoomCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ChatRoomCreateWithoutOwnerInput, ChatRoomUncheckedCreateWithoutOwnerInput> | ChatRoomCreateWithoutOwnerInput[] | ChatRoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutOwnerInput | ChatRoomCreateOrConnectWithoutOwnerInput[]
    createMany?: ChatRoomCreateManyOwnerInputEnvelope
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
  }

  export type FollowRequestCreateNestedManyWithoutRequesterInput = {
    create?: XOR<FollowRequestCreateWithoutRequesterInput, FollowRequestUncheckedCreateWithoutRequesterInput> | FollowRequestCreateWithoutRequesterInput[] | FollowRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: FollowRequestCreateOrConnectWithoutRequesterInput | FollowRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: FollowRequestCreateManyRequesterInputEnvelope
    connect?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
  }

  export type FollowRequestCreateNestedManyWithoutRecipientInput = {
    create?: XOR<FollowRequestCreateWithoutRecipientInput, FollowRequestUncheckedCreateWithoutRecipientInput> | FollowRequestCreateWithoutRecipientInput[] | FollowRequestUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: FollowRequestCreateOrConnectWithoutRecipientInput | FollowRequestCreateOrConnectWithoutRecipientInput[]
    createMany?: FollowRequestCreateManyRecipientInputEnvelope
    connect?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type GameLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<GameLikeCreateWithoutUserInput, GameLikeUncheckedCreateWithoutUserInput> | GameLikeCreateWithoutUserInput[] | GameLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameLikeCreateOrConnectWithoutUserInput | GameLikeCreateOrConnectWithoutUserInput[]
    createMany?: GameLikeCreateManyUserInputEnvelope
    connect?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
  }

  export type GameRatingCreateNestedManyWithoutUserInput = {
    create?: XOR<GameRatingCreateWithoutUserInput, GameRatingUncheckedCreateWithoutUserInput> | GameRatingCreateWithoutUserInput[] | GameRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameRatingCreateOrConnectWithoutUserInput | GameRatingCreateOrConnectWithoutUserInput[]
    createMany?: GameRatingCreateManyUserInputEnvelope
    connect?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutInvitedByInput = {
    create?: XOR<UserCreateWithoutInvitedByInput, UserUncheckedCreateWithoutInvitedByInput> | UserCreateWithoutInvitedByInput[] | UserUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutInvitedByInput | UserCreateOrConnectWithoutInvitedByInput[]
    createMany?: UserCreateManyInvitedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TrustedDeviceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TrustedDeviceCreateWithoutUserInput, TrustedDeviceUncheckedCreateWithoutUserInput> | TrustedDeviceCreateWithoutUserInput[] | TrustedDeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrustedDeviceCreateOrConnectWithoutUserInput | TrustedDeviceCreateOrConnectWithoutUserInput[]
    createMany?: TrustedDeviceCreateManyUserInputEnvelope
    connect?: TrustedDeviceWhereUniqueInput | TrustedDeviceWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OneSignalPlayerCreateWithoutUserInput, OneSignalPlayerUncheckedCreateWithoutUserInput> | OneSignalPlayerCreateWithoutUserInput[] | OneSignalPlayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OneSignalPlayerCreateOrConnectWithoutUserInput | OneSignalPlayerCreateOrConnectWithoutUserInput[]
    createMany?: OneSignalPlayerCreateManyUserInputEnvelope
    connect?: OneSignalPlayerWhereUniqueInput | OneSignalPlayerWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedUserInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<ReportCreateWithoutReviewerInput, ReportUncheckedCreateWithoutReviewerInput> | ReportCreateWithoutReviewerInput[] | ReportUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReviewerInput | ReportCreateOrConnectWithoutReviewerInput[]
    createMany?: ReportCreateManyReviewerInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type GameSessionUncheckedCreateNestedManyWithoutHostInput = {
    create?: XOR<GameSessionCreateWithoutHostInput, GameSessionUncheckedCreateWithoutHostInput> | GameSessionCreateWithoutHostInput[] | GameSessionUncheckedCreateWithoutHostInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutHostInput | GameSessionCreateOrConnectWithoutHostInput[]
    createMany?: GameSessionCreateManyHostInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type StreamUncheckedCreateNestedManyWithoutBroadcasterInput = {
    create?: XOR<StreamCreateWithoutBroadcasterInput, StreamUncheckedCreateWithoutBroadcasterInput> | StreamCreateWithoutBroadcasterInput[] | StreamUncheckedCreateWithoutBroadcasterInput[]
    connectOrCreate?: StreamCreateOrConnectWithoutBroadcasterInput | StreamCreateOrConnectWithoutBroadcasterInput[]
    createMany?: StreamCreateManyBroadcasterInputEnvelope
    connect?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
  }

  export type ChatRoomUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ChatRoomCreateWithoutOwnerInput, ChatRoomUncheckedCreateWithoutOwnerInput> | ChatRoomCreateWithoutOwnerInput[] | ChatRoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutOwnerInput | ChatRoomCreateOrConnectWithoutOwnerInput[]
    createMany?: ChatRoomCreateManyOwnerInputEnvelope
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
  }

  export type FollowRequestUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<FollowRequestCreateWithoutRequesterInput, FollowRequestUncheckedCreateWithoutRequesterInput> | FollowRequestCreateWithoutRequesterInput[] | FollowRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: FollowRequestCreateOrConnectWithoutRequesterInput | FollowRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: FollowRequestCreateManyRequesterInputEnvelope
    connect?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
  }

  export type FollowRequestUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<FollowRequestCreateWithoutRecipientInput, FollowRequestUncheckedCreateWithoutRecipientInput> | FollowRequestCreateWithoutRecipientInput[] | FollowRequestUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: FollowRequestCreateOrConnectWithoutRecipientInput | FollowRequestCreateOrConnectWithoutRecipientInput[]
    createMany?: FollowRequestCreateManyRecipientInputEnvelope
    connect?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type GameLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GameLikeCreateWithoutUserInput, GameLikeUncheckedCreateWithoutUserInput> | GameLikeCreateWithoutUserInput[] | GameLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameLikeCreateOrConnectWithoutUserInput | GameLikeCreateOrConnectWithoutUserInput[]
    createMany?: GameLikeCreateManyUserInputEnvelope
    connect?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
  }

  export type GameRatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GameRatingCreateWithoutUserInput, GameRatingUncheckedCreateWithoutUserInput> | GameRatingCreateWithoutUserInput[] | GameRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameRatingCreateOrConnectWithoutUserInput | GameRatingCreateOrConnectWithoutUserInput[]
    createMany?: GameRatingCreateManyUserInputEnvelope
    connect?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumUserGenderFieldUpdateOperationsInput = {
    set?: $Enums.UserGender | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type EnumUserAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserAccountStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type UserUpdateManyWithoutInvitedByNestedInput = {
    create?: XOR<UserCreateWithoutInvitedByInput, UserUncheckedCreateWithoutInvitedByInput> | UserCreateWithoutInvitedByInput[] | UserUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutInvitedByInput | UserCreateOrConnectWithoutInvitedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutInvitedByInput | UserUpsertWithWhereUniqueWithoutInvitedByInput[]
    createMany?: UserCreateManyInvitedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutInvitedByInput | UserUpdateWithWhereUniqueWithoutInvitedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutInvitedByInput | UserUpdateManyWithWhereWithoutInvitedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUpdateOneWithoutInvitedUsersNestedInput = {
    create?: XOR<UserCreateWithoutInvitedUsersInput, UserUncheckedCreateWithoutInvitedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitedUsersInput
    upsert?: UserUpsertWithoutInvitedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitedUsersInput, UserUpdateWithoutInvitedUsersInput>, UserUncheckedUpdateWithoutInvitedUsersInput>
  }

  export type TrustedDeviceUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrustedDeviceCreateWithoutUserInput, TrustedDeviceUncheckedCreateWithoutUserInput> | TrustedDeviceCreateWithoutUserInput[] | TrustedDeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrustedDeviceCreateOrConnectWithoutUserInput | TrustedDeviceCreateOrConnectWithoutUserInput[]
    upsert?: TrustedDeviceUpsertWithWhereUniqueWithoutUserInput | TrustedDeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrustedDeviceCreateManyUserInputEnvelope
    set?: TrustedDeviceWhereUniqueInput | TrustedDeviceWhereUniqueInput[]
    disconnect?: TrustedDeviceWhereUniqueInput | TrustedDeviceWhereUniqueInput[]
    delete?: TrustedDeviceWhereUniqueInput | TrustedDeviceWhereUniqueInput[]
    connect?: TrustedDeviceWhereUniqueInput | TrustedDeviceWhereUniqueInput[]
    update?: TrustedDeviceUpdateWithWhereUniqueWithoutUserInput | TrustedDeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrustedDeviceUpdateManyWithWhereWithoutUserInput | TrustedDeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrustedDeviceScalarWhereInput | TrustedDeviceScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type OneSignalPlayerUpdateManyWithoutUserNestedInput = {
    create?: XOR<OneSignalPlayerCreateWithoutUserInput, OneSignalPlayerUncheckedCreateWithoutUserInput> | OneSignalPlayerCreateWithoutUserInput[] | OneSignalPlayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OneSignalPlayerCreateOrConnectWithoutUserInput | OneSignalPlayerCreateOrConnectWithoutUserInput[]
    upsert?: OneSignalPlayerUpsertWithWhereUniqueWithoutUserInput | OneSignalPlayerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OneSignalPlayerCreateManyUserInputEnvelope
    set?: OneSignalPlayerWhereUniqueInput | OneSignalPlayerWhereUniqueInput[]
    disconnect?: OneSignalPlayerWhereUniqueInput | OneSignalPlayerWhereUniqueInput[]
    delete?: OneSignalPlayerWhereUniqueInput | OneSignalPlayerWhereUniqueInput[]
    connect?: OneSignalPlayerWhereUniqueInput | OneSignalPlayerWhereUniqueInput[]
    update?: OneSignalPlayerUpdateWithWhereUniqueWithoutUserInput | OneSignalPlayerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OneSignalPlayerUpdateManyWithWhereWithoutUserInput | OneSignalPlayerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OneSignalPlayerScalarWhereInput | OneSignalPlayerScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReporterInput | ReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReporterInput | ReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReporterInput | ReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReportedUserNestedInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedUserInput | ReportUpsertWithWhereUniqueWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedUserInput | ReportUpdateWithWhereUniqueWithoutReportedUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedUserInput | ReportUpdateManyWithWhereWithoutReportedUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<ReportCreateWithoutReviewerInput, ReportUncheckedCreateWithoutReviewerInput> | ReportCreateWithoutReviewerInput[] | ReportUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReviewerInput | ReportCreateOrConnectWithoutReviewerInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReviewerInput | ReportUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: ReportCreateManyReviewerInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReviewerInput | ReportUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReviewerInput | ReportUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type GameSessionUpdateManyWithoutHostNestedInput = {
    create?: XOR<GameSessionCreateWithoutHostInput, GameSessionUncheckedCreateWithoutHostInput> | GameSessionCreateWithoutHostInput[] | GameSessionUncheckedCreateWithoutHostInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutHostInput | GameSessionCreateOrConnectWithoutHostInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutHostInput | GameSessionUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: GameSessionCreateManyHostInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutHostInput | GameSessionUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutHostInput | GameSessionUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type StreamUpdateManyWithoutBroadcasterNestedInput = {
    create?: XOR<StreamCreateWithoutBroadcasterInput, StreamUncheckedCreateWithoutBroadcasterInput> | StreamCreateWithoutBroadcasterInput[] | StreamUncheckedCreateWithoutBroadcasterInput[]
    connectOrCreate?: StreamCreateOrConnectWithoutBroadcasterInput | StreamCreateOrConnectWithoutBroadcasterInput[]
    upsert?: StreamUpsertWithWhereUniqueWithoutBroadcasterInput | StreamUpsertWithWhereUniqueWithoutBroadcasterInput[]
    createMany?: StreamCreateManyBroadcasterInputEnvelope
    set?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    disconnect?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    delete?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    connect?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    update?: StreamUpdateWithWhereUniqueWithoutBroadcasterInput | StreamUpdateWithWhereUniqueWithoutBroadcasterInput[]
    updateMany?: StreamUpdateManyWithWhereWithoutBroadcasterInput | StreamUpdateManyWithWhereWithoutBroadcasterInput[]
    deleteMany?: StreamScalarWhereInput | StreamScalarWhereInput[]
  }

  export type ChatRoomUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ChatRoomCreateWithoutOwnerInput, ChatRoomUncheckedCreateWithoutOwnerInput> | ChatRoomCreateWithoutOwnerInput[] | ChatRoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutOwnerInput | ChatRoomCreateOrConnectWithoutOwnerInput[]
    upsert?: ChatRoomUpsertWithWhereUniqueWithoutOwnerInput | ChatRoomUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ChatRoomCreateManyOwnerInputEnvelope
    set?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    disconnect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    delete?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    update?: ChatRoomUpdateWithWhereUniqueWithoutOwnerInput | ChatRoomUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ChatRoomUpdateManyWithWhereWithoutOwnerInput | ChatRoomUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
  }

  export type FollowRequestUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<FollowRequestCreateWithoutRequesterInput, FollowRequestUncheckedCreateWithoutRequesterInput> | FollowRequestCreateWithoutRequesterInput[] | FollowRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: FollowRequestCreateOrConnectWithoutRequesterInput | FollowRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: FollowRequestUpsertWithWhereUniqueWithoutRequesterInput | FollowRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: FollowRequestCreateManyRequesterInputEnvelope
    set?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    disconnect?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    delete?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    connect?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    update?: FollowRequestUpdateWithWhereUniqueWithoutRequesterInput | FollowRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: FollowRequestUpdateManyWithWhereWithoutRequesterInput | FollowRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: FollowRequestScalarWhereInput | FollowRequestScalarWhereInput[]
  }

  export type FollowRequestUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<FollowRequestCreateWithoutRecipientInput, FollowRequestUncheckedCreateWithoutRecipientInput> | FollowRequestCreateWithoutRecipientInput[] | FollowRequestUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: FollowRequestCreateOrConnectWithoutRecipientInput | FollowRequestCreateOrConnectWithoutRecipientInput[]
    upsert?: FollowRequestUpsertWithWhereUniqueWithoutRecipientInput | FollowRequestUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: FollowRequestCreateManyRecipientInputEnvelope
    set?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    disconnect?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    delete?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    connect?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    update?: FollowRequestUpdateWithWhereUniqueWithoutRecipientInput | FollowRequestUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: FollowRequestUpdateManyWithWhereWithoutRecipientInput | FollowRequestUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: FollowRequestScalarWhereInput | FollowRequestScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type GameLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameLikeCreateWithoutUserInput, GameLikeUncheckedCreateWithoutUserInput> | GameLikeCreateWithoutUserInput[] | GameLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameLikeCreateOrConnectWithoutUserInput | GameLikeCreateOrConnectWithoutUserInput[]
    upsert?: GameLikeUpsertWithWhereUniqueWithoutUserInput | GameLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameLikeCreateManyUserInputEnvelope
    set?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    disconnect?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    delete?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    connect?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    update?: GameLikeUpdateWithWhereUniqueWithoutUserInput | GameLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameLikeUpdateManyWithWhereWithoutUserInput | GameLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameLikeScalarWhereInput | GameLikeScalarWhereInput[]
  }

  export type GameRatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameRatingCreateWithoutUserInput, GameRatingUncheckedCreateWithoutUserInput> | GameRatingCreateWithoutUserInput[] | GameRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameRatingCreateOrConnectWithoutUserInput | GameRatingCreateOrConnectWithoutUserInput[]
    upsert?: GameRatingUpsertWithWhereUniqueWithoutUserInput | GameRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameRatingCreateManyUserInputEnvelope
    set?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    disconnect?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    delete?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    connect?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    update?: GameRatingUpdateWithWhereUniqueWithoutUserInput | GameRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameRatingUpdateManyWithWhereWithoutUserInput | GameRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameRatingScalarWhereInput | GameRatingScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutInvitedByNestedInput = {
    create?: XOR<UserCreateWithoutInvitedByInput, UserUncheckedCreateWithoutInvitedByInput> | UserCreateWithoutInvitedByInput[] | UserUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutInvitedByInput | UserCreateOrConnectWithoutInvitedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutInvitedByInput | UserUpsertWithWhereUniqueWithoutInvitedByInput[]
    createMany?: UserCreateManyInvitedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutInvitedByInput | UserUpdateWithWhereUniqueWithoutInvitedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutInvitedByInput | UserUpdateManyWithWhereWithoutInvitedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrustedDeviceCreateWithoutUserInput, TrustedDeviceUncheckedCreateWithoutUserInput> | TrustedDeviceCreateWithoutUserInput[] | TrustedDeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrustedDeviceCreateOrConnectWithoutUserInput | TrustedDeviceCreateOrConnectWithoutUserInput[]
    upsert?: TrustedDeviceUpsertWithWhereUniqueWithoutUserInput | TrustedDeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrustedDeviceCreateManyUserInputEnvelope
    set?: TrustedDeviceWhereUniqueInput | TrustedDeviceWhereUniqueInput[]
    disconnect?: TrustedDeviceWhereUniqueInput | TrustedDeviceWhereUniqueInput[]
    delete?: TrustedDeviceWhereUniqueInput | TrustedDeviceWhereUniqueInput[]
    connect?: TrustedDeviceWhereUniqueInput | TrustedDeviceWhereUniqueInput[]
    update?: TrustedDeviceUpdateWithWhereUniqueWithoutUserInput | TrustedDeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrustedDeviceUpdateManyWithWhereWithoutUserInput | TrustedDeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrustedDeviceScalarWhereInput | TrustedDeviceScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OneSignalPlayerCreateWithoutUserInput, OneSignalPlayerUncheckedCreateWithoutUserInput> | OneSignalPlayerCreateWithoutUserInput[] | OneSignalPlayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OneSignalPlayerCreateOrConnectWithoutUserInput | OneSignalPlayerCreateOrConnectWithoutUserInput[]
    upsert?: OneSignalPlayerUpsertWithWhereUniqueWithoutUserInput | OneSignalPlayerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OneSignalPlayerCreateManyUserInputEnvelope
    set?: OneSignalPlayerWhereUniqueInput | OneSignalPlayerWhereUniqueInput[]
    disconnect?: OneSignalPlayerWhereUniqueInput | OneSignalPlayerWhereUniqueInput[]
    delete?: OneSignalPlayerWhereUniqueInput | OneSignalPlayerWhereUniqueInput[]
    connect?: OneSignalPlayerWhereUniqueInput | OneSignalPlayerWhereUniqueInput[]
    update?: OneSignalPlayerUpdateWithWhereUniqueWithoutUserInput | OneSignalPlayerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OneSignalPlayerUpdateManyWithWhereWithoutUserInput | OneSignalPlayerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OneSignalPlayerScalarWhereInput | OneSignalPlayerScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReporterInput | ReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReporterInput | ReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReporterInput | ReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReportedUserNestedInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedUserInput | ReportUpsertWithWhereUniqueWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedUserInput | ReportUpdateWithWhereUniqueWithoutReportedUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedUserInput | ReportUpdateManyWithWhereWithoutReportedUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<ReportCreateWithoutReviewerInput, ReportUncheckedCreateWithoutReviewerInput> | ReportCreateWithoutReviewerInput[] | ReportUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReviewerInput | ReportCreateOrConnectWithoutReviewerInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReviewerInput | ReportUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: ReportCreateManyReviewerInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReviewerInput | ReportUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReviewerInput | ReportUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type GameSessionUncheckedUpdateManyWithoutHostNestedInput = {
    create?: XOR<GameSessionCreateWithoutHostInput, GameSessionUncheckedCreateWithoutHostInput> | GameSessionCreateWithoutHostInput[] | GameSessionUncheckedCreateWithoutHostInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutHostInput | GameSessionCreateOrConnectWithoutHostInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutHostInput | GameSessionUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: GameSessionCreateManyHostInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutHostInput | GameSessionUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutHostInput | GameSessionUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type StreamUncheckedUpdateManyWithoutBroadcasterNestedInput = {
    create?: XOR<StreamCreateWithoutBroadcasterInput, StreamUncheckedCreateWithoutBroadcasterInput> | StreamCreateWithoutBroadcasterInput[] | StreamUncheckedCreateWithoutBroadcasterInput[]
    connectOrCreate?: StreamCreateOrConnectWithoutBroadcasterInput | StreamCreateOrConnectWithoutBroadcasterInput[]
    upsert?: StreamUpsertWithWhereUniqueWithoutBroadcasterInput | StreamUpsertWithWhereUniqueWithoutBroadcasterInput[]
    createMany?: StreamCreateManyBroadcasterInputEnvelope
    set?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    disconnect?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    delete?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    connect?: StreamWhereUniqueInput | StreamWhereUniqueInput[]
    update?: StreamUpdateWithWhereUniqueWithoutBroadcasterInput | StreamUpdateWithWhereUniqueWithoutBroadcasterInput[]
    updateMany?: StreamUpdateManyWithWhereWithoutBroadcasterInput | StreamUpdateManyWithWhereWithoutBroadcasterInput[]
    deleteMany?: StreamScalarWhereInput | StreamScalarWhereInput[]
  }

  export type ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ChatRoomCreateWithoutOwnerInput, ChatRoomUncheckedCreateWithoutOwnerInput> | ChatRoomCreateWithoutOwnerInput[] | ChatRoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutOwnerInput | ChatRoomCreateOrConnectWithoutOwnerInput[]
    upsert?: ChatRoomUpsertWithWhereUniqueWithoutOwnerInput | ChatRoomUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ChatRoomCreateManyOwnerInputEnvelope
    set?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    disconnect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    delete?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    update?: ChatRoomUpdateWithWhereUniqueWithoutOwnerInput | ChatRoomUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ChatRoomUpdateManyWithWhereWithoutOwnerInput | ChatRoomUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
  }

  export type FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<FollowRequestCreateWithoutRequesterInput, FollowRequestUncheckedCreateWithoutRequesterInput> | FollowRequestCreateWithoutRequesterInput[] | FollowRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: FollowRequestCreateOrConnectWithoutRequesterInput | FollowRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: FollowRequestUpsertWithWhereUniqueWithoutRequesterInput | FollowRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: FollowRequestCreateManyRequesterInputEnvelope
    set?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    disconnect?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    delete?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    connect?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    update?: FollowRequestUpdateWithWhereUniqueWithoutRequesterInput | FollowRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: FollowRequestUpdateManyWithWhereWithoutRequesterInput | FollowRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: FollowRequestScalarWhereInput | FollowRequestScalarWhereInput[]
  }

  export type FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<FollowRequestCreateWithoutRecipientInput, FollowRequestUncheckedCreateWithoutRecipientInput> | FollowRequestCreateWithoutRecipientInput[] | FollowRequestUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: FollowRequestCreateOrConnectWithoutRecipientInput | FollowRequestCreateOrConnectWithoutRecipientInput[]
    upsert?: FollowRequestUpsertWithWhereUniqueWithoutRecipientInput | FollowRequestUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: FollowRequestCreateManyRecipientInputEnvelope
    set?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    disconnect?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    delete?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    connect?: FollowRequestWhereUniqueInput | FollowRequestWhereUniqueInput[]
    update?: FollowRequestUpdateWithWhereUniqueWithoutRecipientInput | FollowRequestUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: FollowRequestUpdateManyWithWhereWithoutRecipientInput | FollowRequestUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: FollowRequestScalarWhereInput | FollowRequestScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type GameLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameLikeCreateWithoutUserInput, GameLikeUncheckedCreateWithoutUserInput> | GameLikeCreateWithoutUserInput[] | GameLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameLikeCreateOrConnectWithoutUserInput | GameLikeCreateOrConnectWithoutUserInput[]
    upsert?: GameLikeUpsertWithWhereUniqueWithoutUserInput | GameLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameLikeCreateManyUserInputEnvelope
    set?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    disconnect?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    delete?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    connect?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    update?: GameLikeUpdateWithWhereUniqueWithoutUserInput | GameLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameLikeUpdateManyWithWhereWithoutUserInput | GameLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameLikeScalarWhereInput | GameLikeScalarWhereInput[]
  }

  export type GameRatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameRatingCreateWithoutUserInput, GameRatingUncheckedCreateWithoutUserInput> | GameRatingCreateWithoutUserInput[] | GameRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameRatingCreateOrConnectWithoutUserInput | GameRatingCreateOrConnectWithoutUserInput[]
    upsert?: GameRatingUpsertWithWhereUniqueWithoutUserInput | GameRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameRatingCreateManyUserInputEnvelope
    set?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    disconnect?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    delete?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    connect?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    update?: GameRatingUpdateWithWhereUniqueWithoutUserInput | GameRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameRatingUpdateManyWithWhereWithoutUserInput | GameRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameRatingScalarWhereInput | GameRatingScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOwnedChatRoomsInput = {
    create?: XOR<UserCreateWithoutOwnedChatRoomsInput, UserUncheckedCreateWithoutOwnedChatRoomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedChatRoomsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutRoomInput = {
    create?: XOR<MessageCreateWithoutRoomInput, MessageUncheckedCreateWithoutRoomInput> | MessageCreateWithoutRoomInput[] | MessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRoomInput | MessageCreateOrConnectWithoutRoomInput[]
    createMany?: MessageCreateManyRoomInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReportedRoomInput = {
    create?: XOR<ReportCreateWithoutReportedRoomInput, ReportUncheckedCreateWithoutReportedRoomInput> | ReportCreateWithoutReportedRoomInput[] | ReportUncheckedCreateWithoutReportedRoomInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedRoomInput | ReportCreateOrConnectWithoutReportedRoomInput[]
    createMany?: ReportCreateManyReportedRoomInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<MessageCreateWithoutRoomInput, MessageUncheckedCreateWithoutRoomInput> | MessageCreateWithoutRoomInput[] | MessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRoomInput | MessageCreateOrConnectWithoutRoomInput[]
    createMany?: MessageCreateManyRoomInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedRoomInput = {
    create?: XOR<ReportCreateWithoutReportedRoomInput, ReportUncheckedCreateWithoutReportedRoomInput> | ReportCreateWithoutReportedRoomInput[] | ReportUncheckedCreateWithoutReportedRoomInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedRoomInput | ReportCreateOrConnectWithoutReportedRoomInput[]
    createMany?: ReportCreateManyReportedRoomInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EnumChatRoomTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChatRoomType
  }

  export type EnumChatRoomStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChatRoomStatus
  }

  export type UserUpdateOneRequiredWithoutOwnedChatRoomsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedChatRoomsInput, UserUncheckedCreateWithoutOwnedChatRoomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedChatRoomsInput
    upsert?: UserUpsertWithoutOwnedChatRoomsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedChatRoomsInput, UserUpdateWithoutOwnedChatRoomsInput>, UserUncheckedUpdateWithoutOwnedChatRoomsInput>
  }

  export type MessageUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MessageCreateWithoutRoomInput, MessageUncheckedCreateWithoutRoomInput> | MessageCreateWithoutRoomInput[] | MessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRoomInput | MessageCreateOrConnectWithoutRoomInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRoomInput | MessageUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MessageCreateManyRoomInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRoomInput | MessageUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRoomInput | MessageUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReportedRoomNestedInput = {
    create?: XOR<ReportCreateWithoutReportedRoomInput, ReportUncheckedCreateWithoutReportedRoomInput> | ReportCreateWithoutReportedRoomInput[] | ReportUncheckedCreateWithoutReportedRoomInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedRoomInput | ReportCreateOrConnectWithoutReportedRoomInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedRoomInput | ReportUpsertWithWhereUniqueWithoutReportedRoomInput[]
    createMany?: ReportCreateManyReportedRoomInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedRoomInput | ReportUpdateWithWhereUniqueWithoutReportedRoomInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedRoomInput | ReportUpdateManyWithWhereWithoutReportedRoomInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MessageCreateWithoutRoomInput, MessageUncheckedCreateWithoutRoomInput> | MessageCreateWithoutRoomInput[] | MessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRoomInput | MessageCreateOrConnectWithoutRoomInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRoomInput | MessageUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MessageCreateManyRoomInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRoomInput | MessageUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRoomInput | MessageUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReportedRoomNestedInput = {
    create?: XOR<ReportCreateWithoutReportedRoomInput, ReportUncheckedCreateWithoutReportedRoomInput> | ReportCreateWithoutReportedRoomInput[] | ReportUncheckedCreateWithoutReportedRoomInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedRoomInput | ReportCreateOrConnectWithoutReportedRoomInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedRoomInput | ReportUpsertWithWhereUniqueWithoutReportedRoomInput[]
    createMany?: ReportCreateManyReportedRoomInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedRoomInput | ReportUpdateWithWhereUniqueWithoutReportedRoomInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedRoomInput | ReportUpdateManyWithWhereWithoutReportedRoomInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ChatRoomCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatRoomCreateWithoutMessagesInput, ChatRoomUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatRoomCreateOrConnectWithoutMessagesInput
    connect?: ChatRoomWhereUniqueInput
  }

  export type GiftCreateNestedOneWithoutMessagesInput = {
    create?: XOR<GiftCreateWithoutMessagesInput, GiftUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: GiftCreateOrConnectWithoutMessagesInput
    connect?: GiftWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutRepliesInput = {
    create?: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRepliesInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutRepliedToMessageInput = {
    create?: XOR<MessageCreateWithoutRepliedToMessageInput, MessageUncheckedCreateWithoutRepliedToMessageInput> | MessageCreateWithoutRepliedToMessageInput[] | MessageUncheckedCreateWithoutRepliedToMessageInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRepliedToMessageInput | MessageCreateOrConnectWithoutRepliedToMessageInput[]
    createMany?: MessageCreateManyRepliedToMessageInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReportedMessageInput = {
    create?: XOR<ReportCreateWithoutReportedMessageInput, ReportUncheckedCreateWithoutReportedMessageInput> | ReportCreateWithoutReportedMessageInput[] | ReportUncheckedCreateWithoutReportedMessageInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedMessageInput | ReportCreateOrConnectWithoutReportedMessageInput[]
    createMany?: ReportCreateManyReportedMessageInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutRepliedToMessageInput = {
    create?: XOR<MessageCreateWithoutRepliedToMessageInput, MessageUncheckedCreateWithoutRepliedToMessageInput> | MessageCreateWithoutRepliedToMessageInput[] | MessageUncheckedCreateWithoutRepliedToMessageInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRepliedToMessageInput | MessageCreateOrConnectWithoutRepliedToMessageInput[]
    createMany?: MessageCreateManyRepliedToMessageInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedMessageInput = {
    create?: XOR<ReportCreateWithoutReportedMessageInput, ReportUncheckedCreateWithoutReportedMessageInput> | ReportCreateWithoutReportedMessageInput[] | ReportUncheckedCreateWithoutReportedMessageInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedMessageInput | ReportCreateOrConnectWithoutReportedMessageInput[]
    createMany?: ReportCreateManyReportedMessageInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type ChatRoomUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<ChatRoomCreateWithoutMessagesInput, ChatRoomUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatRoomCreateOrConnectWithoutMessagesInput
    upsert?: ChatRoomUpsertWithoutMessagesInput
    disconnect?: ChatRoomWhereInput | boolean
    delete?: ChatRoomWhereInput | boolean
    connect?: ChatRoomWhereUniqueInput
    update?: XOR<XOR<ChatRoomUpdateToOneWithWhereWithoutMessagesInput, ChatRoomUpdateWithoutMessagesInput>, ChatRoomUncheckedUpdateWithoutMessagesInput>
  }

  export type GiftUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<GiftCreateWithoutMessagesInput, GiftUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: GiftCreateOrConnectWithoutMessagesInput
    upsert?: GiftUpsertWithoutMessagesInput
    disconnect?: GiftWhereInput | boolean
    delete?: GiftWhereInput | boolean
    connect?: GiftWhereUniqueInput
    update?: XOR<XOR<GiftUpdateToOneWithWhereWithoutMessagesInput, GiftUpdateWithoutMessagesInput>, GiftUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRepliesInput
    upsert?: MessageUpsertWithoutRepliesInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutRepliesInput, MessageUpdateWithoutRepliesInput>, MessageUncheckedUpdateWithoutRepliesInput>
  }

  export type MessageUpdateManyWithoutRepliedToMessageNestedInput = {
    create?: XOR<MessageCreateWithoutRepliedToMessageInput, MessageUncheckedCreateWithoutRepliedToMessageInput> | MessageCreateWithoutRepliedToMessageInput[] | MessageUncheckedCreateWithoutRepliedToMessageInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRepliedToMessageInput | MessageCreateOrConnectWithoutRepliedToMessageInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRepliedToMessageInput | MessageUpsertWithWhereUniqueWithoutRepliedToMessageInput[]
    createMany?: MessageCreateManyRepliedToMessageInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRepliedToMessageInput | MessageUpdateWithWhereUniqueWithoutRepliedToMessageInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRepliedToMessageInput | MessageUpdateManyWithWhereWithoutRepliedToMessageInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReportedMessageNestedInput = {
    create?: XOR<ReportCreateWithoutReportedMessageInput, ReportUncheckedCreateWithoutReportedMessageInput> | ReportCreateWithoutReportedMessageInput[] | ReportUncheckedCreateWithoutReportedMessageInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedMessageInput | ReportCreateOrConnectWithoutReportedMessageInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedMessageInput | ReportUpsertWithWhereUniqueWithoutReportedMessageInput[]
    createMany?: ReportCreateManyReportedMessageInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedMessageInput | ReportUpdateWithWhereUniqueWithoutReportedMessageInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedMessageInput | ReportUpdateManyWithWhereWithoutReportedMessageInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutRepliedToMessageNestedInput = {
    create?: XOR<MessageCreateWithoutRepliedToMessageInput, MessageUncheckedCreateWithoutRepliedToMessageInput> | MessageCreateWithoutRepliedToMessageInput[] | MessageUncheckedCreateWithoutRepliedToMessageInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRepliedToMessageInput | MessageCreateOrConnectWithoutRepliedToMessageInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRepliedToMessageInput | MessageUpsertWithWhereUniqueWithoutRepliedToMessageInput[]
    createMany?: MessageCreateManyRepliedToMessageInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRepliedToMessageInput | MessageUpdateWithWhereUniqueWithoutRepliedToMessageInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRepliedToMessageInput | MessageUpdateManyWithWhereWithoutRepliedToMessageInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReportedMessageNestedInput = {
    create?: XOR<ReportCreateWithoutReportedMessageInput, ReportUncheckedCreateWithoutReportedMessageInput> | ReportCreateWithoutReportedMessageInput[] | ReportUncheckedCreateWithoutReportedMessageInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedMessageInput | ReportCreateOrConnectWithoutReportedMessageInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedMessageInput | ReportUpsertWithWhereUniqueWithoutReportedMessageInput[]
    createMany?: ReportCreateManyReportedMessageInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedMessageInput | ReportUpdateWithWhereUniqueWithoutReportedMessageInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedMessageInput | ReportUpdateManyWithWhereWithoutReportedMessageInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowedByInput = {
    create?: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingInput, UserUpdateWithoutFollowingInput>, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateOneRequiredWithoutFollowedByNestedInput = {
    create?: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedByInput
    upsert?: UserUpsertWithoutFollowedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowedByInput, UserUpdateWithoutFollowedByInput>, UserUncheckedUpdateWithoutFollowedByInput>
  }

  export type UserCreateNestedOneWithoutSentFollowRequestsInput = {
    create?: XOR<UserCreateWithoutSentFollowRequestsInput, UserUncheckedCreateWithoutSentFollowRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentFollowRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedFollowRequestsInput = {
    create?: XOR<UserCreateWithoutReceivedFollowRequestsInput, UserUncheckedCreateWithoutReceivedFollowRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedFollowRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFollowRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.FollowRequestStatus
  }

  export type UserUpdateOneRequiredWithoutSentFollowRequestsNestedInput = {
    create?: XOR<UserCreateWithoutSentFollowRequestsInput, UserUncheckedCreateWithoutSentFollowRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentFollowRequestsInput
    upsert?: UserUpsertWithoutSentFollowRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentFollowRequestsInput, UserUpdateWithoutSentFollowRequestsInput>, UserUncheckedUpdateWithoutSentFollowRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedFollowRequestsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedFollowRequestsInput, UserUncheckedCreateWithoutReceivedFollowRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedFollowRequestsInput
    upsert?: UserUpsertWithoutReceivedFollowRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedFollowRequestsInput, UserUpdateWithoutReceivedFollowRequestsInput>, UserUncheckedUpdateWithoutReceivedFollowRequestsInput>
  }

  export type GameCategoryCreateNestedOneWithoutGamesInput = {
    create?: XOR<GameCategoryCreateWithoutGamesInput, GameCategoryUncheckedCreateWithoutGamesInput>
    connectOrCreate?: GameCategoryCreateOrConnectWithoutGamesInput
    connect?: GameCategoryWhereUniqueInput
  }

  export type GameGenreTagCreateNestedManyWithoutGameInput = {
    create?: XOR<GameGenreTagCreateWithoutGameInput, GameGenreTagUncheckedCreateWithoutGameInput> | GameGenreTagCreateWithoutGameInput[] | GameGenreTagUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameGenreTagCreateOrConnectWithoutGameInput | GameGenreTagCreateOrConnectWithoutGameInput[]
    createMany?: GameGenreTagCreateManyGameInputEnvelope
    connect?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
  }

  export type GameSessionCreateNestedManyWithoutGameInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type GameLikeCreateNestedManyWithoutGameInput = {
    create?: XOR<GameLikeCreateWithoutGameInput, GameLikeUncheckedCreateWithoutGameInput> | GameLikeCreateWithoutGameInput[] | GameLikeUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameLikeCreateOrConnectWithoutGameInput | GameLikeCreateOrConnectWithoutGameInput[]
    createMany?: GameLikeCreateManyGameInputEnvelope
    connect?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
  }

  export type GameRatingCreateNestedManyWithoutGameInput = {
    create?: XOR<GameRatingCreateWithoutGameInput, GameRatingUncheckedCreateWithoutGameInput> | GameRatingCreateWithoutGameInput[] | GameRatingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameRatingCreateOrConnectWithoutGameInput | GameRatingCreateOrConnectWithoutGameInput[]
    createMany?: GameRatingCreateManyGameInputEnvelope
    connect?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
  }

  export type GameGenreTagUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameGenreTagCreateWithoutGameInput, GameGenreTagUncheckedCreateWithoutGameInput> | GameGenreTagCreateWithoutGameInput[] | GameGenreTagUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameGenreTagCreateOrConnectWithoutGameInput | GameGenreTagCreateOrConnectWithoutGameInput[]
    createMany?: GameGenreTagCreateManyGameInputEnvelope
    connect?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
  }

  export type GameSessionUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type GameLikeUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameLikeCreateWithoutGameInput, GameLikeUncheckedCreateWithoutGameInput> | GameLikeCreateWithoutGameInput[] | GameLikeUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameLikeCreateOrConnectWithoutGameInput | GameLikeCreateOrConnectWithoutGameInput[]
    createMany?: GameLikeCreateManyGameInputEnvelope
    connect?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
  }

  export type GameRatingUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameRatingCreateWithoutGameInput, GameRatingUncheckedCreateWithoutGameInput> | GameRatingCreateWithoutGameInput[] | GameRatingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameRatingCreateOrConnectWithoutGameInput | GameRatingCreateOrConnectWithoutGameInput[]
    createMany?: GameRatingCreateManyGameInputEnvelope
    connect?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GameCategoryUpdateOneWithoutGamesNestedInput = {
    create?: XOR<GameCategoryCreateWithoutGamesInput, GameCategoryUncheckedCreateWithoutGamesInput>
    connectOrCreate?: GameCategoryCreateOrConnectWithoutGamesInput
    upsert?: GameCategoryUpsertWithoutGamesInput
    disconnect?: GameCategoryWhereInput | boolean
    delete?: GameCategoryWhereInput | boolean
    connect?: GameCategoryWhereUniqueInput
    update?: XOR<XOR<GameCategoryUpdateToOneWithWhereWithoutGamesInput, GameCategoryUpdateWithoutGamesInput>, GameCategoryUncheckedUpdateWithoutGamesInput>
  }

  export type GameGenreTagUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameGenreTagCreateWithoutGameInput, GameGenreTagUncheckedCreateWithoutGameInput> | GameGenreTagCreateWithoutGameInput[] | GameGenreTagUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameGenreTagCreateOrConnectWithoutGameInput | GameGenreTagCreateOrConnectWithoutGameInput[]
    upsert?: GameGenreTagUpsertWithWhereUniqueWithoutGameInput | GameGenreTagUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameGenreTagCreateManyGameInputEnvelope
    set?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    disconnect?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    delete?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    connect?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    update?: GameGenreTagUpdateWithWhereUniqueWithoutGameInput | GameGenreTagUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameGenreTagUpdateManyWithWhereWithoutGameInput | GameGenreTagUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameGenreTagScalarWhereInput | GameGenreTagScalarWhereInput[]
  }

  export type GameSessionUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutGameInput | GameSessionUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutGameInput | GameSessionUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutGameInput | GameSessionUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type GameLikeUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameLikeCreateWithoutGameInput, GameLikeUncheckedCreateWithoutGameInput> | GameLikeCreateWithoutGameInput[] | GameLikeUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameLikeCreateOrConnectWithoutGameInput | GameLikeCreateOrConnectWithoutGameInput[]
    upsert?: GameLikeUpsertWithWhereUniqueWithoutGameInput | GameLikeUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameLikeCreateManyGameInputEnvelope
    set?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    disconnect?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    delete?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    connect?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    update?: GameLikeUpdateWithWhereUniqueWithoutGameInput | GameLikeUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameLikeUpdateManyWithWhereWithoutGameInput | GameLikeUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameLikeScalarWhereInput | GameLikeScalarWhereInput[]
  }

  export type GameRatingUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameRatingCreateWithoutGameInput, GameRatingUncheckedCreateWithoutGameInput> | GameRatingCreateWithoutGameInput[] | GameRatingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameRatingCreateOrConnectWithoutGameInput | GameRatingCreateOrConnectWithoutGameInput[]
    upsert?: GameRatingUpsertWithWhereUniqueWithoutGameInput | GameRatingUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameRatingCreateManyGameInputEnvelope
    set?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    disconnect?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    delete?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    connect?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    update?: GameRatingUpdateWithWhereUniqueWithoutGameInput | GameRatingUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameRatingUpdateManyWithWhereWithoutGameInput | GameRatingUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameRatingScalarWhereInput | GameRatingScalarWhereInput[]
  }

  export type GameGenreTagUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameGenreTagCreateWithoutGameInput, GameGenreTagUncheckedCreateWithoutGameInput> | GameGenreTagCreateWithoutGameInput[] | GameGenreTagUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameGenreTagCreateOrConnectWithoutGameInput | GameGenreTagCreateOrConnectWithoutGameInput[]
    upsert?: GameGenreTagUpsertWithWhereUniqueWithoutGameInput | GameGenreTagUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameGenreTagCreateManyGameInputEnvelope
    set?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    disconnect?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    delete?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    connect?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    update?: GameGenreTagUpdateWithWhereUniqueWithoutGameInput | GameGenreTagUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameGenreTagUpdateManyWithWhereWithoutGameInput | GameGenreTagUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameGenreTagScalarWhereInput | GameGenreTagScalarWhereInput[]
  }

  export type GameSessionUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutGameInput | GameSessionUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutGameInput | GameSessionUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutGameInput | GameSessionUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type GameLikeUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameLikeCreateWithoutGameInput, GameLikeUncheckedCreateWithoutGameInput> | GameLikeCreateWithoutGameInput[] | GameLikeUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameLikeCreateOrConnectWithoutGameInput | GameLikeCreateOrConnectWithoutGameInput[]
    upsert?: GameLikeUpsertWithWhereUniqueWithoutGameInput | GameLikeUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameLikeCreateManyGameInputEnvelope
    set?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    disconnect?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    delete?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    connect?: GameLikeWhereUniqueInput | GameLikeWhereUniqueInput[]
    update?: GameLikeUpdateWithWhereUniqueWithoutGameInput | GameLikeUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameLikeUpdateManyWithWhereWithoutGameInput | GameLikeUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameLikeScalarWhereInput | GameLikeScalarWhereInput[]
  }

  export type GameRatingUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameRatingCreateWithoutGameInput, GameRatingUncheckedCreateWithoutGameInput> | GameRatingCreateWithoutGameInput[] | GameRatingUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameRatingCreateOrConnectWithoutGameInput | GameRatingCreateOrConnectWithoutGameInput[]
    upsert?: GameRatingUpsertWithWhereUniqueWithoutGameInput | GameRatingUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameRatingCreateManyGameInputEnvelope
    set?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    disconnect?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    delete?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    connect?: GameRatingWhereUniqueInput | GameRatingWhereUniqueInput[]
    update?: GameRatingUpdateWithWhereUniqueWithoutGameInput | GameRatingUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameRatingUpdateManyWithWhereWithoutGameInput | GameRatingUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameRatingScalarWhereInput | GameRatingScalarWhereInput[]
  }

  export type GameGenreTagCreateNestedManyWithoutGenreTagInput = {
    create?: XOR<GameGenreTagCreateWithoutGenreTagInput, GameGenreTagUncheckedCreateWithoutGenreTagInput> | GameGenreTagCreateWithoutGenreTagInput[] | GameGenreTagUncheckedCreateWithoutGenreTagInput[]
    connectOrCreate?: GameGenreTagCreateOrConnectWithoutGenreTagInput | GameGenreTagCreateOrConnectWithoutGenreTagInput[]
    createMany?: GameGenreTagCreateManyGenreTagInputEnvelope
    connect?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
  }

  export type GameGenreTagUncheckedCreateNestedManyWithoutGenreTagInput = {
    create?: XOR<GameGenreTagCreateWithoutGenreTagInput, GameGenreTagUncheckedCreateWithoutGenreTagInput> | GameGenreTagCreateWithoutGenreTagInput[] | GameGenreTagUncheckedCreateWithoutGenreTagInput[]
    connectOrCreate?: GameGenreTagCreateOrConnectWithoutGenreTagInput | GameGenreTagCreateOrConnectWithoutGenreTagInput[]
    createMany?: GameGenreTagCreateManyGenreTagInputEnvelope
    connect?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
  }

  export type GameGenreTagUpdateManyWithoutGenreTagNestedInput = {
    create?: XOR<GameGenreTagCreateWithoutGenreTagInput, GameGenreTagUncheckedCreateWithoutGenreTagInput> | GameGenreTagCreateWithoutGenreTagInput[] | GameGenreTagUncheckedCreateWithoutGenreTagInput[]
    connectOrCreate?: GameGenreTagCreateOrConnectWithoutGenreTagInput | GameGenreTagCreateOrConnectWithoutGenreTagInput[]
    upsert?: GameGenreTagUpsertWithWhereUniqueWithoutGenreTagInput | GameGenreTagUpsertWithWhereUniqueWithoutGenreTagInput[]
    createMany?: GameGenreTagCreateManyGenreTagInputEnvelope
    set?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    disconnect?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    delete?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    connect?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    update?: GameGenreTagUpdateWithWhereUniqueWithoutGenreTagInput | GameGenreTagUpdateWithWhereUniqueWithoutGenreTagInput[]
    updateMany?: GameGenreTagUpdateManyWithWhereWithoutGenreTagInput | GameGenreTagUpdateManyWithWhereWithoutGenreTagInput[]
    deleteMany?: GameGenreTagScalarWhereInput | GameGenreTagScalarWhereInput[]
  }

  export type GameGenreTagUncheckedUpdateManyWithoutGenreTagNestedInput = {
    create?: XOR<GameGenreTagCreateWithoutGenreTagInput, GameGenreTagUncheckedCreateWithoutGenreTagInput> | GameGenreTagCreateWithoutGenreTagInput[] | GameGenreTagUncheckedCreateWithoutGenreTagInput[]
    connectOrCreate?: GameGenreTagCreateOrConnectWithoutGenreTagInput | GameGenreTagCreateOrConnectWithoutGenreTagInput[]
    upsert?: GameGenreTagUpsertWithWhereUniqueWithoutGenreTagInput | GameGenreTagUpsertWithWhereUniqueWithoutGenreTagInput[]
    createMany?: GameGenreTagCreateManyGenreTagInputEnvelope
    set?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    disconnect?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    delete?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    connect?: GameGenreTagWhereUniqueInput | GameGenreTagWhereUniqueInput[]
    update?: GameGenreTagUpdateWithWhereUniqueWithoutGenreTagInput | GameGenreTagUpdateWithWhereUniqueWithoutGenreTagInput[]
    updateMany?: GameGenreTagUpdateManyWithWhereWithoutGenreTagInput | GameGenreTagUpdateManyWithWhereWithoutGenreTagInput[]
    deleteMany?: GameGenreTagScalarWhereInput | GameGenreTagScalarWhereInput[]
  }

  export type GameCreateNestedOneWithoutGameGenreTagsInput = {
    create?: XOR<GameCreateWithoutGameGenreTagsInput, GameUncheckedCreateWithoutGameGenreTagsInput>
    connectOrCreate?: GameCreateOrConnectWithoutGameGenreTagsInput
    connect?: GameWhereUniqueInput
  }

  export type GenreTagCreateNestedOneWithoutGameGenreTagsInput = {
    create?: XOR<GenreTagCreateWithoutGameGenreTagsInput, GenreTagUncheckedCreateWithoutGameGenreTagsInput>
    connectOrCreate?: GenreTagCreateOrConnectWithoutGameGenreTagsInput
    connect?: GenreTagWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutGameGenreTagsNestedInput = {
    create?: XOR<GameCreateWithoutGameGenreTagsInput, GameUncheckedCreateWithoutGameGenreTagsInput>
    connectOrCreate?: GameCreateOrConnectWithoutGameGenreTagsInput
    upsert?: GameUpsertWithoutGameGenreTagsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutGameGenreTagsInput, GameUpdateWithoutGameGenreTagsInput>, GameUncheckedUpdateWithoutGameGenreTagsInput>
  }

  export type GenreTagUpdateOneRequiredWithoutGameGenreTagsNestedInput = {
    create?: XOR<GenreTagCreateWithoutGameGenreTagsInput, GenreTagUncheckedCreateWithoutGameGenreTagsInput>
    connectOrCreate?: GenreTagCreateOrConnectWithoutGameGenreTagsInput
    upsert?: GenreTagUpsertWithoutGameGenreTagsInput
    connect?: GenreTagWhereUniqueInput
    update?: XOR<XOR<GenreTagUpdateToOneWithWhereWithoutGameGenreTagsInput, GenreTagUpdateWithoutGameGenreTagsInput>, GenreTagUncheckedUpdateWithoutGameGenreTagsInput>
  }

  export type UserCreateNestedOneWithoutLikedGamesInput = {
    create?: XOR<UserCreateWithoutLikedGamesInput, UserUncheckedCreateWithoutLikedGamesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedGamesInput
    connect?: UserWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutLikesInput = {
    create?: XOR<GameCreateWithoutLikesInput, GameUncheckedCreateWithoutLikesInput>
    connectOrCreate?: GameCreateOrConnectWithoutLikesInput
    connect?: GameWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikedGamesNestedInput = {
    create?: XOR<UserCreateWithoutLikedGamesInput, UserUncheckedCreateWithoutLikedGamesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedGamesInput
    upsert?: UserUpsertWithoutLikedGamesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikedGamesInput, UserUpdateWithoutLikedGamesInput>, UserUncheckedUpdateWithoutLikedGamesInput>
  }

  export type GameUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<GameCreateWithoutLikesInput, GameUncheckedCreateWithoutLikesInput>
    connectOrCreate?: GameCreateOrConnectWithoutLikesInput
    upsert?: GameUpsertWithoutLikesInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutLikesInput, GameUpdateWithoutLikesInput>, GameUncheckedUpdateWithoutLikesInput>
  }

  export type UserCreateNestedOneWithoutGameRatingsInput = {
    create?: XOR<UserCreateWithoutGameRatingsInput, UserUncheckedCreateWithoutGameRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutRatingsInput = {
    create?: XOR<GameCreateWithoutRatingsInput, GameUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: GameCreateOrConnectWithoutRatingsInput
    connect?: GameWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGameRatingsNestedInput = {
    create?: XOR<UserCreateWithoutGameRatingsInput, UserUncheckedCreateWithoutGameRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameRatingsInput
    upsert?: UserUpsertWithoutGameRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGameRatingsInput, UserUpdateWithoutGameRatingsInput>, UserUncheckedUpdateWithoutGameRatingsInput>
  }

  export type GameUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<GameCreateWithoutRatingsInput, GameUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: GameCreateOrConnectWithoutRatingsInput
    upsert?: GameUpsertWithoutRatingsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutRatingsInput, GameUpdateWithoutRatingsInput>, GameUncheckedUpdateWithoutRatingsInput>
  }

  export type GameCreateNestedManyWithoutCategoryInput = {
    create?: XOR<GameCreateWithoutCategoryInput, GameUncheckedCreateWithoutCategoryInput> | GameCreateWithoutCategoryInput[] | GameUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GameCreateOrConnectWithoutCategoryInput | GameCreateOrConnectWithoutCategoryInput[]
    createMany?: GameCreateManyCategoryInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<GameCreateWithoutCategoryInput, GameUncheckedCreateWithoutCategoryInput> | GameCreateWithoutCategoryInput[] | GameUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GameCreateOrConnectWithoutCategoryInput | GameCreateOrConnectWithoutCategoryInput[]
    createMany?: GameCreateManyCategoryInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<GameCreateWithoutCategoryInput, GameUncheckedCreateWithoutCategoryInput> | GameCreateWithoutCategoryInput[] | GameUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GameCreateOrConnectWithoutCategoryInput | GameCreateOrConnectWithoutCategoryInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutCategoryInput | GameUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: GameCreateManyCategoryInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutCategoryInput | GameUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: GameUpdateManyWithWhereWithoutCategoryInput | GameUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<GameCreateWithoutCategoryInput, GameUncheckedCreateWithoutCategoryInput> | GameCreateWithoutCategoryInput[] | GameUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GameCreateOrConnectWithoutCategoryInput | GameCreateOrConnectWithoutCategoryInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutCategoryInput | GameUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: GameCreateManyCategoryInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutCategoryInput | GameUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: GameUpdateManyWithWhereWithoutCategoryInput | GameUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameCreateNestedOneWithoutGameSessionsInput = {
    create?: XOR<GameCreateWithoutGameSessionsInput, GameUncheckedCreateWithoutGameSessionsInput>
    connectOrCreate?: GameCreateOrConnectWithoutGameSessionsInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHostedGameSessionsInput = {
    create?: XOR<UserCreateWithoutHostedGameSessionsInput, UserUncheckedCreateWithoutHostedGameSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHostedGameSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGameSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.GameSessionStatus
  }

  export type GameUpdateOneRequiredWithoutGameSessionsNestedInput = {
    create?: XOR<GameCreateWithoutGameSessionsInput, GameUncheckedCreateWithoutGameSessionsInput>
    connectOrCreate?: GameCreateOrConnectWithoutGameSessionsInput
    upsert?: GameUpsertWithoutGameSessionsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutGameSessionsInput, GameUpdateWithoutGameSessionsInput>, GameUncheckedUpdateWithoutGameSessionsInput>
  }

  export type UserUpdateOneRequiredWithoutHostedGameSessionsNestedInput = {
    create?: XOR<UserCreateWithoutHostedGameSessionsInput, UserUncheckedCreateWithoutHostedGameSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHostedGameSessionsInput
    upsert?: UserUpsertWithoutHostedGameSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHostedGameSessionsInput, UserUpdateWithoutHostedGameSessionsInput>, UserUncheckedUpdateWithoutHostedGameSessionsInput>
  }

  export type MessageCreateNestedManyWithoutGiftInput = {
    create?: XOR<MessageCreateWithoutGiftInput, MessageUncheckedCreateWithoutGiftInput> | MessageCreateWithoutGiftInput[] | MessageUncheckedCreateWithoutGiftInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGiftInput | MessageCreateOrConnectWithoutGiftInput[]
    createMany?: MessageCreateManyGiftInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutGiftInput = {
    create?: XOR<MessageCreateWithoutGiftInput, MessageUncheckedCreateWithoutGiftInput> | MessageCreateWithoutGiftInput[] | MessageUncheckedCreateWithoutGiftInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGiftInput | MessageCreateOrConnectWithoutGiftInput[]
    createMany?: MessageCreateManyGiftInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUpdateManyWithoutGiftNestedInput = {
    create?: XOR<MessageCreateWithoutGiftInput, MessageUncheckedCreateWithoutGiftInput> | MessageCreateWithoutGiftInput[] | MessageUncheckedCreateWithoutGiftInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGiftInput | MessageCreateOrConnectWithoutGiftInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutGiftInput | MessageUpsertWithWhereUniqueWithoutGiftInput[]
    createMany?: MessageCreateManyGiftInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutGiftInput | MessageUpdateWithWhereUniqueWithoutGiftInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutGiftInput | MessageUpdateManyWithWhereWithoutGiftInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutGiftNestedInput = {
    create?: XOR<MessageCreateWithoutGiftInput, MessageUncheckedCreateWithoutGiftInput> | MessageCreateWithoutGiftInput[] | MessageUncheckedCreateWithoutGiftInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGiftInput | MessageCreateOrConnectWithoutGiftInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutGiftInput | MessageUpsertWithWhereUniqueWithoutGiftInput[]
    createMany?: MessageCreateManyGiftInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutGiftInput | MessageUpdateWithWhereUniqueWithoutGiftInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutGiftInput | MessageUpdateManyWithWhereWithoutGiftInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReportsMadeInput = {
    create?: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportsReceivedInput = {
    create?: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type StreamCreateNestedOneWithoutReportsInput = {
    create?: XOR<StreamCreateWithoutReportsInput, StreamUncheckedCreateWithoutReportsInput>
    connectOrCreate?: StreamCreateOrConnectWithoutReportsInput
    connect?: StreamWhereUniqueInput
  }

  export type ChatRoomCreateNestedOneWithoutReportsInput = {
    create?: XOR<ChatRoomCreateWithoutReportsInput, ChatRoomUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ChatRoomCreateOrConnectWithoutReportsInput
    connect?: ChatRoomWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutReportsInput = {
    create?: XOR<MessageCreateWithoutReportsInput, MessageUncheckedCreateWithoutReportsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReportsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedReportsInput = {
    create?: XOR<UserCreateWithoutReviewedReportsInput, UserUncheckedCreateWithoutReviewedReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedReportsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type UserUpdateOneRequiredWithoutReportsMadeNestedInput = {
    create?: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsMadeInput
    upsert?: UserUpsertWithoutReportsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsMadeInput, UserUpdateWithoutReportsMadeInput>, UserUncheckedUpdateWithoutReportsMadeInput>
  }

  export type UserUpdateOneWithoutReportsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsReceivedInput
    upsert?: UserUpsertWithoutReportsReceivedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsReceivedInput, UserUpdateWithoutReportsReceivedInput>, UserUncheckedUpdateWithoutReportsReceivedInput>
  }

  export type StreamUpdateOneWithoutReportsNestedInput = {
    create?: XOR<StreamCreateWithoutReportsInput, StreamUncheckedCreateWithoutReportsInput>
    connectOrCreate?: StreamCreateOrConnectWithoutReportsInput
    upsert?: StreamUpsertWithoutReportsInput
    disconnect?: StreamWhereInput | boolean
    delete?: StreamWhereInput | boolean
    connect?: StreamWhereUniqueInput
    update?: XOR<XOR<StreamUpdateToOneWithWhereWithoutReportsInput, StreamUpdateWithoutReportsInput>, StreamUncheckedUpdateWithoutReportsInput>
  }

  export type ChatRoomUpdateOneWithoutReportsNestedInput = {
    create?: XOR<ChatRoomCreateWithoutReportsInput, ChatRoomUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ChatRoomCreateOrConnectWithoutReportsInput
    upsert?: ChatRoomUpsertWithoutReportsInput
    disconnect?: ChatRoomWhereInput | boolean
    delete?: ChatRoomWhereInput | boolean
    connect?: ChatRoomWhereUniqueInput
    update?: XOR<XOR<ChatRoomUpdateToOneWithWhereWithoutReportsInput, ChatRoomUpdateWithoutReportsInput>, ChatRoomUncheckedUpdateWithoutReportsInput>
  }

  export type MessageUpdateOneWithoutReportsNestedInput = {
    create?: XOR<MessageCreateWithoutReportsInput, MessageUncheckedCreateWithoutReportsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReportsInput
    upsert?: MessageUpsertWithoutReportsInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutReportsInput, MessageUpdateWithoutReportsInput>, MessageUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateOneWithoutReviewedReportsNestedInput = {
    create?: XOR<UserCreateWithoutReviewedReportsInput, UserUncheckedCreateWithoutReviewedReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedReportsInput
    upsert?: UserUpsertWithoutReviewedReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedReportsInput, UserUpdateWithoutReviewedReportsInput>, UserUncheckedUpdateWithoutReviewedReportsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentNotificationsInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneWithoutSentNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    upsert?: UserUpsertWithoutSentNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentNotificationsInput, UserUpdateWithoutSentNotificationsInput>, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type UserCreateNestedOneWithoutStreamsInput = {
    create?: XOR<UserCreateWithoutStreamsInput, UserUncheckedCreateWithoutStreamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStreamsInput
    connect?: UserWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutReportedStreamInput = {
    create?: XOR<ReportCreateWithoutReportedStreamInput, ReportUncheckedCreateWithoutReportedStreamInput> | ReportCreateWithoutReportedStreamInput[] | ReportUncheckedCreateWithoutReportedStreamInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedStreamInput | ReportCreateOrConnectWithoutReportedStreamInput[]
    createMany?: ReportCreateManyReportedStreamInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedStreamInput = {
    create?: XOR<ReportCreateWithoutReportedStreamInput, ReportUncheckedCreateWithoutReportedStreamInput> | ReportCreateWithoutReportedStreamInput[] | ReportUncheckedCreateWithoutReportedStreamInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedStreamInput | ReportCreateOrConnectWithoutReportedStreamInput[]
    createMany?: ReportCreateManyReportedStreamInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EnumStreamStatusFieldUpdateOperationsInput = {
    set?: $Enums.StreamStatus
  }

  export type UserUpdateOneRequiredWithoutStreamsNestedInput = {
    create?: XOR<UserCreateWithoutStreamsInput, UserUncheckedCreateWithoutStreamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStreamsInput
    upsert?: UserUpsertWithoutStreamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStreamsInput, UserUpdateWithoutStreamsInput>, UserUncheckedUpdateWithoutStreamsInput>
  }

  export type ReportUpdateManyWithoutReportedStreamNestedInput = {
    create?: XOR<ReportCreateWithoutReportedStreamInput, ReportUncheckedCreateWithoutReportedStreamInput> | ReportCreateWithoutReportedStreamInput[] | ReportUncheckedCreateWithoutReportedStreamInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedStreamInput | ReportCreateOrConnectWithoutReportedStreamInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedStreamInput | ReportUpsertWithWhereUniqueWithoutReportedStreamInput[]
    createMany?: ReportCreateManyReportedStreamInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedStreamInput | ReportUpdateWithWhereUniqueWithoutReportedStreamInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedStreamInput | ReportUpdateManyWithWhereWithoutReportedStreamInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReportedStreamNestedInput = {
    create?: XOR<ReportCreateWithoutReportedStreamInput, ReportUncheckedCreateWithoutReportedStreamInput> | ReportCreateWithoutReportedStreamInput[] | ReportUncheckedCreateWithoutReportedStreamInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedStreamInput | ReportCreateOrConnectWithoutReportedStreamInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedStreamInput | ReportUpsertWithWhereUniqueWithoutReportedStreamInput[]
    createMany?: ReportCreateManyReportedStreamInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedStreamInput | ReportUpdateWithWhereUniqueWithoutReportedStreamInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedStreamInput | ReportUpdateManyWithWhereWithoutReportedStreamInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutOneSignalPlayersInput = {
    create?: XOR<UserCreateWithoutOneSignalPlayersInput, UserUncheckedCreateWithoutOneSignalPlayersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOneSignalPlayersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOneSignalPlayersNestedInput = {
    create?: XOR<UserCreateWithoutOneSignalPlayersInput, UserUncheckedCreateWithoutOneSignalPlayersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOneSignalPlayersInput
    upsert?: UserUpsertWithoutOneSignalPlayersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOneSignalPlayersInput, UserUpdateWithoutOneSignalPlayersInput>, UserUncheckedUpdateWithoutOneSignalPlayersInput>
  }

  export type UserCreateNestedOneWithoutTrustedDevicesInput = {
    create?: XOR<UserCreateWithoutTrustedDevicesInput, UserUncheckedCreateWithoutTrustedDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrustedDevicesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTrustedDevicesNestedInput = {
    create?: XOR<UserCreateWithoutTrustedDevicesInput, UserUncheckedCreateWithoutTrustedDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrustedDevicesInput
    upsert?: UserUpsertWithoutTrustedDevicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrustedDevicesInput, UserUpdateWithoutTrustedDevicesInput>, UserUncheckedUpdateWithoutTrustedDevicesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserGender | EnumUserGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserGender[] | ListEnumUserGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserGender[] | ListEnumUserGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserGenderNullableFilter<$PrismaModel> | $Enums.UserGender | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumUserAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserAccountStatus | EnumUserAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserAccountStatus[] | ListEnumUserAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserAccountStatus[] | ListEnumUserAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserAccountStatusFilter<$PrismaModel> | $Enums.UserAccountStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserGender | EnumUserGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserGender[] | ListEnumUserGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserGender[] | ListEnumUserGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserGender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumUserGenderNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUserAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserAccountStatus | EnumUserAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserAccountStatus[] | ListEnumUserAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserAccountStatus[] | ListEnumUserAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserAccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumUserAccountStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumChatRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatRoomType | EnumChatRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChatRoomType[] | ListEnumChatRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatRoomType[] | ListEnumChatRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChatRoomTypeFilter<$PrismaModel> | $Enums.ChatRoomType
  }

  export type NestedEnumChatRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatRoomStatus | EnumChatRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChatRoomStatus[] | ListEnumChatRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatRoomStatus[] | ListEnumChatRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChatRoomStatusFilter<$PrismaModel> | $Enums.ChatRoomStatus
  }

  export type NestedEnumChatRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatRoomType | EnumChatRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChatRoomType[] | ListEnumChatRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatRoomType[] | ListEnumChatRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChatRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChatRoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumChatRoomTypeFilter<$PrismaModel>
  }

  export type NestedEnumChatRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatRoomStatus | EnumChatRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChatRoomStatus[] | ListEnumChatRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatRoomStatus[] | ListEnumChatRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChatRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChatRoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumChatRoomStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumFollowRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowRequestStatus | EnumFollowRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowRequestStatus[] | ListEnumFollowRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowRequestStatus[] | ListEnumFollowRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowRequestStatusFilter<$PrismaModel> | $Enums.FollowRequestStatus
  }

  export type NestedEnumFollowRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowRequestStatus | EnumFollowRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowRequestStatus[] | ListEnumFollowRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowRequestStatus[] | ListEnumFollowRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.FollowRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFollowRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumFollowRequestStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumGameSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameSessionStatus | EnumGameSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameSessionStatus[] | ListEnumGameSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameSessionStatus[] | ListEnumGameSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameSessionStatusFilter<$PrismaModel> | $Enums.GameSessionStatus
  }

  export type NestedEnumGameSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameSessionStatus | EnumGameSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameSessionStatus[] | ListEnumGameSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameSessionStatus[] | ListEnumGameSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumGameSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumStreamStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StreamStatus | EnumStreamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStreamStatusFilter<$PrismaModel> | $Enums.StreamStatus
  }

  export type NestedEnumStreamStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StreamStatus | EnumStreamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StreamStatus[] | ListEnumStreamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStreamStatusWithAggregatesFilter<$PrismaModel> | $Enums.StreamStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStreamStatusFilter<$PrismaModel>
    _max?: NestedEnumStreamStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutInvitedByInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutInvitedByInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutInvitedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitedByInput, UserUncheckedCreateWithoutInvitedByInput>
  }

  export type UserCreateManyInvitedByInputEnvelope = {
    data: UserCreateManyInvitedByInput | UserCreateManyInvitedByInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutInvitedUsersInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutInvitedUsersInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutInvitedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitedUsersInput, UserUncheckedCreateWithoutInvitedUsersInput>
  }

  export type TrustedDeviceCreateWithoutUserInput = {
    id?: string
    deviceName: string
    deviceType?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    location?: string | null
    isCurrentDevice?: boolean
    lastUsedAt?: Date | string
    createdAt?: Date | string
  }

  export type TrustedDeviceUncheckedCreateWithoutUserInput = {
    id?: string
    deviceName: string
    deviceType?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    location?: string | null
    isCurrentDevice?: boolean
    lastUsedAt?: Date | string
    createdAt?: Date | string
  }

  export type TrustedDeviceCreateOrConnectWithoutUserInput = {
    where: TrustedDeviceWhereUniqueInput
    create: XOR<TrustedDeviceCreateWithoutUserInput, TrustedDeviceUncheckedCreateWithoutUserInput>
  }

  export type TrustedDeviceCreateManyUserInputEnvelope = {
    data: TrustedDeviceCreateManyUserInput | TrustedDeviceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    lastUsedAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    lastUsedAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OneSignalPlayerCreateWithoutUserInput = {
    id?: string
    playerId: string
    deviceInfo?: string | null
    lastSeen?: Date | string
    createdAt?: Date | string
  }

  export type OneSignalPlayerUncheckedCreateWithoutUserInput = {
    id?: string
    playerId: string
    deviceInfo?: string | null
    lastSeen?: Date | string
    createdAt?: Date | string
  }

  export type OneSignalPlayerCreateOrConnectWithoutUserInput = {
    where: OneSignalPlayerWhereUniqueInput
    create: XOR<OneSignalPlayerCreateWithoutUserInput, OneSignalPlayerUncheckedCreateWithoutUserInput>
  }

  export type OneSignalPlayerCreateManyUserInputEnvelope = {
    data: OneSignalPlayerCreateManyUserInput | OneSignalPlayerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    transactionType: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    description?: string | null
    platform?: string | null
    platformTransactionId?: string | null
    status?: $Enums.TransactionStatus
    paymentGatewayToken?: string | null
    createdAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    transactionType: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    description?: string | null
    platform?: string | null
    platformTransactionId?: string | null
    status?: $Enums.TransactionStatus
    paymentGatewayToken?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    messageType: $Enums.MessageType
    content?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    receiver?: UserCreateNestedOneWithoutReceivedMessagesInput
    room?: ChatRoomCreateNestedOneWithoutMessagesInput
    gift?: GiftCreateNestedOneWithoutMessagesInput
    repliedToMessage?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutRepliedToMessageInput
    reports?: ReportCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    receiverId?: string | null
    roomId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    giftId?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    repliedToMessageId?: string | null
    replies?: MessageUncheckedCreateNestedManyWithoutRepliedToMessageInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutReceiverInput = {
    id?: string
    conversationId: string
    messageType: $Enums.MessageType
    content?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    room?: ChatRoomCreateNestedOneWithoutMessagesInput
    gift?: GiftCreateNestedOneWithoutMessagesInput
    repliedToMessage?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutRepliedToMessageInput
    reports?: ReportCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    conversationId: string
    senderId: string
    roomId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    giftId?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    repliedToMessageId?: string | null
    replies?: MessageUncheckedCreateNestedManyWithoutRepliedToMessageInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateManyReceiverInputEnvelope = {
    data: MessageCreateManyReceiverInput | MessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutReporterInput = {
    id?: string
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
    reportedUser?: UserCreateNestedOneWithoutReportsReceivedInput
    reportedStream?: StreamCreateNestedOneWithoutReportsInput
    reportedRoom?: ChatRoomCreateNestedOneWithoutReportsInput
    reportedMessage?: MessageCreateNestedOneWithoutReportsInput
    reviewer?: UserCreateNestedOneWithoutReviewedReportsInput
  }

  export type ReportUncheckedCreateWithoutReporterInput = {
    id?: string
    reportedUserId?: string | null
    reportedStreamId?: string | null
    reportedRoomId?: string | null
    reportedMessageId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewedById?: string | null
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutReporterInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
  }

  export type ReportCreateManyReporterInputEnvelope = {
    data: ReportCreateManyReporterInput | ReportCreateManyReporterInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutReportedUserInput = {
    id?: string
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsMadeInput
    reportedStream?: StreamCreateNestedOneWithoutReportsInput
    reportedRoom?: ChatRoomCreateNestedOneWithoutReportsInput
    reportedMessage?: MessageCreateNestedOneWithoutReportsInput
    reviewer?: UserCreateNestedOneWithoutReviewedReportsInput
  }

  export type ReportUncheckedCreateWithoutReportedUserInput = {
    id?: string
    reporterId: string
    reportedStreamId?: string | null
    reportedRoomId?: string | null
    reportedMessageId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewedById?: string | null
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput>
  }

  export type ReportCreateManyReportedUserInputEnvelope = {
    data: ReportCreateManyReportedUserInput | ReportCreateManyReportedUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutReviewerInput = {
    id?: string
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsMadeInput
    reportedUser?: UserCreateNestedOneWithoutReportsReceivedInput
    reportedStream?: StreamCreateNestedOneWithoutReportsInput
    reportedRoom?: ChatRoomCreateNestedOneWithoutReportsInput
    reportedMessage?: MessageCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutReviewerInput = {
    id?: string
    reporterId: string
    reportedUserId?: string | null
    reportedStreamId?: string | null
    reportedRoomId?: string | null
    reportedMessageId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutReviewerInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReviewerInput, ReportUncheckedCreateWithoutReviewerInput>
  }

  export type ReportCreateManyReviewerInputEnvelope = {
    data: ReportCreateManyReviewerInput | ReportCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type GameSessionCreateWithoutHostInput = {
    id?: string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers: number
    currentPlayers?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    status?: $Enums.GameSessionStatus
    createdAt?: Date | string
    game: GameCreateNestedOneWithoutGameSessionsInput
  }

  export type GameSessionUncheckedCreateWithoutHostInput = {
    id?: string
    gameId: string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers: number
    currentPlayers?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    status?: $Enums.GameSessionStatus
    createdAt?: Date | string
  }

  export type GameSessionCreateOrConnectWithoutHostInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutHostInput, GameSessionUncheckedCreateWithoutHostInput>
  }

  export type GameSessionCreateManyHostInputEnvelope = {
    data: GameSessionCreateManyHostInput | GameSessionCreateManyHostInput[]
    skipDuplicates?: boolean
  }

  export type StreamCreateWithoutBroadcasterInput = {
    id?: string
    title?: string | null
    coverImageUrl?: string | null
    status?: $Enums.StreamStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    currentViewers?: number
    peakViewers?: number
    totalDiamondsReceived?: bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    recordingUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportCreateNestedManyWithoutReportedStreamInput
  }

  export type StreamUncheckedCreateWithoutBroadcasterInput = {
    id?: string
    title?: string | null
    coverImageUrl?: string | null
    status?: $Enums.StreamStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    currentViewers?: number
    peakViewers?: number
    totalDiamondsReceived?: bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    recordingUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutReportedStreamInput
  }

  export type StreamCreateOrConnectWithoutBroadcasterInput = {
    where: StreamWhereUniqueInput
    create: XOR<StreamCreateWithoutBroadcasterInput, StreamUncheckedCreateWithoutBroadcasterInput>
  }

  export type StreamCreateManyBroadcasterInputEnvelope = {
    data: StreamCreateManyBroadcasterInput | StreamCreateManyBroadcasterInput[]
    skipDuplicates?: boolean
  }

  export type ChatRoomCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    coverImageUrl?: string | null
    type: $Enums.ChatRoomType
    passwordHash?: string | null
    maxParticipants: number
    currentParticipantCount?: number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutRoomInput
    reports?: ReportCreateNestedManyWithoutReportedRoomInput
  }

  export type ChatRoomUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    coverImageUrl?: string | null
    type: $Enums.ChatRoomType
    passwordHash?: string | null
    maxParticipants: number
    currentParticipantCount?: number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutRoomInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedRoomInput
  }

  export type ChatRoomCreateOrConnectWithoutOwnerInput = {
    where: ChatRoomWhereUniqueInput
    create: XOR<ChatRoomCreateWithoutOwnerInput, ChatRoomUncheckedCreateWithoutOwnerInput>
  }

  export type ChatRoomCreateManyOwnerInputEnvelope = {
    data: ChatRoomCreateManyOwnerInput | ChatRoomCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type FollowRequestCreateWithoutRequesterInput = {
    id?: string
    status?: $Enums.FollowRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: UserCreateNestedOneWithoutReceivedFollowRequestsInput
  }

  export type FollowRequestUncheckedCreateWithoutRequesterInput = {
    id?: string
    recipientId: string
    status?: $Enums.FollowRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowRequestCreateOrConnectWithoutRequesterInput = {
    where: FollowRequestWhereUniqueInput
    create: XOR<FollowRequestCreateWithoutRequesterInput, FollowRequestUncheckedCreateWithoutRequesterInput>
  }

  export type FollowRequestCreateManyRequesterInputEnvelope = {
    data: FollowRequestCreateManyRequesterInput | FollowRequestCreateManyRequesterInput[]
    skipDuplicates?: boolean
  }

  export type FollowRequestCreateWithoutRecipientInput = {
    id?: string
    status?: $Enums.FollowRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutSentFollowRequestsInput
  }

  export type FollowRequestUncheckedCreateWithoutRecipientInput = {
    id?: string
    requesterId: string
    status?: $Enums.FollowRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowRequestCreateOrConnectWithoutRecipientInput = {
    where: FollowRequestWhereUniqueInput
    create: XOR<FollowRequestCreateWithoutRecipientInput, FollowRequestUncheckedCreateWithoutRecipientInput>
  }

  export type FollowRequestCreateManyRecipientInputEnvelope = {
    data: FollowRequestCreateManyRecipientInput | FollowRequestCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateWithoutFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowCreateManyFollowingInputEnvelope = {
    data: FollowCreateManyFollowingInput | FollowCreateManyFollowingInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    following: UserCreateNestedOneWithoutFollowedByInput
  }

  export type FollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowCreateManyFollowerInputEnvelope = {
    data: FollowCreateManyFollowerInput | FollowCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type GameLikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    game: GameCreateNestedOneWithoutLikesInput
  }

  export type GameLikeUncheckedCreateWithoutUserInput = {
    id?: string
    gameId: string
    createdAt?: Date | string
  }

  export type GameLikeCreateOrConnectWithoutUserInput = {
    where: GameLikeWhereUniqueInput
    create: XOR<GameLikeCreateWithoutUserInput, GameLikeUncheckedCreateWithoutUserInput>
  }

  export type GameLikeCreateManyUserInputEnvelope = {
    data: GameLikeCreateManyUserInput | GameLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GameRatingCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    game: GameCreateNestedOneWithoutRatingsInput
  }

  export type GameRatingUncheckedCreateWithoutUserInput = {
    id?: string
    gameId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameRatingCreateOrConnectWithoutUserInput = {
    where: GameRatingWhereUniqueInput
    create: XOR<GameRatingCreateWithoutUserInput, GameRatingUncheckedCreateWithoutUserInput>
  }

  export type GameRatingCreateManyUserInputEnvelope = {
    data: GameRatingCreateManyUserInput | GameRatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRecipientInput = {
    id?: string
    type: $Enums.NotificationType
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    content?: string | null
    isRead?: boolean
    createdAt?: Date | string
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRecipientInput = {
    id?: string
    senderId?: string | null
    type: $Enums.NotificationType
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    content?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationCreateManyRecipientInputEnvelope = {
    data: NotificationCreateManyRecipientInput | NotificationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutSenderInput = {
    id?: string
    type: $Enums.NotificationType
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    content?: string | null
    isRead?: boolean
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutSenderInput = {
    id?: string
    recipientId: string
    type: $Enums.NotificationType
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    content?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationCreateManySenderInputEnvelope = {
    data: NotificationCreateManySenderInput | NotificationCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutInvitedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutInvitedByInput, UserUncheckedUpdateWithoutInvitedByInput>
    create: XOR<UserCreateWithoutInvitedByInput, UserUncheckedCreateWithoutInvitedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutInvitedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutInvitedByInput, UserUncheckedUpdateWithoutInvitedByInput>
  }

  export type UserUpdateManyWithWhereWithoutInvitedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutInvitedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    authProvider?: StringNullableFilter<"User"> | string | null
    authId?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    nickname?: StringNullableFilter<"User"> | string | null
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    gender?: EnumUserGenderNullableFilter<"User"> | $Enums.UserGender | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    country?: StringNullableFilter<"User"> | string | null
    region?: StringNullableFilter<"User"> | string | null
    level?: IntFilter<"User"> | number
    vipLevel?: IntFilter<"User"> | number
    coins?: BigIntFilter<"User"> | bigint | number
    diamonds?: BigIntFilter<"User"> | bigint | number
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isEmailVerified?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    followingCount?: IntFilter<"User"> | number
    followerCount?: IntFilter<"User"> | number
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    isOnline?: BoolFilter<"User"> | boolean
    preferences?: JsonNullableFilter<"User">
    allowDirectMessages?: BoolFilter<"User"> | boolean
    notificationSettings?: JsonNullableFilter<"User">
    blockedUserIds?: JsonNullableFilter<"User">
    accountStatus?: EnumUserAccountStatusFilter<"User"> | $Enums.UserAccountStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isPrivate?: BoolFilter<"User"> | boolean
    pinnedMessagesInRooms?: JsonNullableFilter<"User">
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorRecoveryCodes?: JsonNullableFilter<"User">
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    emailVerificationExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    postCount?: IntFilter<"User"> | number
    invitedByForeignKey?: StringNullableFilter<"User"> | string | null
  }

  export type UserUpsertWithoutInvitedUsersInput = {
    update: XOR<UserUpdateWithoutInvitedUsersInput, UserUncheckedUpdateWithoutInvitedUsersInput>
    create: XOR<UserCreateWithoutInvitedUsersInput, UserUncheckedCreateWithoutInvitedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitedUsersInput, UserUncheckedUpdateWithoutInvitedUsersInput>
  }

  export type UserUpdateWithoutInvitedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type TrustedDeviceUpsertWithWhereUniqueWithoutUserInput = {
    where: TrustedDeviceWhereUniqueInput
    update: XOR<TrustedDeviceUpdateWithoutUserInput, TrustedDeviceUncheckedUpdateWithoutUserInput>
    create: XOR<TrustedDeviceCreateWithoutUserInput, TrustedDeviceUncheckedCreateWithoutUserInput>
  }

  export type TrustedDeviceUpdateWithWhereUniqueWithoutUserInput = {
    where: TrustedDeviceWhereUniqueInput
    data: XOR<TrustedDeviceUpdateWithoutUserInput, TrustedDeviceUncheckedUpdateWithoutUserInput>
  }

  export type TrustedDeviceUpdateManyWithWhereWithoutUserInput = {
    where: TrustedDeviceScalarWhereInput
    data: XOR<TrustedDeviceUpdateManyMutationInput, TrustedDeviceUncheckedUpdateManyWithoutUserInput>
  }

  export type TrustedDeviceScalarWhereInput = {
    AND?: TrustedDeviceScalarWhereInput | TrustedDeviceScalarWhereInput[]
    OR?: TrustedDeviceScalarWhereInput[]
    NOT?: TrustedDeviceScalarWhereInput | TrustedDeviceScalarWhereInput[]
    id?: StringFilter<"TrustedDevice"> | string
    userId?: StringFilter<"TrustedDevice"> | string
    deviceName?: StringFilter<"TrustedDevice"> | string
    deviceType?: StringNullableFilter<"TrustedDevice"> | string | null
    ipAddress?: StringNullableFilter<"TrustedDevice"> | string | null
    userAgent?: StringNullableFilter<"TrustedDevice"> | string | null
    location?: StringNullableFilter<"TrustedDevice"> | string | null
    isCurrentDevice?: BoolFilter<"TrustedDevice"> | boolean
    lastUsedAt?: DateTimeFilter<"TrustedDevice"> | Date | string
    createdAt?: DateTimeFilter<"TrustedDevice"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    lastUsedAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type OneSignalPlayerUpsertWithWhereUniqueWithoutUserInput = {
    where: OneSignalPlayerWhereUniqueInput
    update: XOR<OneSignalPlayerUpdateWithoutUserInput, OneSignalPlayerUncheckedUpdateWithoutUserInput>
    create: XOR<OneSignalPlayerCreateWithoutUserInput, OneSignalPlayerUncheckedCreateWithoutUserInput>
  }

  export type OneSignalPlayerUpdateWithWhereUniqueWithoutUserInput = {
    where: OneSignalPlayerWhereUniqueInput
    data: XOR<OneSignalPlayerUpdateWithoutUserInput, OneSignalPlayerUncheckedUpdateWithoutUserInput>
  }

  export type OneSignalPlayerUpdateManyWithWhereWithoutUserInput = {
    where: OneSignalPlayerScalarWhereInput
    data: XOR<OneSignalPlayerUpdateManyMutationInput, OneSignalPlayerUncheckedUpdateManyWithoutUserInput>
  }

  export type OneSignalPlayerScalarWhereInput = {
    AND?: OneSignalPlayerScalarWhereInput | OneSignalPlayerScalarWhereInput[]
    OR?: OneSignalPlayerScalarWhereInput[]
    NOT?: OneSignalPlayerScalarWhereInput | OneSignalPlayerScalarWhereInput[]
    id?: StringFilter<"OneSignalPlayer"> | string
    playerId?: StringFilter<"OneSignalPlayer"> | string
    userId?: StringFilter<"OneSignalPlayer"> | string
    deviceInfo?: StringNullableFilter<"OneSignalPlayer"> | string | null
    lastSeen?: DateTimeFilter<"OneSignalPlayer"> | Date | string
    createdAt?: DateTimeFilter<"OneSignalPlayer"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    transactionType?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Transaction"> | string
    relatedEntityId?: StringNullableFilter<"Transaction"> | string | null
    relatedEntityType?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    platform?: StringNullableFilter<"Transaction"> | string | null
    platformTransactionId?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    paymentGatewayToken?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringNullableFilter<"Message"> | string | null
    roomId?: StringNullableFilter<"Message"> | string | null
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    content?: StringNullableFilter<"Message"> | string | null
    giftId?: StringNullableFilter<"Message"> | string | null
    readStatus?: JsonNullableFilter<"Message">
    isDeletedFor?: JsonNullableFilter<"Message">
    isPinned?: BoolFilter<"Message"> | boolean
    reactions?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    repliedToMessageId?: StringNullableFilter<"Message"> | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>
  }

  export type ReportUpdateManyWithWhereWithoutReporterInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReporterInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringNullableFilter<"Report"> | string | null
    reportedStreamId?: StringNullableFilter<"Report"> | string | null
    reportedRoomId?: StringNullableFilter<"Report"> | string | null
    reportedMessageId?: StringNullableFilter<"Report"> | string | null
    reason?: StringFilter<"Report"> | string
    description?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    reviewedById?: StringNullableFilter<"Report"> | string | null
    reviewTimestamp?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedUserInput, ReportUncheckedUpdateWithoutReportedUserInput>
    create: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedUserInput, ReportUncheckedUpdateWithoutReportedUserInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedUserInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportedUserInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutReviewerInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReviewerInput, ReportUncheckedUpdateWithoutReviewerInput>
    create: XOR<ReportCreateWithoutReviewerInput, ReportUncheckedCreateWithoutReviewerInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReviewerInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReviewerInput, ReportUncheckedUpdateWithoutReviewerInput>
  }

  export type ReportUpdateManyWithWhereWithoutReviewerInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReviewerInput>
  }

  export type GameSessionUpsertWithWhereUniqueWithoutHostInput = {
    where: GameSessionWhereUniqueInput
    update: XOR<GameSessionUpdateWithoutHostInput, GameSessionUncheckedUpdateWithoutHostInput>
    create: XOR<GameSessionCreateWithoutHostInput, GameSessionUncheckedCreateWithoutHostInput>
  }

  export type GameSessionUpdateWithWhereUniqueWithoutHostInput = {
    where: GameSessionWhereUniqueInput
    data: XOR<GameSessionUpdateWithoutHostInput, GameSessionUncheckedUpdateWithoutHostInput>
  }

  export type GameSessionUpdateManyWithWhereWithoutHostInput = {
    where: GameSessionScalarWhereInput
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyWithoutHostInput>
  }

  export type GameSessionScalarWhereInput = {
    AND?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
    OR?: GameSessionScalarWhereInput[]
    NOT?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
    id?: StringFilter<"GameSession"> | string
    gameId?: StringFilter<"GameSession"> | string
    hostId?: StringFilter<"GameSession"> | string
    participants?: JsonNullableFilter<"GameSession">
    viewerIds?: JsonNullableFilter<"GameSession">
    maxPlayers?: IntFilter<"GameSession"> | number
    currentPlayers?: IntFilter<"GameSession"> | number
    startTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    status?: EnumGameSessionStatusFilter<"GameSession"> | $Enums.GameSessionStatus
    createdAt?: DateTimeFilter<"GameSession"> | Date | string
  }

  export type StreamUpsertWithWhereUniqueWithoutBroadcasterInput = {
    where: StreamWhereUniqueInput
    update: XOR<StreamUpdateWithoutBroadcasterInput, StreamUncheckedUpdateWithoutBroadcasterInput>
    create: XOR<StreamCreateWithoutBroadcasterInput, StreamUncheckedCreateWithoutBroadcasterInput>
  }

  export type StreamUpdateWithWhereUniqueWithoutBroadcasterInput = {
    where: StreamWhereUniqueInput
    data: XOR<StreamUpdateWithoutBroadcasterInput, StreamUncheckedUpdateWithoutBroadcasterInput>
  }

  export type StreamUpdateManyWithWhereWithoutBroadcasterInput = {
    where: StreamScalarWhereInput
    data: XOR<StreamUpdateManyMutationInput, StreamUncheckedUpdateManyWithoutBroadcasterInput>
  }

  export type StreamScalarWhereInput = {
    AND?: StreamScalarWhereInput | StreamScalarWhereInput[]
    OR?: StreamScalarWhereInput[]
    NOT?: StreamScalarWhereInput | StreamScalarWhereInput[]
    id?: StringFilter<"Stream"> | string
    broadcasterId?: StringFilter<"Stream"> | string
    title?: StringNullableFilter<"Stream"> | string | null
    coverImageUrl?: StringNullableFilter<"Stream"> | string | null
    status?: EnumStreamStatusFilter<"Stream"> | $Enums.StreamStatus
    startTime?: DateTimeNullableFilter<"Stream"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Stream"> | Date | string | null
    currentViewers?: IntFilter<"Stream"> | number
    peakViewers?: IntFilter<"Stream"> | number
    totalDiamondsReceived?: BigIntFilter<"Stream"> | bigint | number
    tags?: JsonNullableFilter<"Stream">
    location?: JsonNullableFilter<"Stream">
    rtcChannelName?: StringNullableFilter<"Stream"> | string | null
    recordingUrl?: StringNullableFilter<"Stream"> | string | null
    createdAt?: DateTimeFilter<"Stream"> | Date | string
    updatedAt?: DateTimeFilter<"Stream"> | Date | string
  }

  export type ChatRoomUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ChatRoomWhereUniqueInput
    update: XOR<ChatRoomUpdateWithoutOwnerInput, ChatRoomUncheckedUpdateWithoutOwnerInput>
    create: XOR<ChatRoomCreateWithoutOwnerInput, ChatRoomUncheckedCreateWithoutOwnerInput>
  }

  export type ChatRoomUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ChatRoomWhereUniqueInput
    data: XOR<ChatRoomUpdateWithoutOwnerInput, ChatRoomUncheckedUpdateWithoutOwnerInput>
  }

  export type ChatRoomUpdateManyWithWhereWithoutOwnerInput = {
    where: ChatRoomScalarWhereInput
    data: XOR<ChatRoomUpdateManyMutationInput, ChatRoomUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ChatRoomScalarWhereInput = {
    AND?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
    OR?: ChatRoomScalarWhereInput[]
    NOT?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
    id?: StringFilter<"ChatRoom"> | string
    ownerId?: StringFilter<"ChatRoom"> | string
    title?: StringFilter<"ChatRoom"> | string
    description?: StringNullableFilter<"ChatRoom"> | string | null
    coverImageUrl?: StringNullableFilter<"ChatRoom"> | string | null
    type?: EnumChatRoomTypeFilter<"ChatRoom"> | $Enums.ChatRoomType
    passwordHash?: StringNullableFilter<"ChatRoom"> | string | null
    maxParticipants?: IntFilter<"ChatRoom"> | number
    currentParticipantCount?: IntFilter<"ChatRoom"> | number
    activeParticipants?: JsonNullableFilter<"ChatRoom">
    moderators?: JsonNullableFilter<"ChatRoom">
    speakerSeatCount?: IntFilter<"ChatRoom"> | number
    speakerSeatAssignments?: JsonNullableFilter<"ChatRoom">
    rtcChannelName?: StringNullableFilter<"ChatRoom"> | string | null
    tags?: JsonNullableFilter<"ChatRoom">
    status?: EnumChatRoomStatusFilter<"ChatRoom"> | $Enums.ChatRoomStatus
    pinnedMessageIds?: JsonNullableFilter<"ChatRoom">
    createdAt?: DateTimeFilter<"ChatRoom"> | Date | string
    updatedAt?: DateTimeFilter<"ChatRoom"> | Date | string
  }

  export type FollowRequestUpsertWithWhereUniqueWithoutRequesterInput = {
    where: FollowRequestWhereUniqueInput
    update: XOR<FollowRequestUpdateWithoutRequesterInput, FollowRequestUncheckedUpdateWithoutRequesterInput>
    create: XOR<FollowRequestCreateWithoutRequesterInput, FollowRequestUncheckedCreateWithoutRequesterInput>
  }

  export type FollowRequestUpdateWithWhereUniqueWithoutRequesterInput = {
    where: FollowRequestWhereUniqueInput
    data: XOR<FollowRequestUpdateWithoutRequesterInput, FollowRequestUncheckedUpdateWithoutRequesterInput>
  }

  export type FollowRequestUpdateManyWithWhereWithoutRequesterInput = {
    where: FollowRequestScalarWhereInput
    data: XOR<FollowRequestUpdateManyMutationInput, FollowRequestUncheckedUpdateManyWithoutRequesterInput>
  }

  export type FollowRequestScalarWhereInput = {
    AND?: FollowRequestScalarWhereInput | FollowRequestScalarWhereInput[]
    OR?: FollowRequestScalarWhereInput[]
    NOT?: FollowRequestScalarWhereInput | FollowRequestScalarWhereInput[]
    id?: StringFilter<"FollowRequest"> | string
    requesterId?: StringFilter<"FollowRequest"> | string
    recipientId?: StringFilter<"FollowRequest"> | string
    status?: EnumFollowRequestStatusFilter<"FollowRequest"> | $Enums.FollowRequestStatus
    createdAt?: DateTimeFilter<"FollowRequest"> | Date | string
    updatedAt?: DateTimeFilter<"FollowRequest"> | Date | string
  }

  export type FollowRequestUpsertWithWhereUniqueWithoutRecipientInput = {
    where: FollowRequestWhereUniqueInput
    update: XOR<FollowRequestUpdateWithoutRecipientInput, FollowRequestUncheckedUpdateWithoutRecipientInput>
    create: XOR<FollowRequestCreateWithoutRecipientInput, FollowRequestUncheckedCreateWithoutRecipientInput>
  }

  export type FollowRequestUpdateWithWhereUniqueWithoutRecipientInput = {
    where: FollowRequestWhereUniqueInput
    data: XOR<FollowRequestUpdateWithoutRecipientInput, FollowRequestUncheckedUpdateWithoutRecipientInput>
  }

  export type FollowRequestUpdateManyWithWhereWithoutRecipientInput = {
    where: FollowRequestScalarWhereInput
    data: XOR<FollowRequestUpdateManyMutationInput, FollowRequestUncheckedUpdateManyWithoutRecipientInput>
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type GameLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: GameLikeWhereUniqueInput
    update: XOR<GameLikeUpdateWithoutUserInput, GameLikeUncheckedUpdateWithoutUserInput>
    create: XOR<GameLikeCreateWithoutUserInput, GameLikeUncheckedCreateWithoutUserInput>
  }

  export type GameLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: GameLikeWhereUniqueInput
    data: XOR<GameLikeUpdateWithoutUserInput, GameLikeUncheckedUpdateWithoutUserInput>
  }

  export type GameLikeUpdateManyWithWhereWithoutUserInput = {
    where: GameLikeScalarWhereInput
    data: XOR<GameLikeUpdateManyMutationInput, GameLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type GameLikeScalarWhereInput = {
    AND?: GameLikeScalarWhereInput | GameLikeScalarWhereInput[]
    OR?: GameLikeScalarWhereInput[]
    NOT?: GameLikeScalarWhereInput | GameLikeScalarWhereInput[]
    id?: StringFilter<"GameLike"> | string
    userId?: StringFilter<"GameLike"> | string
    gameId?: StringFilter<"GameLike"> | string
    createdAt?: DateTimeFilter<"GameLike"> | Date | string
  }

  export type GameRatingUpsertWithWhereUniqueWithoutUserInput = {
    where: GameRatingWhereUniqueInput
    update: XOR<GameRatingUpdateWithoutUserInput, GameRatingUncheckedUpdateWithoutUserInput>
    create: XOR<GameRatingCreateWithoutUserInput, GameRatingUncheckedCreateWithoutUserInput>
  }

  export type GameRatingUpdateWithWhereUniqueWithoutUserInput = {
    where: GameRatingWhereUniqueInput
    data: XOR<GameRatingUpdateWithoutUserInput, GameRatingUncheckedUpdateWithoutUserInput>
  }

  export type GameRatingUpdateManyWithWhereWithoutUserInput = {
    where: GameRatingScalarWhereInput
    data: XOR<GameRatingUpdateManyMutationInput, GameRatingUncheckedUpdateManyWithoutUserInput>
  }

  export type GameRatingScalarWhereInput = {
    AND?: GameRatingScalarWhereInput | GameRatingScalarWhereInput[]
    OR?: GameRatingScalarWhereInput[]
    NOT?: GameRatingScalarWhereInput | GameRatingScalarWhereInput[]
    id?: StringFilter<"GameRating"> | string
    userId?: StringFilter<"GameRating"> | string
    gameId?: StringFilter<"GameRating"> | string
    rating?: IntFilter<"GameRating"> | number
    comment?: StringNullableFilter<"GameRating"> | string | null
    createdAt?: DateTimeFilter<"GameRating"> | Date | string
    updatedAt?: DateTimeFilter<"GameRating"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRecipientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    senderId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    relatedEntityType?: StringNullableFilter<"Notification"> | string | null
    content?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSenderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSenderInput>
  }

  export type UserCreateWithoutOwnedChatRoomsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutOwnedChatRoomsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutOwnedChatRoomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedChatRoomsInput, UserUncheckedCreateWithoutOwnedChatRoomsInput>
  }

  export type MessageCreateWithoutRoomInput = {
    id?: string
    conversationId: string
    messageType: $Enums.MessageType
    content?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver?: UserCreateNestedOneWithoutReceivedMessagesInput
    gift?: GiftCreateNestedOneWithoutMessagesInput
    repliedToMessage?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutRepliedToMessageInput
    reports?: ReportCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageUncheckedCreateWithoutRoomInput = {
    id?: string
    conversationId: string
    senderId: string
    receiverId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    giftId?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    repliedToMessageId?: string | null
    replies?: MessageUncheckedCreateNestedManyWithoutRepliedToMessageInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageCreateOrConnectWithoutRoomInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRoomInput, MessageUncheckedCreateWithoutRoomInput>
  }

  export type MessageCreateManyRoomInputEnvelope = {
    data: MessageCreateManyRoomInput | MessageCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutReportedRoomInput = {
    id?: string
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsMadeInput
    reportedUser?: UserCreateNestedOneWithoutReportsReceivedInput
    reportedStream?: StreamCreateNestedOneWithoutReportsInput
    reportedMessage?: MessageCreateNestedOneWithoutReportsInput
    reviewer?: UserCreateNestedOneWithoutReviewedReportsInput
  }

  export type ReportUncheckedCreateWithoutReportedRoomInput = {
    id?: string
    reporterId: string
    reportedUserId?: string | null
    reportedStreamId?: string | null
    reportedMessageId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewedById?: string | null
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutReportedRoomInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedRoomInput, ReportUncheckedCreateWithoutReportedRoomInput>
  }

  export type ReportCreateManyReportedRoomInputEnvelope = {
    data: ReportCreateManyReportedRoomInput | ReportCreateManyReportedRoomInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedChatRoomsInput = {
    update: XOR<UserUpdateWithoutOwnedChatRoomsInput, UserUncheckedUpdateWithoutOwnedChatRoomsInput>
    create: XOR<UserCreateWithoutOwnedChatRoomsInput, UserUncheckedCreateWithoutOwnedChatRoomsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedChatRoomsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedChatRoomsInput, UserUncheckedUpdateWithoutOwnedChatRoomsInput>
  }

  export type UserUpdateWithoutOwnedChatRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedChatRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutRoomInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutRoomInput, MessageUncheckedUpdateWithoutRoomInput>
    create: XOR<MessageCreateWithoutRoomInput, MessageUncheckedCreateWithoutRoomInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutRoomInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutRoomInput, MessageUncheckedUpdateWithoutRoomInput>
  }

  export type MessageUpdateManyWithWhereWithoutRoomInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutRoomInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedRoomInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedRoomInput, ReportUncheckedUpdateWithoutReportedRoomInput>
    create: XOR<ReportCreateWithoutReportedRoomInput, ReportUncheckedCreateWithoutReportedRoomInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedRoomInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedRoomInput, ReportUncheckedUpdateWithoutReportedRoomInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedRoomInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportedRoomInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type ChatRoomCreateWithoutMessagesInput = {
    id?: string
    title: string
    description?: string | null
    coverImageUrl?: string | null
    type: $Enums.ChatRoomType
    passwordHash?: string | null
    maxParticipants: number
    currentParticipantCount?: number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChatRoomsInput
    reports?: ReportCreateNestedManyWithoutReportedRoomInput
  }

  export type ChatRoomUncheckedCreateWithoutMessagesInput = {
    id?: string
    ownerId: string
    title: string
    description?: string | null
    coverImageUrl?: string | null
    type: $Enums.ChatRoomType
    passwordHash?: string | null
    maxParticipants: number
    currentParticipantCount?: number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutReportedRoomInput
  }

  export type ChatRoomCreateOrConnectWithoutMessagesInput = {
    where: ChatRoomWhereUniqueInput
    create: XOR<ChatRoomCreateWithoutMessagesInput, ChatRoomUncheckedCreateWithoutMessagesInput>
  }

  export type GiftCreateWithoutMessagesInput = {
    id?: string
    giftId: string
    name: string
    description?: string | null
    imageUrl: string
    animationUrl?: string | null
    cost: bigint | number
    value: bigint | number
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GiftUncheckedCreateWithoutMessagesInput = {
    id?: string
    giftId: string
    name: string
    description?: string | null
    imageUrl: string
    animationUrl?: string | null
    cost: bigint | number
    value: bigint | number
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GiftCreateOrConnectWithoutMessagesInput = {
    where: GiftWhereUniqueInput
    create: XOR<GiftCreateWithoutMessagesInput, GiftUncheckedCreateWithoutMessagesInput>
  }

  export type MessageCreateWithoutRepliesInput = {
    id?: string
    conversationId: string
    messageType: $Enums.MessageType
    content?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver?: UserCreateNestedOneWithoutReceivedMessagesInput
    room?: ChatRoomCreateNestedOneWithoutMessagesInput
    gift?: GiftCreateNestedOneWithoutMessagesInput
    repliedToMessage?: MessageCreateNestedOneWithoutRepliesInput
    reports?: ReportCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageUncheckedCreateWithoutRepliesInput = {
    id?: string
    conversationId: string
    senderId: string
    receiverId?: string | null
    roomId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    giftId?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    repliedToMessageId?: string | null
    reports?: ReportUncheckedCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageCreateOrConnectWithoutRepliesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
  }

  export type MessageCreateWithoutRepliedToMessageInput = {
    id?: string
    conversationId: string
    messageType: $Enums.MessageType
    content?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver?: UserCreateNestedOneWithoutReceivedMessagesInput
    room?: ChatRoomCreateNestedOneWithoutMessagesInput
    gift?: GiftCreateNestedOneWithoutMessagesInput
    replies?: MessageCreateNestedManyWithoutRepliedToMessageInput
    reports?: ReportCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageUncheckedCreateWithoutRepliedToMessageInput = {
    id?: string
    conversationId: string
    senderId: string
    receiverId?: string | null
    roomId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    giftId?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    replies?: MessageUncheckedCreateNestedManyWithoutRepliedToMessageInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageCreateOrConnectWithoutRepliedToMessageInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRepliedToMessageInput, MessageUncheckedCreateWithoutRepliedToMessageInput>
  }

  export type MessageCreateManyRepliedToMessageInputEnvelope = {
    data: MessageCreateManyRepliedToMessageInput | MessageCreateManyRepliedToMessageInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutReportedMessageInput = {
    id?: string
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsMadeInput
    reportedUser?: UserCreateNestedOneWithoutReportsReceivedInput
    reportedStream?: StreamCreateNestedOneWithoutReportsInput
    reportedRoom?: ChatRoomCreateNestedOneWithoutReportsInput
    reviewer?: UserCreateNestedOneWithoutReviewedReportsInput
  }

  export type ReportUncheckedCreateWithoutReportedMessageInput = {
    id?: string
    reporterId: string
    reportedUserId?: string | null
    reportedStreamId?: string | null
    reportedRoomId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewedById?: string | null
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutReportedMessageInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedMessageInput, ReportUncheckedCreateWithoutReportedMessageInput>
  }

  export type ReportCreateManyReportedMessageInputEnvelope = {
    data: ReportCreateManyReportedMessageInput | ReportCreateManyReportedMessageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type ChatRoomUpsertWithoutMessagesInput = {
    update: XOR<ChatRoomUpdateWithoutMessagesInput, ChatRoomUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatRoomCreateWithoutMessagesInput, ChatRoomUncheckedCreateWithoutMessagesInput>
    where?: ChatRoomWhereInput
  }

  export type ChatRoomUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatRoomWhereInput
    data: XOR<ChatRoomUpdateWithoutMessagesInput, ChatRoomUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatRoomUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatRoomTypeFieldUpdateOperationsInput | $Enums.ChatRoomType
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipantCount?: IntFieldUpdateOperationsInput | number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: IntFieldUpdateOperationsInput | number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumChatRoomStatusFieldUpdateOperationsInput | $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChatRoomsNestedInput
    reports?: ReportUpdateManyWithoutReportedRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatRoomTypeFieldUpdateOperationsInput | $Enums.ChatRoomType
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipantCount?: IntFieldUpdateOperationsInput | number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: IntFieldUpdateOperationsInput | number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumChatRoomStatusFieldUpdateOperationsInput | $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutReportedRoomNestedInput
  }

  export type GiftUpsertWithoutMessagesInput = {
    update: XOR<GiftUpdateWithoutMessagesInput, GiftUncheckedUpdateWithoutMessagesInput>
    create: XOR<GiftCreateWithoutMessagesInput, GiftUncheckedCreateWithoutMessagesInput>
    where?: GiftWhereInput
  }

  export type GiftUpdateToOneWithWhereWithoutMessagesInput = {
    where?: GiftWhereInput
    data: XOR<GiftUpdateWithoutMessagesInput, GiftUncheckedUpdateWithoutMessagesInput>
  }

  export type GiftUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    giftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GiftUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    giftId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpsertWithoutRepliesInput = {
    update: XOR<MessageUpdateWithoutRepliesInput, MessageUncheckedUpdateWithoutRepliesInput>
    create: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutRepliesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutRepliesInput, MessageUncheckedUpdateWithoutRepliesInput>
  }

  export type MessageUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneWithoutReceivedMessagesNestedInput
    room?: ChatRoomUpdateOneWithoutMessagesNestedInput
    gift?: GiftUpdateOneWithoutMessagesNestedInput
    repliedToMessage?: MessageUpdateOneWithoutRepliesNestedInput
    reports?: ReportUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    giftId?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repliedToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reports?: ReportUncheckedUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutRepliedToMessageInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutRepliedToMessageInput, MessageUncheckedUpdateWithoutRepliedToMessageInput>
    create: XOR<MessageCreateWithoutRepliedToMessageInput, MessageUncheckedCreateWithoutRepliedToMessageInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutRepliedToMessageInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutRepliedToMessageInput, MessageUncheckedUpdateWithoutRepliedToMessageInput>
  }

  export type MessageUpdateManyWithWhereWithoutRepliedToMessageInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutRepliedToMessageInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedMessageInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedMessageInput, ReportUncheckedUpdateWithoutReportedMessageInput>
    create: XOR<ReportCreateWithoutReportedMessageInput, ReportUncheckedCreateWithoutReportedMessageInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedMessageInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedMessageInput, ReportUncheckedUpdateWithoutReportedMessageInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedMessageInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportedMessageInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserCreateWithoutFollowedByInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutFollowedByInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutFollowedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUpsertWithoutFollowedByInput = {
    update: XOR<UserUpdateWithoutFollowedByInput, UserUncheckedUpdateWithoutFollowedByInput>
    create: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowedByInput, UserUncheckedUpdateWithoutFollowedByInput>
  }

  export type UserUpdateWithoutFollowedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutSentFollowRequestsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutSentFollowRequestsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutSentFollowRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentFollowRequestsInput, UserUncheckedCreateWithoutSentFollowRequestsInput>
  }

  export type UserCreateWithoutReceivedFollowRequestsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutReceivedFollowRequestsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutReceivedFollowRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedFollowRequestsInput, UserUncheckedCreateWithoutReceivedFollowRequestsInput>
  }

  export type UserUpsertWithoutSentFollowRequestsInput = {
    update: XOR<UserUpdateWithoutSentFollowRequestsInput, UserUncheckedUpdateWithoutSentFollowRequestsInput>
    create: XOR<UserCreateWithoutSentFollowRequestsInput, UserUncheckedCreateWithoutSentFollowRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentFollowRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentFollowRequestsInput, UserUncheckedUpdateWithoutSentFollowRequestsInput>
  }

  export type UserUpdateWithoutSentFollowRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutSentFollowRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUpsertWithoutReceivedFollowRequestsInput = {
    update: XOR<UserUpdateWithoutReceivedFollowRequestsInput, UserUncheckedUpdateWithoutReceivedFollowRequestsInput>
    create: XOR<UserCreateWithoutReceivedFollowRequestsInput, UserUncheckedCreateWithoutReceivedFollowRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedFollowRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedFollowRequestsInput, UserUncheckedUpdateWithoutReceivedFollowRequestsInput>
  }

  export type UserUpdateWithoutReceivedFollowRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedFollowRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type GameCategoryCreateWithoutGamesInput = {
    id?: string
    name: string
    slug: string
    iconUrl?: string | null
    createdAt?: Date | string
  }

  export type GameCategoryUncheckedCreateWithoutGamesInput = {
    id?: string
    name: string
    slug: string
    iconUrl?: string | null
    createdAt?: Date | string
  }

  export type GameCategoryCreateOrConnectWithoutGamesInput = {
    where: GameCategoryWhereUniqueInput
    create: XOR<GameCategoryCreateWithoutGamesInput, GameCategoryUncheckedCreateWithoutGamesInput>
  }

  export type GameGenreTagCreateWithoutGameInput = {
    id?: string
    assignedAt?: Date | string
    genreTag: GenreTagCreateNestedOneWithoutGameGenreTagsInput
  }

  export type GameGenreTagUncheckedCreateWithoutGameInput = {
    id?: string
    genreTagId: string
    assignedAt?: Date | string
  }

  export type GameGenreTagCreateOrConnectWithoutGameInput = {
    where: GameGenreTagWhereUniqueInput
    create: XOR<GameGenreTagCreateWithoutGameInput, GameGenreTagUncheckedCreateWithoutGameInput>
  }

  export type GameGenreTagCreateManyGameInputEnvelope = {
    data: GameGenreTagCreateManyGameInput | GameGenreTagCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameSessionCreateWithoutGameInput = {
    id?: string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers: number
    currentPlayers?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    status?: $Enums.GameSessionStatus
    createdAt?: Date | string
    host: UserCreateNestedOneWithoutHostedGameSessionsInput
  }

  export type GameSessionUncheckedCreateWithoutGameInput = {
    id?: string
    hostId: string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers: number
    currentPlayers?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    status?: $Enums.GameSessionStatus
    createdAt?: Date | string
  }

  export type GameSessionCreateOrConnectWithoutGameInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput>
  }

  export type GameSessionCreateManyGameInputEnvelope = {
    data: GameSessionCreateManyGameInput | GameSessionCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameLikeCreateWithoutGameInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikedGamesInput
  }

  export type GameLikeUncheckedCreateWithoutGameInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type GameLikeCreateOrConnectWithoutGameInput = {
    where: GameLikeWhereUniqueInput
    create: XOR<GameLikeCreateWithoutGameInput, GameLikeUncheckedCreateWithoutGameInput>
  }

  export type GameLikeCreateManyGameInputEnvelope = {
    data: GameLikeCreateManyGameInput | GameLikeCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameRatingCreateWithoutGameInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGameRatingsInput
  }

  export type GameRatingUncheckedCreateWithoutGameInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameRatingCreateOrConnectWithoutGameInput = {
    where: GameRatingWhereUniqueInput
    create: XOR<GameRatingCreateWithoutGameInput, GameRatingUncheckedCreateWithoutGameInput>
  }

  export type GameRatingCreateManyGameInputEnvelope = {
    data: GameRatingCreateManyGameInput | GameRatingCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameCategoryUpsertWithoutGamesInput = {
    update: XOR<GameCategoryUpdateWithoutGamesInput, GameCategoryUncheckedUpdateWithoutGamesInput>
    create: XOR<GameCategoryCreateWithoutGamesInput, GameCategoryUncheckedCreateWithoutGamesInput>
    where?: GameCategoryWhereInput
  }

  export type GameCategoryUpdateToOneWithWhereWithoutGamesInput = {
    where?: GameCategoryWhereInput
    data: XOR<GameCategoryUpdateWithoutGamesInput, GameCategoryUncheckedUpdateWithoutGamesInput>
  }

  export type GameCategoryUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCategoryUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameGenreTagUpsertWithWhereUniqueWithoutGameInput = {
    where: GameGenreTagWhereUniqueInput
    update: XOR<GameGenreTagUpdateWithoutGameInput, GameGenreTagUncheckedUpdateWithoutGameInput>
    create: XOR<GameGenreTagCreateWithoutGameInput, GameGenreTagUncheckedCreateWithoutGameInput>
  }

  export type GameGenreTagUpdateWithWhereUniqueWithoutGameInput = {
    where: GameGenreTagWhereUniqueInput
    data: XOR<GameGenreTagUpdateWithoutGameInput, GameGenreTagUncheckedUpdateWithoutGameInput>
  }

  export type GameGenreTagUpdateManyWithWhereWithoutGameInput = {
    where: GameGenreTagScalarWhereInput
    data: XOR<GameGenreTagUpdateManyMutationInput, GameGenreTagUncheckedUpdateManyWithoutGameInput>
  }

  export type GameGenreTagScalarWhereInput = {
    AND?: GameGenreTagScalarWhereInput | GameGenreTagScalarWhereInput[]
    OR?: GameGenreTagScalarWhereInput[]
    NOT?: GameGenreTagScalarWhereInput | GameGenreTagScalarWhereInput[]
    id?: StringFilter<"GameGenreTag"> | string
    gameId?: StringFilter<"GameGenreTag"> | string
    genreTagId?: StringFilter<"GameGenreTag"> | string
    assignedAt?: DateTimeFilter<"GameGenreTag"> | Date | string
  }

  export type GameSessionUpsertWithWhereUniqueWithoutGameInput = {
    where: GameSessionWhereUniqueInput
    update: XOR<GameSessionUpdateWithoutGameInput, GameSessionUncheckedUpdateWithoutGameInput>
    create: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput>
  }

  export type GameSessionUpdateWithWhereUniqueWithoutGameInput = {
    where: GameSessionWhereUniqueInput
    data: XOR<GameSessionUpdateWithoutGameInput, GameSessionUncheckedUpdateWithoutGameInput>
  }

  export type GameSessionUpdateManyWithWhereWithoutGameInput = {
    where: GameSessionScalarWhereInput
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyWithoutGameInput>
  }

  export type GameLikeUpsertWithWhereUniqueWithoutGameInput = {
    where: GameLikeWhereUniqueInput
    update: XOR<GameLikeUpdateWithoutGameInput, GameLikeUncheckedUpdateWithoutGameInput>
    create: XOR<GameLikeCreateWithoutGameInput, GameLikeUncheckedCreateWithoutGameInput>
  }

  export type GameLikeUpdateWithWhereUniqueWithoutGameInput = {
    where: GameLikeWhereUniqueInput
    data: XOR<GameLikeUpdateWithoutGameInput, GameLikeUncheckedUpdateWithoutGameInput>
  }

  export type GameLikeUpdateManyWithWhereWithoutGameInput = {
    where: GameLikeScalarWhereInput
    data: XOR<GameLikeUpdateManyMutationInput, GameLikeUncheckedUpdateManyWithoutGameInput>
  }

  export type GameRatingUpsertWithWhereUniqueWithoutGameInput = {
    where: GameRatingWhereUniqueInput
    update: XOR<GameRatingUpdateWithoutGameInput, GameRatingUncheckedUpdateWithoutGameInput>
    create: XOR<GameRatingCreateWithoutGameInput, GameRatingUncheckedCreateWithoutGameInput>
  }

  export type GameRatingUpdateWithWhereUniqueWithoutGameInput = {
    where: GameRatingWhereUniqueInput
    data: XOR<GameRatingUpdateWithoutGameInput, GameRatingUncheckedUpdateWithoutGameInput>
  }

  export type GameRatingUpdateManyWithWhereWithoutGameInput = {
    where: GameRatingScalarWhereInput
    data: XOR<GameRatingUpdateManyMutationInput, GameRatingUncheckedUpdateManyWithoutGameInput>
  }

  export type GameGenreTagCreateWithoutGenreTagInput = {
    id?: string
    assignedAt?: Date | string
    game: GameCreateNestedOneWithoutGameGenreTagsInput
  }

  export type GameGenreTagUncheckedCreateWithoutGenreTagInput = {
    id?: string
    gameId: string
    assignedAt?: Date | string
  }

  export type GameGenreTagCreateOrConnectWithoutGenreTagInput = {
    where: GameGenreTagWhereUniqueInput
    create: XOR<GameGenreTagCreateWithoutGenreTagInput, GameGenreTagUncheckedCreateWithoutGenreTagInput>
  }

  export type GameGenreTagCreateManyGenreTagInputEnvelope = {
    data: GameGenreTagCreateManyGenreTagInput | GameGenreTagCreateManyGenreTagInput[]
    skipDuplicates?: boolean
  }

  export type GameGenreTagUpsertWithWhereUniqueWithoutGenreTagInput = {
    where: GameGenreTagWhereUniqueInput
    update: XOR<GameGenreTagUpdateWithoutGenreTagInput, GameGenreTagUncheckedUpdateWithoutGenreTagInput>
    create: XOR<GameGenreTagCreateWithoutGenreTagInput, GameGenreTagUncheckedCreateWithoutGenreTagInput>
  }

  export type GameGenreTagUpdateWithWhereUniqueWithoutGenreTagInput = {
    where: GameGenreTagWhereUniqueInput
    data: XOR<GameGenreTagUpdateWithoutGenreTagInput, GameGenreTagUncheckedUpdateWithoutGenreTagInput>
  }

  export type GameGenreTagUpdateManyWithWhereWithoutGenreTagInput = {
    where: GameGenreTagScalarWhereInput
    data: XOR<GameGenreTagUpdateManyMutationInput, GameGenreTagUncheckedUpdateManyWithoutGenreTagInput>
  }

  export type GameCreateWithoutGameGenreTagsInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    category?: GameCategoryCreateNestedOneWithoutGamesInput
    gameSessions?: GameSessionCreateNestedManyWithoutGameInput
    likes?: GameLikeCreateNestedManyWithoutGameInput
    ratings?: GameRatingCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutGameGenreTagsInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    categoryId?: string | null
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    likes?: GameLikeUncheckedCreateNestedManyWithoutGameInput
    ratings?: GameRatingUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutGameGenreTagsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutGameGenreTagsInput, GameUncheckedCreateWithoutGameGenreTagsInput>
  }

  export type GenreTagCreateWithoutGameGenreTagsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
  }

  export type GenreTagUncheckedCreateWithoutGameGenreTagsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
  }

  export type GenreTagCreateOrConnectWithoutGameGenreTagsInput = {
    where: GenreTagWhereUniqueInput
    create: XOR<GenreTagCreateWithoutGameGenreTagsInput, GenreTagUncheckedCreateWithoutGameGenreTagsInput>
  }

  export type GameUpsertWithoutGameGenreTagsInput = {
    update: XOR<GameUpdateWithoutGameGenreTagsInput, GameUncheckedUpdateWithoutGameGenreTagsInput>
    create: XOR<GameCreateWithoutGameGenreTagsInput, GameUncheckedCreateWithoutGameGenreTagsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutGameGenreTagsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutGameGenreTagsInput, GameUncheckedUpdateWithoutGameGenreTagsInput>
  }

  export type GameUpdateWithoutGameGenreTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: GameCategoryUpdateOneWithoutGamesNestedInput
    gameSessions?: GameSessionUpdateManyWithoutGameNestedInput
    likes?: GameLikeUpdateManyWithoutGameNestedInput
    ratings?: GameRatingUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutGameGenreTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    gameSessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    likes?: GameLikeUncheckedUpdateManyWithoutGameNestedInput
    ratings?: GameRatingUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GenreTagUpsertWithoutGameGenreTagsInput = {
    update: XOR<GenreTagUpdateWithoutGameGenreTagsInput, GenreTagUncheckedUpdateWithoutGameGenreTagsInput>
    create: XOR<GenreTagCreateWithoutGameGenreTagsInput, GenreTagUncheckedCreateWithoutGameGenreTagsInput>
    where?: GenreTagWhereInput
  }

  export type GenreTagUpdateToOneWithWhereWithoutGameGenreTagsInput = {
    where?: GenreTagWhereInput
    data: XOR<GenreTagUpdateWithoutGameGenreTagsInput, GenreTagUncheckedUpdateWithoutGameGenreTagsInput>
  }

  export type GenreTagUpdateWithoutGameGenreTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreTagUncheckedUpdateWithoutGameGenreTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutLikedGamesInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutLikedGamesInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutLikedGamesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedGamesInput, UserUncheckedCreateWithoutLikedGamesInput>
  }

  export type GameCreateWithoutLikesInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    category?: GameCategoryCreateNestedOneWithoutGamesInput
    gameGenreTags?: GameGenreTagCreateNestedManyWithoutGameInput
    gameSessions?: GameSessionCreateNestedManyWithoutGameInput
    ratings?: GameRatingCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutLikesInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    categoryId?: string | null
    gameGenreTags?: GameGenreTagUncheckedCreateNestedManyWithoutGameInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    ratings?: GameRatingUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutLikesInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutLikesInput, GameUncheckedCreateWithoutLikesInput>
  }

  export type UserUpsertWithoutLikedGamesInput = {
    update: XOR<UserUpdateWithoutLikedGamesInput, UserUncheckedUpdateWithoutLikedGamesInput>
    create: XOR<UserCreateWithoutLikedGamesInput, UserUncheckedCreateWithoutLikedGamesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikedGamesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikedGamesInput, UserUncheckedUpdateWithoutLikedGamesInput>
  }

  export type UserUpdateWithoutLikedGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type GameUpsertWithoutLikesInput = {
    update: XOR<GameUpdateWithoutLikesInput, GameUncheckedUpdateWithoutLikesInput>
    create: XOR<GameCreateWithoutLikesInput, GameUncheckedCreateWithoutLikesInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutLikesInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutLikesInput, GameUncheckedUpdateWithoutLikesInput>
  }

  export type GameUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: GameCategoryUpdateOneWithoutGamesNestedInput
    gameGenreTags?: GameGenreTagUpdateManyWithoutGameNestedInput
    gameSessions?: GameSessionUpdateManyWithoutGameNestedInput
    ratings?: GameRatingUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    gameGenreTags?: GameGenreTagUncheckedUpdateManyWithoutGameNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    ratings?: GameRatingUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserCreateWithoutGameRatingsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutGameRatingsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutGameRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGameRatingsInput, UserUncheckedCreateWithoutGameRatingsInput>
  }

  export type GameCreateWithoutRatingsInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    category?: GameCategoryCreateNestedOneWithoutGamesInput
    gameGenreTags?: GameGenreTagCreateNestedManyWithoutGameInput
    gameSessions?: GameSessionCreateNestedManyWithoutGameInput
    likes?: GameLikeCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutRatingsInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    categoryId?: string | null
    gameGenreTags?: GameGenreTagUncheckedCreateNestedManyWithoutGameInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    likes?: GameLikeUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutRatingsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutRatingsInput, GameUncheckedCreateWithoutRatingsInput>
  }

  export type UserUpsertWithoutGameRatingsInput = {
    update: XOR<UserUpdateWithoutGameRatingsInput, UserUncheckedUpdateWithoutGameRatingsInput>
    create: XOR<UserCreateWithoutGameRatingsInput, UserUncheckedCreateWithoutGameRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGameRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGameRatingsInput, UserUncheckedUpdateWithoutGameRatingsInput>
  }

  export type UserUpdateWithoutGameRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutGameRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type GameUpsertWithoutRatingsInput = {
    update: XOR<GameUpdateWithoutRatingsInput, GameUncheckedUpdateWithoutRatingsInput>
    create: XOR<GameCreateWithoutRatingsInput, GameUncheckedCreateWithoutRatingsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutRatingsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutRatingsInput, GameUncheckedUpdateWithoutRatingsInput>
  }

  export type GameUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: GameCategoryUpdateOneWithoutGamesNestedInput
    gameGenreTags?: GameGenreTagUpdateManyWithoutGameNestedInput
    gameSessions?: GameSessionUpdateManyWithoutGameNestedInput
    likes?: GameLikeUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    gameGenreTags?: GameGenreTagUncheckedUpdateManyWithoutGameNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    likes?: GameLikeUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateWithoutCategoryInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    gameGenreTags?: GameGenreTagCreateNestedManyWithoutGameInput
    gameSessions?: GameSessionCreateNestedManyWithoutGameInput
    likes?: GameLikeCreateNestedManyWithoutGameInput
    ratings?: GameRatingCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutCategoryInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    gameGenreTags?: GameGenreTagUncheckedCreateNestedManyWithoutGameInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    likes?: GameLikeUncheckedCreateNestedManyWithoutGameInput
    ratings?: GameRatingUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutCategoryInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutCategoryInput, GameUncheckedCreateWithoutCategoryInput>
  }

  export type GameCreateManyCategoryInputEnvelope = {
    data: GameCreateManyCategoryInput | GameCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type GameUpsertWithWhereUniqueWithoutCategoryInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutCategoryInput, GameUncheckedUpdateWithoutCategoryInput>
    create: XOR<GameCreateWithoutCategoryInput, GameUncheckedCreateWithoutCategoryInput>
  }

  export type GameUpdateWithWhereUniqueWithoutCategoryInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutCategoryInput, GameUncheckedUpdateWithoutCategoryInput>
  }

  export type GameUpdateManyWithWhereWithoutCategoryInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutCategoryInput>
  }

  export type GameScalarWhereInput = {
    AND?: GameScalarWhereInput | GameScalarWhereInput[]
    OR?: GameScalarWhereInput[]
    NOT?: GameScalarWhereInput | GameScalarWhereInput[]
    id?: StringFilter<"Game"> | string
    gameId?: StringFilter<"Game"> | string
    name?: StringFilter<"Game"> | string
    description?: StringNullableFilter<"Game"> | string | null
    iconUrl?: StringNullableFilter<"Game"> | string | null
    entryCost?: BigIntFilter<"Game"> | bigint | number
    rewardStructure?: JsonNullableFilter<"Game">
    isActive?: BoolFilter<"Game"> | boolean
    developer?: StringNullableFilter<"Game"> | string | null
    publisher?: StringNullableFilter<"Game"> | string | null
    releaseDate?: DateTimeNullableFilter<"Game"> | Date | string | null
    platformCompat?: JsonNullableFilter<"Game">
    likeCount?: IntFilter<"Game"> | number
    playCount?: IntFilter<"Game"> | number
    averageRating?: FloatFilter<"Game"> | number
    ratingCount?: IntFilter<"Game"> | number
    createdAt?: DateTimeFilter<"Game"> | Date | string
    categoryId?: StringNullableFilter<"Game"> | string | null
  }

  export type GameCreateWithoutGameSessionsInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    category?: GameCategoryCreateNestedOneWithoutGamesInput
    gameGenreTags?: GameGenreTagCreateNestedManyWithoutGameInput
    likes?: GameLikeCreateNestedManyWithoutGameInput
    ratings?: GameRatingCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutGameSessionsInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
    categoryId?: string | null
    gameGenreTags?: GameGenreTagUncheckedCreateNestedManyWithoutGameInput
    likes?: GameLikeUncheckedCreateNestedManyWithoutGameInput
    ratings?: GameRatingUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutGameSessionsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutGameSessionsInput, GameUncheckedCreateWithoutGameSessionsInput>
  }

  export type UserCreateWithoutHostedGameSessionsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutHostedGameSessionsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutHostedGameSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHostedGameSessionsInput, UserUncheckedCreateWithoutHostedGameSessionsInput>
  }

  export type GameUpsertWithoutGameSessionsInput = {
    update: XOR<GameUpdateWithoutGameSessionsInput, GameUncheckedUpdateWithoutGameSessionsInput>
    create: XOR<GameCreateWithoutGameSessionsInput, GameUncheckedCreateWithoutGameSessionsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutGameSessionsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutGameSessionsInput, GameUncheckedUpdateWithoutGameSessionsInput>
  }

  export type GameUpdateWithoutGameSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: GameCategoryUpdateOneWithoutGamesNestedInput
    gameGenreTags?: GameGenreTagUpdateManyWithoutGameNestedInput
    likes?: GameLikeUpdateManyWithoutGameNestedInput
    ratings?: GameRatingUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutGameSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    gameGenreTags?: GameGenreTagUncheckedUpdateManyWithoutGameNestedInput
    likes?: GameLikeUncheckedUpdateManyWithoutGameNestedInput
    ratings?: GameRatingUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserUpsertWithoutHostedGameSessionsInput = {
    update: XOR<UserUpdateWithoutHostedGameSessionsInput, UserUncheckedUpdateWithoutHostedGameSessionsInput>
    create: XOR<UserCreateWithoutHostedGameSessionsInput, UserUncheckedCreateWithoutHostedGameSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHostedGameSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHostedGameSessionsInput, UserUncheckedUpdateWithoutHostedGameSessionsInput>
  }

  export type UserUpdateWithoutHostedGameSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutHostedGameSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type MessageCreateWithoutGiftInput = {
    id?: string
    conversationId: string
    messageType: $Enums.MessageType
    content?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver?: UserCreateNestedOneWithoutReceivedMessagesInput
    room?: ChatRoomCreateNestedOneWithoutMessagesInput
    repliedToMessage?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutRepliedToMessageInput
    reports?: ReportCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageUncheckedCreateWithoutGiftInput = {
    id?: string
    conversationId: string
    senderId: string
    receiverId?: string | null
    roomId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    repliedToMessageId?: string | null
    replies?: MessageUncheckedCreateNestedManyWithoutRepliedToMessageInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageCreateOrConnectWithoutGiftInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutGiftInput, MessageUncheckedCreateWithoutGiftInput>
  }

  export type MessageCreateManyGiftInputEnvelope = {
    data: MessageCreateManyGiftInput | MessageCreateManyGiftInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutGiftInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutGiftInput, MessageUncheckedUpdateWithoutGiftInput>
    create: XOR<MessageCreateWithoutGiftInput, MessageUncheckedCreateWithoutGiftInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutGiftInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutGiftInput, MessageUncheckedUpdateWithoutGiftInput>
  }

  export type MessageUpdateManyWithWhereWithoutGiftInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutGiftInput>
  }

  export type UserCreateWithoutReportsMadeInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutReportsMadeInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutReportsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
  }

  export type UserCreateWithoutReportsReceivedInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutReportsReceivedInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutReportsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
  }

  export type StreamCreateWithoutReportsInput = {
    id?: string
    title?: string | null
    coverImageUrl?: string | null
    status?: $Enums.StreamStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    currentViewers?: number
    peakViewers?: number
    totalDiamondsReceived?: bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    recordingUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    broadcaster: UserCreateNestedOneWithoutStreamsInput
  }

  export type StreamUncheckedCreateWithoutReportsInput = {
    id?: string
    broadcasterId: string
    title?: string | null
    coverImageUrl?: string | null
    status?: $Enums.StreamStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    currentViewers?: number
    peakViewers?: number
    totalDiamondsReceived?: bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    recordingUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StreamCreateOrConnectWithoutReportsInput = {
    where: StreamWhereUniqueInput
    create: XOR<StreamCreateWithoutReportsInput, StreamUncheckedCreateWithoutReportsInput>
  }

  export type ChatRoomCreateWithoutReportsInput = {
    id?: string
    title: string
    description?: string | null
    coverImageUrl?: string | null
    type: $Enums.ChatRoomType
    passwordHash?: string | null
    maxParticipants: number
    currentParticipantCount?: number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedChatRoomsInput
    messages?: MessageCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomUncheckedCreateWithoutReportsInput = {
    id?: string
    ownerId: string
    title: string
    description?: string | null
    coverImageUrl?: string | null
    type: $Enums.ChatRoomType
    passwordHash?: string | null
    maxParticipants: number
    currentParticipantCount?: number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomCreateOrConnectWithoutReportsInput = {
    where: ChatRoomWhereUniqueInput
    create: XOR<ChatRoomCreateWithoutReportsInput, ChatRoomUncheckedCreateWithoutReportsInput>
  }

  export type MessageCreateWithoutReportsInput = {
    id?: string
    conversationId: string
    messageType: $Enums.MessageType
    content?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver?: UserCreateNestedOneWithoutReceivedMessagesInput
    room?: ChatRoomCreateNestedOneWithoutMessagesInput
    gift?: GiftCreateNestedOneWithoutMessagesInput
    repliedToMessage?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutRepliedToMessageInput
  }

  export type MessageUncheckedCreateWithoutReportsInput = {
    id?: string
    conversationId: string
    senderId: string
    receiverId?: string | null
    roomId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    giftId?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    repliedToMessageId?: string | null
    replies?: MessageUncheckedCreateNestedManyWithoutRepliedToMessageInput
  }

  export type MessageCreateOrConnectWithoutReportsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReportsInput, MessageUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutReviewedReportsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutReviewedReportsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutReviewedReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedReportsInput, UserUncheckedCreateWithoutReviewedReportsInput>
  }

  export type UserUpsertWithoutReportsMadeInput = {
    update: XOR<UserUpdateWithoutReportsMadeInput, UserUncheckedUpdateWithoutReportsMadeInput>
    create: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsMadeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsMadeInput, UserUncheckedUpdateWithoutReportsMadeInput>
  }

  export type UserUpdateWithoutReportsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUpsertWithoutReportsReceivedInput = {
    update: XOR<UserUpdateWithoutReportsReceivedInput, UserUncheckedUpdateWithoutReportsReceivedInput>
    create: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsReceivedInput, UserUncheckedUpdateWithoutReportsReceivedInput>
  }

  export type UserUpdateWithoutReportsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type StreamUpsertWithoutReportsInput = {
    update: XOR<StreamUpdateWithoutReportsInput, StreamUncheckedUpdateWithoutReportsInput>
    create: XOR<StreamCreateWithoutReportsInput, StreamUncheckedCreateWithoutReportsInput>
    where?: StreamWhereInput
  }

  export type StreamUpdateToOneWithWhereWithoutReportsInput = {
    where?: StreamWhereInput
    data: XOR<StreamUpdateWithoutReportsInput, StreamUncheckedUpdateWithoutReportsInput>
  }

  export type StreamUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentViewers?: IntFieldUpdateOperationsInput | number
    peakViewers?: IntFieldUpdateOperationsInput | number
    totalDiamondsReceived?: BigIntFieldUpdateOperationsInput | bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    broadcaster?: UserUpdateOneRequiredWithoutStreamsNestedInput
  }

  export type StreamUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    broadcasterId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentViewers?: IntFieldUpdateOperationsInput | number
    peakViewers?: IntFieldUpdateOperationsInput | number
    totalDiamondsReceived?: BigIntFieldUpdateOperationsInput | bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatRoomUpsertWithoutReportsInput = {
    update: XOR<ChatRoomUpdateWithoutReportsInput, ChatRoomUncheckedUpdateWithoutReportsInput>
    create: XOR<ChatRoomCreateWithoutReportsInput, ChatRoomUncheckedCreateWithoutReportsInput>
    where?: ChatRoomWhereInput
  }

  export type ChatRoomUpdateToOneWithWhereWithoutReportsInput = {
    where?: ChatRoomWhereInput
    data: XOR<ChatRoomUpdateWithoutReportsInput, ChatRoomUncheckedUpdateWithoutReportsInput>
  }

  export type ChatRoomUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatRoomTypeFieldUpdateOperationsInput | $Enums.ChatRoomType
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipantCount?: IntFieldUpdateOperationsInput | number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: IntFieldUpdateOperationsInput | number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumChatRoomStatusFieldUpdateOperationsInput | $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedChatRoomsNestedInput
    messages?: MessageUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatRoomTypeFieldUpdateOperationsInput | $Enums.ChatRoomType
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipantCount?: IntFieldUpdateOperationsInput | number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: IntFieldUpdateOperationsInput | number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumChatRoomStatusFieldUpdateOperationsInput | $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type MessageUpsertWithoutReportsInput = {
    update: XOR<MessageUpdateWithoutReportsInput, MessageUncheckedUpdateWithoutReportsInput>
    create: XOR<MessageCreateWithoutReportsInput, MessageUncheckedCreateWithoutReportsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutReportsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutReportsInput, MessageUncheckedUpdateWithoutReportsInput>
  }

  export type MessageUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneWithoutReceivedMessagesNestedInput
    room?: ChatRoomUpdateOneWithoutMessagesNestedInput
    gift?: GiftUpdateOneWithoutMessagesNestedInput
    repliedToMessage?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutRepliedToMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    giftId?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repliedToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessageUncheckedUpdateManyWithoutRepliedToMessageNestedInput
  }

  export type UserUpsertWithoutReviewedReportsInput = {
    update: XOR<UserUpdateWithoutReviewedReportsInput, UserUncheckedUpdateWithoutReviewedReportsInput>
    create: XOR<UserCreateWithoutReviewedReportsInput, UserUncheckedCreateWithoutReviewedReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedReportsInput, UserUncheckedUpdateWithoutReviewedReportsInput>
  }

  export type UserUpdateWithoutReviewedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutSentNotificationsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
  }

  export type UserUncheckedCreateWithoutSentNotificationsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
  }

  export type UserCreateOrConnectWithoutSentNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUpsertWithoutSentNotificationsInput = {
    update: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type UserUpdateWithoutSentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
  }

  export type UserUncheckedUpdateWithoutSentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
  }

  export type UserCreateWithoutStreamsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutStreamsInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutStreamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStreamsInput, UserUncheckedCreateWithoutStreamsInput>
  }

  export type ReportCreateWithoutReportedStreamInput = {
    id?: string
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsMadeInput
    reportedUser?: UserCreateNestedOneWithoutReportsReceivedInput
    reportedRoom?: ChatRoomCreateNestedOneWithoutReportsInput
    reportedMessage?: MessageCreateNestedOneWithoutReportsInput
    reviewer?: UserCreateNestedOneWithoutReviewedReportsInput
  }

  export type ReportUncheckedCreateWithoutReportedStreamInput = {
    id?: string
    reporterId: string
    reportedUserId?: string | null
    reportedRoomId?: string | null
    reportedMessageId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewedById?: string | null
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutReportedStreamInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedStreamInput, ReportUncheckedCreateWithoutReportedStreamInput>
  }

  export type ReportCreateManyReportedStreamInputEnvelope = {
    data: ReportCreateManyReportedStreamInput | ReportCreateManyReportedStreamInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStreamsInput = {
    update: XOR<UserUpdateWithoutStreamsInput, UserUncheckedUpdateWithoutStreamsInput>
    create: XOR<UserCreateWithoutStreamsInput, UserUncheckedCreateWithoutStreamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStreamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStreamsInput, UserUncheckedUpdateWithoutStreamsInput>
  }

  export type UserUpdateWithoutStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedStreamInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedStreamInput, ReportUncheckedUpdateWithoutReportedStreamInput>
    create: XOR<ReportCreateWithoutReportedStreamInput, ReportUncheckedCreateWithoutReportedStreamInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedStreamInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedStreamInput, ReportUncheckedUpdateWithoutReportedStreamInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedStreamInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportedStreamInput>
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutOneSignalPlayersInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    trustedDevices?: TrustedDeviceCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutOneSignalPlayersInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    trustedDevices?: TrustedDeviceUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutOneSignalPlayersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOneSignalPlayersInput, UserUncheckedCreateWithoutOneSignalPlayersInput>
  }

  export type UserUpsertWithoutOneSignalPlayersInput = {
    update: XOR<UserUpdateWithoutOneSignalPlayersInput, UserUncheckedUpdateWithoutOneSignalPlayersInput>
    create: XOR<UserCreateWithoutOneSignalPlayersInput, UserUncheckedCreateWithoutOneSignalPlayersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOneSignalPlayersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOneSignalPlayersInput, UserUncheckedUpdateWithoutOneSignalPlayersInput>
  }

  export type UserUpdateWithoutOneSignalPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutOneSignalPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutTrustedDevicesInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionCreateNestedManyWithoutHostInput
    streams?: StreamCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestCreateNestedManyWithoutRecipientInput
    followedBy?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutTrustedDevicesInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
    invitedByForeignKey?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    oneSignalPlayers?: OneSignalPlayerUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reviewedReports?: ReportUncheckedCreateNestedManyWithoutReviewerInput
    hostedGameSessions?: GameSessionUncheckedCreateNestedManyWithoutHostInput
    streams?: StreamUncheckedCreateNestedManyWithoutBroadcasterInput
    ownedChatRooms?: ChatRoomUncheckedCreateNestedManyWithoutOwnerInput
    sentFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFollowRequests?: FollowRequestUncheckedCreateNestedManyWithoutRecipientInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    likedGames?: GameLikeUncheckedCreateNestedManyWithoutUserInput
    gameRatings?: GameRatingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutTrustedDevicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrustedDevicesInput, UserUncheckedCreateWithoutTrustedDevicesInput>
  }

  export type UserUpsertWithoutTrustedDevicesInput = {
    update: XOR<UserUpdateWithoutTrustedDevicesInput, UserUncheckedUpdateWithoutTrustedDevicesInput>
    create: XOR<UserCreateWithoutTrustedDevicesInput, UserUncheckedCreateWithoutTrustedDevicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrustedDevicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrustedDevicesInput, UserUncheckedUpdateWithoutTrustedDevicesInput>
  }

  export type UserUpdateWithoutTrustedDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutTrustedDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedByForeignKey?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateManyInvitedByInput = {
    id?: string
    authProvider?: string | null
    authId?: string | null
    username: string
    nickname?: string | null
    profilePictureUrl?: string | null
    bio?: string | null
    gender?: $Enums.UserGender | null
    birthDate?: Date | string | null
    country?: string | null
    region?: string | null
    level?: number
    vipLevel?: number
    coins?: bigint | number
    diamonds?: bigint | number
    email: string
    password?: string | null
    passwordChangedAt?: Date | string | null
    isEmailVerified?: boolean
    lastLoginAt?: Date | string | null
    followingCount?: number
    followerCount?: number
    status?: $Enums.UserStatus
    isOnline?: boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: $Enums.UserAccountStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.UserRole
    isPrivate?: boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpiresAt?: Date | string | null
    postCount?: number
  }

  export type TrustedDeviceCreateManyUserInput = {
    id?: string
    deviceName: string
    deviceType?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    location?: string | null
    isCurrentDevice?: boolean
    lastUsedAt?: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    lastUsedAt?: Date | string
  }

  export type OneSignalPlayerCreateManyUserInput = {
    id?: string
    playerId: string
    deviceInfo?: string | null
    lastSeen?: Date | string
    createdAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    transactionType: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    description?: string | null
    platform?: string | null
    platformTransactionId?: string | null
    status?: $Enums.TransactionStatus
    paymentGatewayToken?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    conversationId: string
    receiverId?: string | null
    roomId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    giftId?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    repliedToMessageId?: string | null
  }

  export type MessageCreateManyReceiverInput = {
    id?: string
    conversationId: string
    senderId: string
    roomId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    giftId?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    repliedToMessageId?: string | null
  }

  export type ReportCreateManyReporterInput = {
    id?: string
    reportedUserId?: string | null
    reportedStreamId?: string | null
    reportedRoomId?: string | null
    reportedMessageId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewedById?: string | null
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportCreateManyReportedUserInput = {
    id?: string
    reporterId: string
    reportedStreamId?: string | null
    reportedRoomId?: string | null
    reportedMessageId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewedById?: string | null
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportCreateManyReviewerInput = {
    id?: string
    reporterId: string
    reportedUserId?: string | null
    reportedStreamId?: string | null
    reportedRoomId?: string | null
    reportedMessageId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type GameSessionCreateManyHostInput = {
    id?: string
    gameId: string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers: number
    currentPlayers?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    status?: $Enums.GameSessionStatus
    createdAt?: Date | string
  }

  export type StreamCreateManyBroadcasterInput = {
    id?: string
    title?: string | null
    coverImageUrl?: string | null
    status?: $Enums.StreamStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    currentViewers?: number
    peakViewers?: number
    totalDiamondsReceived?: bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    recordingUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatRoomCreateManyOwnerInput = {
    id?: string
    title: string
    description?: string | null
    coverImageUrl?: string | null
    type: $Enums.ChatRoomType
    passwordHash?: string | null
    maxParticipants: number
    currentParticipantCount?: number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowRequestCreateManyRequesterInput = {
    id?: string
    recipientId: string
    status?: $Enums.FollowRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowRequestCreateManyRecipientInput = {
    id?: string
    requesterId: string
    status?: $Enums.FollowRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateManyFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type FollowCreateManyFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type GameLikeCreateManyUserInput = {
    id?: string
    gameId: string
    createdAt?: Date | string
  }

  export type GameRatingCreateManyUserInput = {
    id?: string
    gameId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyRecipientInput = {
    id?: string
    senderId?: string | null
    type: $Enums.NotificationType
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    content?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateManySenderInput = {
    id?: string
    recipientId: string
    type: $Enums.NotificationType
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    content?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type UserUpdateWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUpdateManyWithoutHostNestedInput
    streams?: StreamUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    trustedDevices?: TrustedDeviceUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    oneSignalPlayers?: OneSignalPlayerUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reviewedReports?: ReportUncheckedUpdateManyWithoutReviewerNestedInput
    hostedGameSessions?: GameSessionUncheckedUpdateManyWithoutHostNestedInput
    streams?: StreamUncheckedUpdateManyWithoutBroadcasterNestedInput
    ownedChatRooms?: ChatRoomUncheckedUpdateManyWithoutOwnerNestedInput
    sentFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFollowRequests?: FollowRequestUncheckedUpdateManyWithoutRecipientNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    likedGames?: GameLikeUncheckedUpdateManyWithoutUserNestedInput
    gameRatings?: GameRatingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateManyWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    authProvider?: NullableStringFieldUpdateOperationsInput | string | null
    authId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    vipLevel?: IntFieldUpdateOperationsInput | number
    coins?: BigIntFieldUpdateOperationsInput | bigint | number
    diamonds?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingCount?: IntFieldUpdateOperationsInput | number
    followerCount?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    preferences?: NullableJsonNullValueInput | InputJsonValue
    allowDirectMessages?: BoolFieldUpdateOperationsInput | boolean
    notificationSettings?: NullableJsonNullValueInput | InputJsonValue
    blockedUserIds?: NullableJsonNullValueInput | InputJsonValue
    accountStatus?: EnumUserAccountStatusFieldUpdateOperationsInput | $Enums.UserAccountStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    pinnedMessagesInRooms?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postCount?: IntFieldUpdateOperationsInput | number
  }

  export type TrustedDeviceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrentDevice?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustedDeviceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrentDevice?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustedDeviceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrentDevice?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneSignalPlayerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneSignalPlayerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneSignalPlayerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    platformTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentGatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    platformTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentGatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    platformTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentGatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneWithoutReceivedMessagesNestedInput
    room?: ChatRoomUpdateOneWithoutMessagesNestedInput
    gift?: GiftUpdateOneWithoutMessagesNestedInput
    repliedToMessage?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutRepliedToMessageNestedInput
    reports?: ReportUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    giftId?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repliedToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessageUncheckedUpdateManyWithoutRepliedToMessageNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    giftId?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repliedToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    room?: ChatRoomUpdateOneWithoutMessagesNestedInput
    gift?: GiftUpdateOneWithoutMessagesNestedInput
    repliedToMessage?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutRepliedToMessageNestedInput
    reports?: ReportUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    giftId?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repliedToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessageUncheckedUpdateManyWithoutRepliedToMessageNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    giftId?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repliedToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedUser?: UserUpdateOneWithoutReportsReceivedNestedInput
    reportedStream?: StreamUpdateOneWithoutReportsNestedInput
    reportedRoom?: ChatRoomUpdateOneWithoutReportsNestedInput
    reportedMessage?: MessageUpdateOneWithoutReportsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedStreamId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedStreamId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
    reportedStream?: StreamUpdateOneWithoutReportsNestedInput
    reportedRoom?: ChatRoomUpdateOneWithoutReportsNestedInput
    reportedMessage?: MessageUpdateOneWithoutReportsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedStreamId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedStreamId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
    reportedUser?: UserUpdateOneWithoutReportsReceivedNestedInput
    reportedStream?: StreamUpdateOneWithoutReportsNestedInput
    reportedRoom?: ChatRoomUpdateOneWithoutReportsNestedInput
    reportedMessage?: MessageUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedStreamId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedStreamId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGameSessionStatusFieldUpdateOperationsInput | $Enums.GameSessionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutGameSessionsNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGameSessionStatusFieldUpdateOperationsInput | $Enums.GameSessionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUncheckedUpdateManyWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGameSessionStatusFieldUpdateOperationsInput | $Enums.GameSessionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamUpdateWithoutBroadcasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentViewers?: IntFieldUpdateOperationsInput | number
    peakViewers?: IntFieldUpdateOperationsInput | number
    totalDiamondsReceived?: BigIntFieldUpdateOperationsInput | bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutReportedStreamNestedInput
  }

  export type StreamUncheckedUpdateWithoutBroadcasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentViewers?: IntFieldUpdateOperationsInput | number
    peakViewers?: IntFieldUpdateOperationsInput | number
    totalDiamondsReceived?: BigIntFieldUpdateOperationsInput | bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutReportedStreamNestedInput
  }

  export type StreamUncheckedUpdateManyWithoutBroadcasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStreamStatusFieldUpdateOperationsInput | $Enums.StreamStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentViewers?: IntFieldUpdateOperationsInput | number
    peakViewers?: IntFieldUpdateOperationsInput | number
    totalDiamondsReceived?: BigIntFieldUpdateOperationsInput | bigint | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatRoomUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatRoomTypeFieldUpdateOperationsInput | $Enums.ChatRoomType
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipantCount?: IntFieldUpdateOperationsInput | number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: IntFieldUpdateOperationsInput | number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumChatRoomStatusFieldUpdateOperationsInput | $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutRoomNestedInput
    reports?: ReportUpdateManyWithoutReportedRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatRoomTypeFieldUpdateOperationsInput | $Enums.ChatRoomType
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipantCount?: IntFieldUpdateOperationsInput | number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: IntFieldUpdateOperationsInput | number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumChatRoomStatusFieldUpdateOperationsInput | $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutRoomNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatRoomTypeFieldUpdateOperationsInput | $Enums.ChatRoomType
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipantCount?: IntFieldUpdateOperationsInput | number
    activeParticipants?: NullableJsonNullValueInput | InputJsonValue
    moderators?: NullableJsonNullValueInput | InputJsonValue
    speakerSeatCount?: IntFieldUpdateOperationsInput | number
    speakerSeatAssignments?: NullableJsonNullValueInput | InputJsonValue
    rtcChannelName?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumChatRoomStatusFieldUpdateOperationsInput | $Enums.ChatRoomStatus
    pinnedMessageIds?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowRequestUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowRequestStatusFieldUpdateOperationsInput | $Enums.FollowRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutReceivedFollowRequestsNestedInput
  }

  export type FollowRequestUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowRequestStatusFieldUpdateOperationsInput | $Enums.FollowRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowRequestUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowRequestStatusFieldUpdateOperationsInput | $Enums.FollowRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowRequestUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowRequestStatusFieldUpdateOperationsInput | $Enums.FollowRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutSentFollowRequestsNestedInput
  }

  export type FollowRequestUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowRequestStatusFieldUpdateOperationsInput | $Enums.FollowRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowRequestUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowRequestStatusFieldUpdateOperationsInput | $Enums.FollowRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UserUpdateOneRequiredWithoutFollowedByNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameLikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutLikesNestedInput
  }

  export type GameLikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameLikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameRatingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type GameRatingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameRatingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyRoomInput = {
    id?: string
    conversationId: string
    senderId: string
    receiverId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    giftId?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    repliedToMessageId?: string | null
  }

  export type ReportCreateManyReportedRoomInput = {
    id?: string
    reporterId: string
    reportedUserId?: string | null
    reportedStreamId?: string | null
    reportedMessageId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewedById?: string | null
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneWithoutReceivedMessagesNestedInput
    gift?: GiftUpdateOneWithoutMessagesNestedInput
    repliedToMessage?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutRepliedToMessageNestedInput
    reports?: ReportUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    giftId?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repliedToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessageUncheckedUpdateManyWithoutRepliedToMessageNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    giftId?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repliedToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUpdateWithoutReportedRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
    reportedUser?: UserUpdateOneWithoutReportsReceivedNestedInput
    reportedStream?: StreamUpdateOneWithoutReportsNestedInput
    reportedMessage?: MessageUpdateOneWithoutReportsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedStreamId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReportedRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedStreamId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyRepliedToMessageInput = {
    id?: string
    conversationId: string
    senderId: string
    receiverId?: string | null
    roomId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    giftId?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReportCreateManyReportedMessageInput = {
    id?: string
    reporterId: string
    reportedUserId?: string | null
    reportedStreamId?: string | null
    reportedRoomId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewedById?: string | null
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutRepliedToMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneWithoutReceivedMessagesNestedInput
    room?: ChatRoomUpdateOneWithoutMessagesNestedInput
    gift?: GiftUpdateOneWithoutMessagesNestedInput
    replies?: MessageUpdateManyWithoutRepliedToMessageNestedInput
    reports?: ReportUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRepliedToMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    giftId?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: MessageUncheckedUpdateManyWithoutRepliedToMessageNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutRepliedToMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    giftId?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutReportedMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
    reportedUser?: UserUpdateOneWithoutReportsReceivedNestedInput
    reportedStream?: StreamUpdateOneWithoutReportsNestedInput
    reportedRoom?: ChatRoomUpdateOneWithoutReportsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedStreamId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReportedMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedStreamId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameGenreTagCreateManyGameInput = {
    id?: string
    genreTagId: string
    assignedAt?: Date | string
  }

  export type GameSessionCreateManyGameInput = {
    id?: string
    hostId: string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers: number
    currentPlayers?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    status?: $Enums.GameSessionStatus
    createdAt?: Date | string
  }

  export type GameLikeCreateManyGameInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type GameRatingCreateManyGameInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameGenreTagUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    genreTag?: GenreTagUpdateOneRequiredWithoutGameGenreTagsNestedInput
  }

  export type GameGenreTagUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    genreTagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameGenreTagUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    genreTagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGameSessionStatusFieldUpdateOperationsInput | $Enums.GameSessionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: UserUpdateOneRequiredWithoutHostedGameSessionsNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGameSessionStatusFieldUpdateOperationsInput | $Enums.GameSessionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    participants?: NullableJsonNullValueInput | InputJsonValue
    viewerIds?: NullableJsonNullValueInput | InputJsonValue
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGameSessionStatusFieldUpdateOperationsInput | $Enums.GameSessionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameLikeUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedGamesNestedInput
  }

  export type GameLikeUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameLikeUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameRatingUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGameRatingsNestedInput
  }

  export type GameRatingUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameRatingUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameGenreTagCreateManyGenreTagInput = {
    id?: string
    gameId: string
    assignedAt?: Date | string
  }

  export type GameGenreTagUpdateWithoutGenreTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutGameGenreTagsNestedInput
  }

  export type GameGenreTagUncheckedUpdateWithoutGenreTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameGenreTagUncheckedUpdateManyWithoutGenreTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateManyCategoryInput = {
    id?: string
    gameId: string
    name: string
    description?: string | null
    iconUrl?: string | null
    entryCost?: bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    developer?: string | null
    publisher?: string | null
    releaseDate?: Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: number
    playCount?: number
    averageRating?: number
    ratingCount?: number
    createdAt?: Date | string
  }

  export type GameUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameGenreTags?: GameGenreTagUpdateManyWithoutGameNestedInput
    gameSessions?: GameSessionUpdateManyWithoutGameNestedInput
    likes?: GameLikeUpdateManyWithoutGameNestedInput
    ratings?: GameRatingUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameGenreTags?: GameGenreTagUncheckedUpdateManyWithoutGameNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    likes?: GameLikeUncheckedUpdateManyWithoutGameNestedInput
    ratings?: GameRatingUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    entryCost?: BigIntFieldUpdateOperationsInput | bigint | number
    rewardStructure?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformCompat?: NullableJsonNullValueInput | InputJsonValue
    likeCount?: IntFieldUpdateOperationsInput | number
    playCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyGiftInput = {
    id?: string
    conversationId: string
    senderId: string
    receiverId?: string | null
    roomId?: string | null
    messageType: $Enums.MessageType
    content?: string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    repliedToMessageId?: string | null
  }

  export type MessageUpdateWithoutGiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneWithoutReceivedMessagesNestedInput
    room?: ChatRoomUpdateOneWithoutMessagesNestedInput
    repliedToMessage?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutRepliedToMessageNestedInput
    reports?: ReportUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutGiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repliedToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: MessageUncheckedUpdateManyWithoutRepliedToMessageNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutGiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: NullableJsonNullValueInput | InputJsonValue
    isDeletedFor?: NullableJsonNullValueInput | InputJsonValue
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    reactions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repliedToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCreateManyReportedStreamInput = {
    id?: string
    reporterId: string
    reportedUserId?: string | null
    reportedRoomId?: string | null
    reportedMessageId?: string | null
    reason: string
    description?: string | null
    status?: $Enums.ReportStatus
    reviewedById?: string | null
    reviewTimestamp?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportUpdateWithoutReportedStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
    reportedUser?: UserUpdateOneWithoutReportsReceivedNestedInput
    reportedRoom?: ChatRoomUpdateOneWithoutReportsNestedInput
    reportedMessage?: MessageUpdateOneWithoutReportsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReportedStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedRoomId?: NullableStringFieldUpdateOperationsInput | string | null
    reportedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}